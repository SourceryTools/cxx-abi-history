<HTML>

<HEAD>
<title>C++ ABI for IA-64: Data Layout</title>

<link rel=stylesheet href=small-table.css type="text/css">
<link rel=stylesheet href=code.css type="text/css">

<hr>

<font size=6><i><b>
<p>
C++ ABI for IA-64: Data Layout
</b></i></font>

<font size=-1>
<p>
<i>Revised 29 December 1999</i>

</center>

</HEAD>

<BODY>

<p> <hr> <p>
<h3> Contents </h3>

<ul>
<li> <a href=#general> General </a>
<li> <a href=#definitions> Definitions </a>
<li> <a href=#pod> POD Data Types </a>
<li> <a href=#member-pointers> Member Pointers </a>
<li> <a href=#class-types> Non-POD Class Types </a>
<li> <a href=#vtable> Virtual Table Layout </a>
<li> <a href=#vtable-ctor> Virtual Tables During Object Construction </a>
<li> <a href=#rtti> Run-Time Type Information (RTTI) </a>
<li> <a href=#external-names> External Names </a>
</ul>

<p> <hr> <p>
<h3> Revisions </h3>

<p>
<font color=blue>[991229]</font>
Clarify definition of nearly empty class, layout of virtual bases.

<p>
<font color=blue>[991203]</font>
Added description of vfunc calling convention from Jason.

<p>
<font color=blue>[991104]</font>
Noted pair of vtable entries for virtual destructors.

<p>
<font color=blue>[991019]</font>
Modified RTTI proposal for 14 October decisions.

<p>
<font color=blue>[991006]</font>
Added RTTI proposal.

<p>
<font color=blue>[990930]</font>
Updated to new vtable layout proposal.

<p>
<font color=blue>[990811]</font>
Described member pointer representations, virtual table layout.

<p>
<font color=blue>[990730]</font>
Selected first variant for empty base allocation; removed others.


<p> <hr> <p>
<a name=general>
<h3> General </h3>

In what follows, we define the memory layout for C++ data objects.
Specifically, for each type, we specify the following information about
an object O of that type:
<ul>
<li> the <i>size</i> of an object, <i>sizeof</i>(O);
<li> the <i>alignment</i> of an object, <i>align</i>(O); and
<li> the <i>offset</i> within O, <i>offset</i>(C),
     of each data component C, i.e. base or member.
</ul>

<p> For purposes internal to the specification,
we also specify:

<ul>
<li> <i>dsize</i>(O):
the <i>data size</i> of an object,
which intuitively is sizeof(O) minus the size of tail padding.

<p>
<li> <i>nvsize</i>(O):
the <i>non-virtual size</i> of an object,
which intuitively is dsize(O) minus the size of virtual bases.

</ul>

<p> <hr> <p>
<a name=definitions>
<h3> Definitions </h3>

<p>
The descriptions below make use of the following definitions:

<dl>

<p>
<dt> <i>alignment</i> of a type T (or object X)</dt>
<dd>
A value A such that any object X of type T has an address satisfying
the constraint that &X modulo A == 0.

<p>
<dt> <i>empty class</i> </dt>
<dd>
A class with no non-static data members other than zero-width bitfields,
no virtual functions, no virtual base classes,
and no non-empty non-virtual base classes.

<p>
<dt> <i>nearly empty class</i> </dt>
<dd>
A class that:
<ul>
<li> has no non-static data members other than zero-width bitfields,
<li> has no base classes that are not either empty or nearly empty,
<li> has at most one nearly empty base class, and
<li> has at least one virtual function, possibly inherited from a base class.
</ul>

Such a class contains only a Vptr.

<p>
<dt> <i>polymorphic class</i> </dt>
<dd>
A class requiring a virtual table pointer
(because it or its bases have one or more virtual member functions or
virtual base classes).

<p>
<dt> <i>primary base class</i> </dt>
<dd>
For a polymorphic class,
the unique base class (if any) with which it shares the Vptr at offset 0.

</dl>

<p> <hr> <p>
<a name=pod>
<h3> POD Data Types </h3>

The size and alignment of C POD types is as specified by the base (C) ABI.
Type bool has size and alignment 1.
All of these types have data size and non-virtual size equal to their size.
(We ignore tail padding for PODs because the Standard does not allow us
to use it for anything else.)


<p> <hr> <p>
<a name=member-pointers></a>
<h3> Member Pointers </h3>

<p>
A pointer to data member is an offset from the base
address of the class object containing it,
represented as a <code>ptrdiff_t</code>.
It has the size, data size, non-virtual size, and alignment
of a <code>ptrdiff_t</code>.

<p>
A pointer to member function is a pair <ptr, adj> as follows:

<dl>
<p>
<dt> <code>ptr</code>:
<dd> For a non-virtual function, this field is a simple function pointer.
     (Under current base IA-64 psABI conventions,
     that is a pointer to a GP/function address pair.)
     For a virtual function,
     it is 1 plus twice the Vtable offset of the function.
     The value zero is a NULL pointer.

<p>
<dt> <code>adj</code>:
<dd> The required adjustment to <i>this</i>,
     represented as a <code>ptrdiff_t</code>.
</dl>

<p>
It has the size, data size, non-virtual size, and alignment
of a class containing those two members, in that order.
(For 64-bit IA-64, that will be 16, 16, 16, and 8 bytes respectively.)



<p> <hr> <p>
<a name=class-types></a>
<h3> Non-POD Class Types </h3>

For non-POD class types C, assume that all component types
(i.e. base classes and non-static data member types)
have been laid out, defining size, data size, and alignment.
Layout (of type C) is done using the following procedure.

<ol type=I>
<p>
<li> <h5> Initialization </h5>
  <ol type=1>
  <p>
  <li> Initialize sizeof(C) to zero, align(C) to one, dsize(C) to zero.
  <p>
  <li> If C is a polymorphic type:
      <ol type=a>
      <p>
      <li> If C has a polymorphic base class,
	   attempt to choose a primary base class B.
	   It is the first non-virtual polymorphic base class, if any,
	   or else the first nearly empty virtual base class.
	   Allocate it at offset zero, and set
	   sizeof(C) to sizeof(B), align(C) to align(B), dsize(C) to nvsize(B).

	   <p>
	   This step allocates only B's non-virtual part,
	   i.e. excluding any direct or indirect bases.

      <p>
      <li> Otherwise, allocate the vtable pointer for C at offset zero,
	   and set sizeof(C), align(C), and dsize(C) to the appropriate
	   values for a pointer (all 8 bytes for IA-64 64-bit ABI).
      </ol>
  </ol>

<p>
<li> <h5> Non-Virtual-Base Allocation </h5>
<p>
For each data component D (i.e. base or non-static data member)
except virtual bases,
first the non-virtual base classes in declaration order
and then the non-static data members in declaration order,
allocate as follows:

  <ol type=1>

  <p>
  <li> If D is not an empty base class,
	start at offset dsize(C),
	incremented if necessary to alignment align(type(D)).
	Place D at this offset unless doing so would result in two
	components (direct or indirect) of the same type having the
	same offset.
	If such a component type conflict occurs,
	increment the candidate offset by align(type(D)),
	and try again,
	repeating until success occurs
	(which will occur no later than sizeof(C) incremented to the
	required alignment).

	<p>
	If D is a base class, this step allocates only its non-virtual
	part, i.e. excluding any direct or indirect bases.

	<p>
	Update sizeof(C) to max (sizeof(C), offset(D)+nvsize(D)).
	Update align(C) to max (align(C), align(D)).
	If D is a base class (not empty in this case),
	update dsize(C) to offset(D)+nvsize(D).
	If D is a data member,
	update dsize(C) to max (offset(D)+dsize(D), offset(D)+1).

  <p>
  <li> If D is an empty base class,
	its allocation is similar to the first case above,
	except that additional candidate offsets are considered before
	starting at dsize(C).
	First, attempt to place D at offset zero.
	If unsuccessful (due to a component type conflict),
	proceed with attempts at dsize(C) as for non-empty bases.
	As for that case, if there is a type conflict at dsize(C)
	(with alignment updated as necessary),
	increment the candidate offset by align(type(D)),
	and try again,
	repeating until success occurs.

	<p>
	Once offset(D) has been chosen,
	update sizeof(C) to max (sizeof(C), offset(D)+sizeof(D)).
	Note that align(D) is 1, so no update of align(C) is needed.
	Similarly, since D is an empty base class,
	no update of dsize(C) is needed.

  </ol>

  <p>
  After all such components have been allocated,
  set nvsize(C) = dsize(C).

<p>
<li> <h5> Virtual Base Allocation </h5>
<p>
Finally allocate any direct or indirect virtual base classes
(except one selected as the primary base class in I-2a, if any)
as we did non-virtual base classes in step II-1,
in depth-first (in the inheritance graph) declaration order.
Update sizeof(C) to max (sizeof(C), offset(D)+nvsize(D)).
If non-empty, also update align(C) and dsize(C) as in II-1.

<p>
<li> <h5> Finalization </h5>
<p>
Round sizeof(C) up to a non-zero multiple of align(C).

</ol>


<p> <hr> <p>
<a name=vtable></a>
<h3> Virtual Table Layout </h3>

<p>
<h4> General </h4>

<p>
A <i>virtual table</i> (<i>vtable</i>) is a table of information used
to dispatch virtual functions,
to access virtual base class subobjects,
and to access information for runtime type identification (RTTI).
Each class that has virtual member functions or virtual bases
has an associated set of vtables.
There may be multiple vtables for a particular class,
if it is used as a base class for other classes.
However, the vtable pointers within all the objects (instances)
of a particular most-derived class point to the same set of vtables.

<p>
A vtable consists of a sequence of offsets, data pointers,
and function pointers, as well as structures composed of such items.
We will describe below the sequence of such items.
Their offsets within the vtable are determined by that allocation
sequence and the natural ABI size and alignment,
just as a data struct would be.  In particular:
<ul>
<li> Offsets are of type <code>ptrdiff_t</code> unless otherwise stated.
<li> Data pointers have normal pointer size and alignment.
<li> Function pointers remain to be defined.
     One possibility is that they will be
     &lt;function address, GP address> pairs, with pointer alignment.
</ul>

<p>
In general, what we consider the address of a vtable
(i.e. the address contained in objects pointing to a vtable)
may not be the beginning of the vtable.
We call it the <i>address point</i> of the vtable.
The vtable may therefore contain components at either positive or
negative offsets from its address point.

<p>
<h4> Components </h4>

<p>
Each vtable consists of the following components:

<ul>
<p>
<li>
<i>Base offsets</i> are used to access
the virtual bases of an object,
Such an entry is a displacement to a virtual base subobject from the
location within the object of the vtable pointer that addresses this vtable.
These entries are only necessary if the class directly
(or <font color=red>indirectly?</font>)
inherits from virtual base classes.
The values can be positive or negative.

<p>
<li>
<i>vcall offsets</i> are used to perform pointer adjustment
for overridden virtual functions.
These entries are allocated when the
class is used as a virtual base.
They are referenced by the virtual functions
to find the necessary adjustment from the base to the derived class,
if any.
These values may be positive or negative.

<p>
<li>
The <i>offset to top</i> holds the displacement to the top of the object
from the location within the object of the vtable pointer that addresses
this vtable,
as a <code>ptrdiff_t</code>.
A negative value indicates the vtable pointer is part of an embedded
base class subobject; otherwise it is zero.
The offset provides a way to find the top of the object from any base
subobject with a vtable pointer.
This is necessary for dynamic_cast<void*> in particular.

<p>
<li>
The <i>typeinfo pointer</i> points to the typeinfo object used for RTTI.
All entries in each of the vtables for a given class must point to the
same typeinfo object.
A correct implementation of typeinfo equality is to check pointer equality.

<p>
<li>
<i>Virtual function pointers</i> are used for virtual function dispatch.
Each pointer holds either the address of a virtual function of the class
(or the address of a secondary entry point that performs certain
adjustments before transferring control to a virtual function.)
In the case of shared library builds,
a virtual function pointer entry contains a pair of components
(each 64 bits in the 64-bit IA-64 ABI):
the value of the target GP value and the actual function address.
That is, rather than being a normal function pointer,
which points to such a two-component descriptor,
a virtual function pointer entry is the descriptor.

<p>
<font color=red>
Note that the entries for virtual destructors are actually pairs of entries.
The first performs the destruction without calling delete() on the object,
while the second calls delete() after destroying the object.
Both destroy any virtual bases;
a separate, non-virtual entry performs destruction of the object but
not its virtual base subobjects, and does not call delete().
</font>

<p>
<li>
<i>Secondary vtables</i> are copies of the vtables for base classes of the
current class
(copies in the sense that they have the same layout,
though virtual function pointers may point to overriding functions).

</ul>

<p>
The virtual pointer in the object points to the first virtual
function pointer.

<p>
<h4> Virtual Table Order </h4>

<p>
A virtual table's components are laid out in the following order,
analogous to the corresponding object layout.

<ol>
<p>
<li>
If vcall offsets are required,
they come first,
with ordering as defined in categories 3 and 4 below.

<p>
<li>
If virtual base offsets are required,
they come next, with ordering as defined in categories 3 and 4 below.

<p>
<li>
The offset to top field is next.
It is present if the class has virtual functions.
<font color=red>
Question: Should we include the RTTI fields for classes with no virtual
functions (only virtual bases), too?
</font>

<p>
<li>
The typeinfo pointer field is next.
It is present if the class has virtual functions.

<p>
<li>
The vtable address point points here,
i.e. this is the address of the vtable contained in an object's vptr.

<p>
<li>
Virtual function pointers come next,
in order of declaration of the corresponding member function in the class.
They appear both for newly introduced functions and overridden functions.

<p>
<li>
The secondary vtables are last.
They are laid out in the same order used for the bases themselves in
the object.

</ol>

<p>
<h4> Virtual Table Construction </h4>

<p>
In this section, we describe how to construct the vtable for an class,
given vtables for all of its base classes.
To do so, we divide classes into several categories,
based on their base class structure.

<p>
<h5> Category 0: Trivial </h5>

Structure:
<ul>
<li> No virtual base classes.
<li> No virtual functions.
</ul>

<p>
Such a class has no associated vtable,
and its objects contain no vptr.

<p>
<h5> Category 1: Leaf </h5>

Structure:
<ul>
<li> No inherited virtual functions.
<li> No virtual base classes.
<li> Declares virtual functions.
</ul>

<p>
The vtable contains an RTTI field followed by virtual function pointers.
There is one function pointer entry for each
virtual function declared in the class.

<p>
<h5> Category 2: Non-Virtual Bases </h5>

Structure:
<ul>
<li> Only non-virtual base classes.
<li> Inherits virtual functions.
</ul>

<p>
The class has a vtable for each base class that has a vtable.
The class's vtables are constructed from copies of the base class vtables.
The entries are the same, except:

<ul>
<p>
<li> The RTTI fields contain information for the class,
     rather than for the base class. 

<p>
<li> The function pointer entries for virtual functions inherited from
     the base class and overridden by this class are replaced with the
     addresses of the overriding functions
     (or the corresponding adjustor secondary entry points).
</ul>

<p>
For a base class <code>Base</code>,
and a derived class <code>Derived</code> for which we are constructing
this set of vtables,
we shall refer to the vtable for <code>Base</code> as
<code>Base-in-Derived</code>.
The vptr of each base subobject of an object of the derived class will
point to the corresponding base vtable in this set.

<p>
The vtable copied from the primary base class is also called the
primary vtable;
it is addressed by the vtable pointer at the top of the object.
The other vtables of the class are called secondary vtables;
they are addressed by vtable pointers inside the object.

<p>
Following the function pointer entries that correspond to those of the
primary base class,
the primary vtable holds the following additional entries at its tail:
<ul>
<li> Entries for virtual functions introduced by this class.
<li> Entries for overridden virtual functions not already in the vtable.
     (These are also called replicated entries because they are already
     in the secondary vtables of the class.)
</ul>

The primary vtable, therefore,
has the base class functions appearing before the derived class functions.
The primary vtable can be viewed as two vtables accessed
from a shared vtable pointer. 

<p>
<i>Note</i>:
Another benefit of replicating virtual function entries is that it
reduces the number of this pointer adjustments during virtual calls.
Without replication,
there would be more cases where the this pointer would have to be
adjusted to access a secondary vtable prior to the call.
These additional cases would be exactly those where the function
is overridden in the derived class,
implying an additional thunk adjustment back to the original pointer.
Thus replication saves two adjustments for each virtual call to an
overridden function introduced by a non-primary base class. 

<p>
<h5> Category 3: Virtual Bases Only </h5>

Structure:
<ul>
<li> Only virtual base classes.
<li> Base classes are not empty or nearly empty.
</ul>

<p>
The class has a vtable for each virtual base class that has a vtable.
These are all secondary vtables and are constructed from copies of the
base class vtables according to the same rules as in Category 2,
except that the vtable for a virtual base A also includes a vcall
offset entry for each virtual function represented in A's primary
vtable and the secondary vtables from A's non-virtual bases.
The vcall offset entries are allocated from the inside out,
in the same order as the functions appear in A's vtables.

<p>
The class also has a vtable that is not copied from the virtual base
class vtables.
This vtable is the primary vtable of the class and is addressed by the
vtable pointer at the top of the object, which is not shared.
It holds the following function pointer entries: 

<ul>
<p>
<li> Entries for virtual functions introduced by this class.

<p>
<li> Entries for overridden virtual functions.
     (These are also called replicated entries,
     because they are already in the secondary vtables of the class.)
</ul>

<p>
The primary vtable also has virtual base offset entries
to allow finding the virtual base subobjects.
There is one virtual base offset entry for each virtual base class.
For a class that inherits only virtual bases,
the entries are at increasing negative offsets from the address point
of the vtable in the order in which the
virtual bases appear in the class declaration,
that is, the entry for the leftmost virtual
base is closest to the address point of the vtable. 


<p>
<h5> Category 4: Complex </h5>

Structure:
<ul>
<li> None of the above,
     i.e. directly or indirectly inherits both virtual and non-virtual
     base classes, or at least one nearly empty virtual base class.
</ul>

<p>
The rules for constructing vtables of the class are a combination of
the rules from Categories 2 and 3,
and for the most part can be determined inductively.
However the rules for placing virtual base offset entries in the
vtables requires elaboration. 

<p>
The primary vtable has virtual base offset entries for all virtual
bases directly or indirectly inherited by the class.
Each secondary vtable has entries only for virtual
bases visible to the corresponding base class.
The entries in the primary vtable are ordered so that entries for
virtual bases visible to the primary base class are placed closest
to the vtable address point, i.e. at higher addresses,
while entries for virtual bases only visible to this class are further
from the vtable address point, i.e. at lower addresses. 

<p>
For virtual bases only visible to this class,
the entries are in the reverse order in which the virtual bases are
encountered in a depth-first, left-to-right traversal of the
inheritance graph formed by the class definitions.
Note that this does not follow the
order that virtual bases are placed in the object. 

<p>
<a name=vcall>
<h4> Virtual Function Calling Convention </h4>
</a>

<p>
This section sketches the calling convention for virtual functions,
based on the above virtual table layout.

<p>
Note: for virtual functions not inherited from a virtual base, 
regular thunks are a suitable implementation,
since the implementation can emit them immediately before the
function to avoid the indirect branch penalty.
We use offsets in the vtable for functions that come from a virtual base,
because it is impossible to predict what the offset between the
current class and its virtual base will
be in classes derived from the current class.

<p>
The calling convention is as follows:

<ul>
<li>vtable layout:
<p>
For each virtual function defined in a class,
we add an entry to the primary vtable if one is not already there.
In particular, a definition which overrides a function inherited from
a secondary base gets a new slot in the primary vtable.
We do this to avoid useless adjustments when calling a virtual
function through a pointer to the most derived class.

<p>
When a class is used as a virtual base,
we add a vcall offset slot to the beginning of its vtable for each of
the virtual functions it provides,
whether in its primary or secondary vtables.
Derived classes which override these functions will use the slots to
determine the adjustment necessary.

<p>
<li>Caller:
<p>
The caller adjusts the 'this' argument to 
point to the class which last overrode the function being called.
The result provides both the 'this' argument and the vtable pointer
for finding the function we want.

<p>
<li>Callee:
<p>
Each virtual function 'f' defined in a class 'A'
has one entry point which takes an A*,
and performs no adjustment.
The primary vtable for A points to this entry point.

<p>
For each secondary vtable
from a non-virtual base class 'B' which defines f,
an additional entry point is generated
which performs the constant adjustment from B* to A*.

<p>
For each secondary vtable from a virtual base class 'C' which defines f,
an additional entry point is generated which performs the adjustment
from C* to A* using the vcall offset for f stored in the secondary
vtable for C.

<p>
For each secondary vtable from a base 'D' which is a non-virtual base
of a virtual base 'E',
an additional entry point is generated which
first performs the constant adjustment from D* to E*,
then the adjustment from E* to A* using the vcall offset for f stored
in the secondary vtable for E.

<p>
<li>Implementation
<p>
Note that the ABI only specifies the multiple entry points;
how those entry points are provided is unspecified.
An existing compiler which uses thunks could be converted to use this
ABI by only adding support for the vcall offsets.
A more efficient implementation would be to emit all of the thunks
immediately before the non-adjusting entry point to the function.
Another might use predication rather than branches to reach the main function.
Another might emit a new copy of the function for each entry point;
this is a quality of implementation issue.
</ul>



<i>
<font color=red>
<p>
<h4> Issues: </h4>
<ul>
<li> A-6:  Duplicate base structure representation.
<li> B-2:  Will contain one entry per return type for covariant returns.
</ul>
</font>
</i>


<p> <hr> <p>
<a name=vtable-ctor>
<h3> Vtables During Object Construction (open issue C-4)</h3>

<p>
In some situations,
a special vtable called a construction vtable is used during
the execution of base class constructors and destructors.
These vtables are for specific cases of virtual inheritance.

<p>
During the construction of a class object, the object assumes the
type of each of its base classes, as each base class subobject is
constructed. RTTI queries in the base class constructor will return  
the type of the base class, and virtual calls will resolve to member  
functions of the base class rather than the complete class. Normally,  
this behavior is accomplished by setting, in the base class
constructor, the object's vtable pointers to the addresses of the
vtables for the base class.

<p>
However, if the base class has direct or indirect virtual bases, the  
vtable pointers have to be set to the addresses of construction
vtables. This is because the normal base class vtables may not hold  
the correct virtual base index values to access the virtual bases of  
the object under construction, and adjustment addressed by these
vtables may hold
the wrong this parameter adjustment if the adjustment is to cast
from a virtual base to another part of the object. The problem is
that a complete object of a base class and a complete object of a
derived class do not have virtual bases at the same offsets.

<p>
A construction vtable holds the virtual function addresses and the
RTTI information associated with the base class and the virtual base  
indexes and the addresses of adjustor entry points with this
parameter adjustments associated with objects of the complete class.

<p>
To ensure that the vtable pointers are set to the appropriate
vtables during base class construction, a table of vtable pointers,  
called the VTT, which holds the addresses of construction and
non-construction vtables is generated for the complete class. The
constructor for the complete class passes to each base class
constructor a pointer to the appropriate place in the VTT where the  
base class constructor can find its set of vtables. Construction
vtables are used in a similar way during the execution of base class  
destructors.



<p> <hr> <p>
<a name=rtti>
<h3> Run-Time Type Information (RTTI) </h3>

<p>
The C++ programming language definition implies that information about
types be available at run time for three distinct purposes:
<ol type=a>
<li> to support the typeid operator,
<li> to match an exception handler with a thrown object, and
<li> to implement the dynamic_cast operator.
</ol>
(c) only requires type information about polymorphic class types,
but (a) and (b) may apply to other types as well;
for example, when a pointer to an int is thrown,
it can be caught by a handler that catches "int const*".


<p>
<h5>Deliberations</h5>
<p>
The following conclusions were arrived at by the attending members of
the C++ IA-64 ABI group:

<ul>
<p>
<li> The exact layout for type_info objects is dependent on whether a
    32-bit or 64-bit model is supported.
<p>
<li> Advantage should be taken of COMDAT sections and symbol preemption:
    two type_info pointers point to equivalent types if and only if the
    pointers are equal.
<p>
<li> A simple dynamic_cast algorithm that is efficient in the common
    case of base-to-most-derived cast case is preferable to more
    sophisticated ideas that handle deep-base-to-in-between-derived
    casts more efficiently at a slight cost to the common case.
    Hence, the original scheme of providing a hash-table into the
    list of base classes
    (as is done e.g. in the HP aC++ compiler)
    has been dropped.
<p>
<li> The GNU egcs development team has implemented an idea of this ABI
    group to accelerate dynamic_cast operations by a-posteriori
    checking a "likely outcome".
    The interface of std::__dynamic_cast therefore keeps the
    src2dst_offset hint.
<p>
<li> std::__extended_type_info is dropped.
<p>
<li> It was decided to only keep direct base information about a class type.
    Indirect base information can be found by chasing type_info pointers
    (and care should be taken to determine ambiguous base class types).
<p>
<li> Different class types are introduced for class that (a) have no bases,
    (b) use only single inheritance, and (c) use multiple inheritance.
<p>
<li> The typeinfo structure for a class type with associated virtual
    tables is emitted as part of the set of virtual tables.
    It precedes the tables proper
    (not explicitly decided, but assumed:
    it also precedes auxiliary tables for locating construction vtables).
</ul>

<p>
<h5>Place of emission</h5>

<p>
It is probably desirable to minimize the number of places where a
particular bit of RTTI is emitted.
For polymorphic types, a similar problem occurs for virtual function tables,
and hence the information can be appended at the end
of the primary vtable for that type.
For other types, they must presumably be emitted at the location
where their use is implied:
the object file containing the typeid, throw or catch.

<p>
Basic type information (such as for "int", "bool", etc.)
can be kept in the run-time support library.
Specifically, this proposal is to place in the
run-time support library type_info objects for the following types:
<ul>
<li> void*, void const*; and
<li> X, X* and X const*,
    for every X in: bool, wchar_t, char, unsigned char, signed char,
    short, unsigned short, int, unsigned int, long, unsigned long, long long,
    unsigned long long, float, double, long double.
</ul>
(Note that various other type_info objects for class types may reside
in the run-time support library by virtue of the preceding rules;
e.g., that of std::bad_alloc.)


<p>
<h5>The typeid operator</h5>

<p>
The typeid operator produces a reference to a std::type_info structure
with the following public interface:

<pre><code>
  struct std::type_info {
     virtual ~type_info();
     bool operator==(type_info const&) const;
     bool operator!=(type_info const&) const;
     bool before(type_info const&) const;
     char const* name() const;
  };
</pre></code>

<p>
Assuming that after linking and loading only one type_info structure is
active for any particular type symbol,
the equality and inequality operators can be
written as address comparisons:
to type_info structures describe the same type
if and only if they are the same structure (at the same address).
In a flat address space
(such as that of the IA-64 architecture),
the before() member is also easily written in terms of an address comparison.
The only additional piece of information that is required is the
NTBS that encodes the name.
The type_info structure itself can hold a pointer into a read-only segment
that contains the text bytes.


<p>
<h5>Matching throw expressions with handlers</h5>

<p>
When an object is thrown a copy is made of it and the type of that copy
is TT.
A handler that catches type HT will match that throw if:
<ul>
  <li> HT is equal to TT except that HT may be a reference and that HT
	may have top-level cv qualifiers
	(i.e., HT can be "TT cv", "TT&" or "TT cv&"); or
  <li> HT is a reference to a public and unambiguous base type of TT; or
  <li> HT has a pointer type to which TT can be converted by a standard
	pointer conversion (though only public,
	unambiguous derived-to-base conversions are permitted)
	and/or a qualification conversion.
</ul>

<p>
This implies that the type information must keep a description of the public,
unambiguous inheritance relationship of a type, as well as the const
and volatile qualifications applied to types.


<p>
<h5>The dynamic_cast operator</h5>

<p>
Although dynamic_cast can work on pointers and references,
from the point of view of representation we need only to worry
about polymorphic class types.
Also, some kinds of dynamic_cast operations are handled at compile time
and do not need any RTTI.
There are then three kinds of truly dynamic cast operations:
<ul>
<li> dynamic_cast&lt;void cv*>, which returns a pointer to the complete lvalue,
<li> dynamic_cast operation from a base class to a derived class, and
<li> dynamic_cast across the hierarchy which can be seen as a cast to
	the complete lvalue and back to a sibling base.
</ul>

<p>
The most common kind of dynamic_cast is base-to-derived in a singly
inherited hierarchy.

<p>
<h5>RTTI layout</h5>

<ol type=1>

<p>
<li>
The RTTI layout for a given type depends on whether a 32-bit or
64-bit mode is in effect.

<p>
<li>
Every vtable shall contain one entry describing the offset from a
vptr for that vtable to the origin of the object containing that vptr
(or equivalently: to the vptr for the primary vtable).
This entry is directly useful to implement dynamic_cast<void cv*>,
but is also needed for the other truly dynamic casts.
This entry is located two words ahead of the location
pointed to by the vptr (i.e., entry "-2").
This entry is present in all vtables,
even for classes having virtual bases but no virtual functions.

<p>
<li>
Every vtable shall contain one entry pointing to an object derived
from std::type_info.
This entry is located at the word preceding the location
pointed to by the vptr (i.e., entry "-1").
The entry is allocated in all vtables;
for classes having virtual bases but no virtual functions,
the entry is zero.
This entry is coded as an offset with respect to the virtual table origin,
rather than as a pointer
(thereby avoiding run-time relocations).

<p>
std::type_info contains just two pointers:
<ul>
<li> its vptr
<li> a pointer to a NTBS representing the name of the type
</ul>

<p>
The possible derived types are:
<ul>
  <li> std::__fundamental_type_info
  <li> std::__pointer_type_info
  <li> std::__reference_type_info
  <li> std::__array_type_info
  <li> std::__function_type_info
  <li> std::__enum_type_info
  <li> std::__class_type_info
  <li> std::__si_class_type_info
  <li> std::__vmi_class_type_info
  <li> std::__ptr_to_member_type_info
</ul>

<p>
<li>
std::fundamental_type_info adds no fields to std::type_info;

<p>
<li>
std::__pointer_type_info adds two fields (in this order):
<ul>
  <p>
  <li> a word describing the cv-qualification of what is pointed to
    (e.g., "int volatile*" should have the "volatile" bit set in that word)
  <p>
  <li> a pointer to the std::type_info derivation for the unqualified type
    being pointed to
</ul>

<p>
Note that the first bits should not be folded into the pointer because
we may eventually need more qualifier bits (e.g. for "restrict").
The bit 0x1 encodes the "const" qualifier;
the bit 0x2 encodes "volatile".

<p>
<li>
std::__reference_type_info is similar to std::__pointer_type_info
but describes references.

<p>
<li>
std::__array_type_info and std::__function_type_info do not add fields
to std::type_info
(these types are only produced by the typeid operator;
they decay in other contexts).
std::__enum_type_info does not add fields either.

<p>
<li>
Three different types are used to represent type information:

<ol type=a>
<p>
<li>
std::__class_type_info is used for class types having no bases,
and is also a base type for the other two class type representations.
It adds one word to std::type_info with flags describing details
about the class (most for use of the derived classes):
  <ul>
  <li> 0x1: contains multiply inherited subobject
  <li> 0x2: is polymorphic
  <li> 0x4: has virtual bases
  <li> 0x8: has privately inherited base
  </ul>

<p>
<li>
For classes containing only a single, nonvirtual inheritance hierarchy,
class std::__si_class_type_info is used.
It adds to std::__class_type_info
a single pointer to the type_info structure for the base type.

<p>
<li>
For class containing (directly or indirectly)
a multiple or virtual inheritance component in their hierarchy,
std::__vmi_class_type_info is used.
It is derived from std::__class_type_info, and adds:
  <ul>
  <li> a word with the number of direct base class descriptions that follow
  <li> base class descriptions for every direct base;
       each description is of the type:
<pre><code>
      struct std::__base_class_info {
         std::type_info *type;
         std::ptrdiff_t offset;
	 int vmi_flags;
      };
</pre></code>
  </ul>

<p>
The vmi_flags field contains one or more flags:
  <ul>
  <li> 0x1: Base class is virtual
  <li> 0x2: Base class is public
  </ul>

</ol>

<p>
<li>
The std::__ptr_to_member_type_info type adds two fields to std::type_info:
<ul>
<li> a pointer to a std::__class_type_info (e.g., the "A" in "int A::*")
<li> a pointer to a std::type_info corresponding to the member type
    (e.g., the "int*" in "int A::*")
<li> a word describing the cv-qualification of what is pointed to
    (see std::__pointer_type_info)
</ul>

</ol>


<h5>std::type_info::name()</h5>
<p>
The null-terminated byte string returned by this routine is
the mangled name of the type.


<p>
<h5>The dynamic_cast algorithm</h5>

<p>
Dynamic casts to "void cv*" are inserted inline at compile time.
So are dynamic casts of null pointers and dynamic casts that are really
static.

<p>
This leaves the following test to be implemented in the run-time
library for truly dynamic casts of the form "dynamic_cast<T>(v)":
(see [expr.dynamic_cast] 5.2.7/8)

<ul>
<p>
<li>
If, in the most derived object pointed (referred) to by v, v points
(refers) to a public base class sub-object of a T object
[note: this can be checked at compile time],
and if only one object of type T is derived
from the sub-object pointed (referred) to by v,
the result is a pointer (an lvalue referring) to that T object.

<p>
<li>
Otherwise, if v points (refers) to a public base class sub-object
of the most derived object,
and the type of the most derived object has an
unambiguous public base class of type T,
the result is a pointer
(an lvalue referring)
to the T sub-object of the most derived object. 

<p>
<li>
Otherwise, the run-time check fails.
</ul>

<p>
The first check corresponds to a "base-to-derived cast" and the second
to a "cross cast".
These tests are implemented by std::__dynamic_cast:

<pre><code>
   void* std::__dynamic_cast ( void *sub,
			       std::__class_type_info *src,
			       std::__class_type_info *dst,
			       std::ptrdiff_t src2dst_offset);
   /* sub: source address to be adjusted; nonnull, and since the
    *      source object is polymoprhic, *(void**)sub is a vptr.
    * src: static type of the source object.
    * dst: destination type (the "T" in "dynamic_cast<T>(v)").
    * obj2sub_offset: a static hint about the location of the
    *    source subobject with respect to the complete object;
    *    special negative values are:
    *       -1: no hint
    *       -2: src is not a public base of dst
    *       -3: src is a multiple public base type but never a
    *           virtual base type
    *    otherwise, the src type is a unique public nonvirtual
    *    base type of dst at offset obj2sub_offset from the
    *    origin of dst.
    */

</pre></code>

<p>
<h5>The exception handler matching algorithm</h5>

<p>
Since the RTTI related exception handling routines are "personality specific",
no interfaces need to be specified in this document
(beyond the layout of the RTTI data).


<p> <hr> <p>
<a name=external-names>
<h3> External Names (a.k.a. Mangling) </h3>

<i>
&lt;To be specified.>
</i>

<p>
<hr>

<p>
Please send corrections to <a href=mailto:dehnert@sgi.com>Jim Dehnert</a>.

</BODY>
</HTML>
