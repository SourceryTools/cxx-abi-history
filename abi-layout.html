<HTML>

<HEAD>
<title>C++ ABI for IA-64: Data Layout</title>

<link rel=stylesheet href=small-table.css type="text/css">
<link rel=stylesheet href=code.css type="text/css">

<hr>

<font size=6><i><b>
<p>
C++ ABI for IA-64: Data Layout
</b></i></font>

<font size=-1>
<p>
<i>Revised 16 February 2000</i>

</center>

</HEAD>

<BODY>


<p> <hr> <p>
<a name=intro>
<h3> Introduction </h3>

In this document, we define the memory layout for C++ data objects,
including both predefined and user-defined data types,
as well as internal compiler generated objects such as virtual tables.

<p>
<font color=blue>
Note that the body of this document makes free use of a number of terms
which are defined in the <i><b>Definitions</b></i> section below.
</font>

<p> <hr> <p>
<h3> Contents </h3>

<ul>
<li> <a href=#general> General </a>
<li> <a href=#definitions> Definitions </a>
<li> <a href=#pod> POD Data Types </a>
<li> <a href=#member-pointers> Member Pointers </a>
<li> <a href=#class-types> Non-POD Class Types </a>
<li> <a href=#vtable> Virtual Table Layout </a>
<li> <a href=#vtable-ctor> Virtual Tables During Object Construction </a>
<li> <a href=#array-new> Array Operator new Cookies </a>
<li> <a href=#rtti> Run-Time Type Information (RTTI) </a>
<li> <a href=#external-names> External Names </a>
</ul>

<!--
<p> <hr> <p>
<h3> Outstanding Questions </h3>
<font color=red>
There are outstanding questions in the body of the document to be
clarified:

<ul>

</ul>
</font>
-->

<p> <hr> <p>
<h3> Revisions </h3>

<p>
<font color=blue>[000214]</font>
Complete array new cookie specification.
Remove unnecessary RTTI flags.
Correct repeated inheritance flag description.
Move all type_info subclasses in namespace abi, not namespace std.
Note requirements for an implementation to prevent users from emitting
invalid vtables for RTTI classes.
Include construction vtable proposal.

<p>
<font color=blue>[000203]</font>
Incorporate discussion of 3 Febrary.
Remove __reference_type_info (issue A-22).
Restructure struct RTTI and flags (issue A-23).
Clarify __base_class_info layout.

<p>
<font color=blue>[000125]</font>
Incorporate discussion of 20 January, generally clarifications.
Resolved A-19 (choice of a primary virtual base).
Answered Nathan's questions about RTTI.
Included RTTI "Deliberations" as rationale notes in the specification,
or removed redundant ones.
Added array operator new section.

<p>
<font color=blue>[000119]</font>
Clarify when virtual base offsets are required.
Note that a vtable has offset-to-top and RTTr entries for classes with
virtual bases even if there are no virtual functions.
Resolve allocation of a virtual base class that is a primary base for
another base (A-17).
Resolve choice of a primary virtual base class that is a primary base for
another base (A-19).
Describe the (non-)effect of virtual bases on the alignment of the
non-virtual part of a class as the base of another class (A-18).

<p>
<font color=blue>[991230]</font>
Integrate proposed resolution of A-16, A-17 in base class layout.
Add outstanding questions list, and clean up questions in text.

<p>
<font color=blue>[991229]</font>
Clarify definition of nearly empty class, layout of virtual bases.

<p>
<font color=blue>[991203]</font>
Added description of vfunc calling convention from Jason.

<p>
<font color=blue>[991104]</font>
Noted pair of vtable entries for virtual destructors.

<p>
<font color=blue>[991019]</font>
Modified RTTI proposal for 14 October decisions.

<p>
<font color=blue>[991006]</font>
Added RTTI proposal.

<p>
<font color=blue>[990930]</font>
Updated to new vtable layout proposal.

<p>
<font color=blue>[990811]</font>
Described member pointer representations, virtual table layout.

<p>
<font color=blue>[990730]</font>
Selected first variant for empty base allocation; removed others.

<p> <hr> <p>
<a name=definitions>
<h3> Definitions </h3>

<p>
The descriptions below make use of the following definitions:

<dl>

<p>
<dt> <i>alignment</i> of a type T (or object X)</dt>
<dd>
A value A such that any object X of type T has an address satisfying
the constraint that &X modulo A == 0.

<p>
<dt> <i>direct base class order</i> </dt>
<dd>
When the direct base classes of a class are viewed as an ordered set,
the order assumed is the order declared, left-to-right.

<p>
<dt> <i>diamond-shaped inheritance</i> </dt>
<dd>
A class has diamond-shaped inheritance iff it has a virtual base class
that can be reached by distinct inheritance graph paths through
more than one direct base.

<p>
<dt> <i>dynamic class</i> </dt>
<dd>
A class requiring a virtual table pointer
(because it or its bases have one or more virtual member functions or
virtual base classes).

<p>
<dt> <i>empty class</i> </dt>
<dd>
A class with no non-static data members other than zero-width bitfields,
no virtual functions, no virtual base classes,
and no non-empty non-virtual base classes.

<p>
<dt> <i>inheritance graph order</i> </dt>
<dd>
When all base classes of a class, direct and indirect,
are viewed as an ordered set,
the order assumed that obtained by a depth-first, left-to-right
walk of the inheritance graph.

<p>
<a name=q3></a>
<dt> <i>nearly empty class</i> </dt>
<dd>
A class that contains no data except its virtual pointer (if any) or
virtual bases.  In particular, it:
<ul>
<li> has no non-static data members other than zero-width bitfields,
<li> has no base classes that are not either empty, nearly empty,
     or virtual, and
<li> has at most one non-virtual, nearly empty base class.
</ul>
Such classes may be primary base classes even if virtual,
sharing a virtual pointer with the derived class.

<p>
<dt> <i>primary base class</i> </dt>
<dd>
For a dynamic class,
the unique base class (if any) with which it shares the virtual pointer
at offset 0.

<p>
<dt> <i>secondary vtable</i> </dt>
<dd>
The instance of a vtable for a base class
that is embedded in the vtable of a class derived from it.

<p>
<dt> <i>virtual table</i> (or <i>vtable</i>) </dt>
<dd>
A dynamic class has an associated table
(often several instances, but not one per object)
which contains information about its dynamic attributes,
e.g. virtual function pointers, virtual base class offsets, etc.

</dl>


<p> <hr> <p>
<a name=general>
<h3> General </h3>

In what follows, we define the memory layout for C++ data objects.
Specifically, for each type, we specify the following information about
an object O of that type:
<ul>
<li> the <i>size</i> of an object, <i>sizeof</i>(O);
<li> the <i>alignment</i> of an object, <i>align</i>(O); and
<li> the <i>offset</i> within O, <i>offset</i>(C),
     of each data component C, i.e. base or member.
</ul>

<p> For purposes internal to the specification,
we also specify:

<ul>
<li> <i>dsize</i>(O):
the <i>data size</i> of an object,
which intuitively is sizeof(O) minus the size of tail padding.

<p>
<li> <i>nvsize</i>(O):
the <i>non-virtual size</i> of an object,
which intuitively is dsize(O) minus the size of virtual bases.
It is always equal to <i>dsize</i>(O) for types without virtual bases.

<p>
<li> <i>nvalign</i>(O):
the <i>non-virtual alignment</i> of an object,
which intuitively is the alignment determined by ignoring virtual bases.
It is always equal to <i>align</i>(O) for types without virtual bases.

</ul>

<p> <hr> <p>
<a name=pod>
<h3> POD Data Types </h3>

The size and alignment of C POD types is as specified by the base (C) ABI.
Type bool has size and alignment 1.
All of these types have data size and non-virtual size equal to their size.
(We ignore tail padding for PODs because the Standard does not allow us
to use it for anything else.)


<p> <hr> <p>
<a name=member-pointers></a>
<h3> Member Pointers </h3>

<p>
A pointer to data member is an offset from the base
address of the class object containing it,
represented as a <code>ptrdiff_t</code>.
It has the size and alignment attributes of a <code>ptrdiff_t</code>.

<p>
A pointer to member function is a pair <ptr, adj> as follows:

<dl>
<p>
<dt> <code>ptr</code>:
<dd> For a non-virtual function, this field is a simple function pointer.
     (Under current base IA-64 psABI conventions,
     that is a pointer to a GP/function address pair.)
     For a virtual function,
     it is 1 plus twice the Vtable offset of the function.
     The value zero is a NULL pointer.

<p>
<dt> <code>adj</code>:
<dd> The required adjustment to <i>this</i>,
     represented as a <code>ptrdiff_t</code>.
</dl>

<p>
It has the size, data size, and alignment
of a class containing those two members, in that order.
(For 64-bit IA-64, that will be 16, 16, and 8 bytes respectively.)



<p> <hr> <p>
<a name=class-types></a>
<h3> Non-POD Class Types </h3>

For non-POD class types C, assume that all component types
(i.e. base classes and non-static data member types)
have been laid out, defining size, data size, non-virtual size,
alignment, and non-virtual alignment.
(See the description of these terms in
<a href=#general><b>General</b></a> above.)
Layout (of type C) is done using the following procedure.

<ol type=I>
<p>
<li> <h5> Initialization </h5>
  <ol type=1>
  <p>
  <li> Initialize sizeof(C) to zero, align(C) to one, dsize(C) to zero.

  <p>
  <li> If C is a dynamic class type:
      <ol type=a>
      <p>
      <li> Identify all virtual base classes, direct or indirect,
	   that are primary base classes for some other direct or indirect
	   base class.
	   Call these <i>indirect primary base classes</i>.

      <p>
      <li> If C has a dynamic base class,
	   attempt to choose a primary base class B.
	   It is the first (in direct base class order)
	   non-virtual dynamic base class, if one exists.
	   Otherwise, it is a nearly empty virtual base class,
	   the first one in inheritance graph order which
	   is not an indirect primary base class if any exist,
	   or just the first one if they are all indirect primaries.

	   <p>
	   Allocate the chosen primary base at offset zero, and set
	   sizeof(C) to sizeof(B), align(C) to nvalign(B),
	   dsize(C) to nvsize(B).
	   This step allocates only B's non-virtual part,
	   i.e. excluding any direct or indirect bases.

      <p>
      <li> Otherwise, allocate the vtable pointer for C at offset zero,
	   and set sizeof(C), align(C), and dsize(C) to the appropriate
	   values for a pointer (all 8 bytes for IA-64 64-bit ABI).
      </ol>
  </ol>

<p>
<li> <h5> Non-Virtual-Base Allocation </h5>
<p>
For each data component D (i.e. base or non-static data member)
except virtual bases,
first the non-virtual base classes in declaration order
and then the non-static data members in declaration order,
allocate as follows:

  <ol type=1>

  <p>
  <li> If D is not an empty base class,
	start at offset dsize(C),
	incremented if necessary to alignment nvalign(type(D)).
	Place D at this offset unless doing so would result in two
	components (direct or indirect) of the same type having the
	same offset.
	If such a component type conflict occurs,
	increment the candidate offset by nvalign(type(D)),
	and try again,
	repeating until success occurs
	(which will occur no later than sizeof(C) rounded up to the
	required alignment).

	<p>
	If D is a base class, this step allocates only its non-virtual
	part, i.e. excluding any direct or indirect virtual bases.

	<p>
	Update sizeof(C) to max (sizeof(C), offset(D)+nvsize(D)).
	Update align(C) to max (align(C), nvalign(D)).
	If D is a base class (not empty in this case),
	update dsize(C) to offset(D)+nvsize(D).
	If D is a data member,
	update dsize(C) to max (offset(D)+dsize(D), offset(D)+1).

  <p>
  <li> If D is an empty base class,
	its allocation is similar to the first case above,
	except that additional candidate offsets are considered before
	starting at dsize(C).
	First, attempt to place D at offset zero.
	If unsuccessful (due to a component type conflict),
	proceed with attempts at dsize(C) as for non-empty bases.
	As for that case, if there is a type conflict at dsize(C)
	(with alignment updated as necessary),
	increment the candidate offset by nvalign(type(D)),
	and try again,
	repeating until success occurs.

	<p>
	Once offset(D) has been chosen,
	update sizeof(C) to max (sizeof(C), offset(D)+sizeof(D)).
	Note that nvalign(D) is 1, so no update of align(C) is needed.
	Similarly, since D is an empty base class,
	no update of dsize(C) is needed.

  </ol>

  <p>
  After all such components have been allocated,
  set nvsize(C) = dsize(C) and nvalign(C) = align(C).
  These values will not change during virtual base allocation.

<p><a name=a17></a>
<li> <h5> Virtual Base Allocation </h5>
<p>

<p>
Finally allocate any direct or indirect virtual base classes
(except the primary base class or any indirect primary base classes)
as we did non-virtual base classes in step II-1,
in inheritance graph order.
Update sizeof(C) to max (sizeof(C), offset(D)+nvsize(D)).
If non-empty, also update align(C) and dsize(C) as in II-1.

<p>
The primary base class has already been allocated in I-3a.
Any indirect primary base class E of the current class C,
has been chosen as the primary base class of some other base class
(direct or indirect, virtual or non-virtual) of C,
will be allocated as part of that other base class,
and is not allocated here.
If E is a primary base class of more than one other base,
the instance used as its allocation in C shall be the first such
in the inheritance graph order.

<p>
<li> <h5> Finalization </h5>
<p>
Round sizeof(C) up to a non-zero multiple of align(C).

</ol>


<p> <hr> <p>
<a name=vtable></a>
<h3> Virtual Table Layout </h3>

<p>
<h4> General </h4>

<p>
A <i>virtual table</i> (<i>vtable</i>) is a table of information used
to dispatch virtual functions,
to access virtual base class subobjects,
and to access information for runtime type identification (RTTI).
Each class that has virtual member functions or virtual bases
has an associated set of vtables.
There may be multiple vtables for a particular class,
if it is used as a base class for other classes.
However, the vtable pointers within all the objects (instances)
of a particular most-derived class point to the same set of vtables.

<p>
A vtable consists of a sequence of offsets, data pointers,
and function pointers, as well as structures composed of such items.
We will describe below the sequence of such items.
Their offsets within the vtable are determined by that allocation
sequence and the natural ABI size and alignment,
just as a data struct would be.  In particular:
<ul>
<li> Offsets are of type <code>ptrdiff_t</code> unless otherwise stated.
<li> Data pointers have normal pointer size and alignment.
<li> Function pointers remain to be defined.
     One possibility is that they will be
     &lt;function address, GP address> pairs, with pointer alignment.
</ul>

<p>
In general, what we consider the address of a vtable
(i.e. the address contained in objects pointing to a vtable)
may not be the beginning of the vtable.
We call it the <i>address point</i> of the vtable.
The vtable may therefore contain components at either positive or
negative offsets from its address point.

<p>
<h4> Components </h4>

<p>
Each vtable consists of the following components:

<ul>
<p>
<li>
<a name=q1></a>
<i>Base offsets</i> are used to access the virtual bases of an object.
Such an entry is added to the derived class object address
(i.e. the address of its vtable pointer)
to get the address of a virtual base class.
These entries are required for:
  <ul>
  <li>direct virtual base classes, or
  <li>indirect virtual base classes inherited from a direct virtual base
  class.
  </ul>
The values can be positive or negative.

<p>
<li>
<i>Vcall offsets</i> are used to perform pointer adjustment
for overridden virtual functions.
These entries are allocated when the class is used as a virtual base.
to find the necessary adjustment from the base to the derived class,
if any.
When a virtual function is invoked via a virtual base,
but has been overridden in a derived class,
the overriding function adds this value to its this pointer to get
the address of the derived object where the function was overridden.
These values may be positive or negative.

<p>
<li>
The <i>offset to top</i> holds the displacement to the top of the object
from the location within the object of the vtable pointer that addresses
this vtable,
as a <code>ptrdiff_t</code>.
A negative value indicates the vtable pointer is part of an embedded
base class subobject; otherwise it is zero.
The offset provides a way to find the top of the object from any base
subobject with a vtable pointer.
This is necessary for dynamic_cast<void*> in particular.

<p>
<li>
The <i>typeinfo pointer</i> points to the typeinfo object used for RTTI.
All entries in each of the vtables for a given class must point to the
same typeinfo object.
A correct implementation of typeinfo equality is to check pointer equality.
The typeinfo pointer is a valid pointer for polymorphic classes,
i.e. those with virtual functions,
and is zero for non-polymorphic classes.

<p>
<li>
<i>Virtual function pointers</i> are used for virtual function dispatch.
Each pointer holds either the address of a virtual function of the class
(or the address of a secondary entry point that performs certain
adjustments before transferring control to a virtual function.)
In the case of shared library builds,
a virtual function pointer entry contains a pair of components
(each 64 bits in the 64-bit IA-64 ABI):
the value of the target GP value and the actual function address.
That is, rather than being a normal function pointer,
which points to such a two-component descriptor,
a virtual function pointer entry is the descriptor.

<p>
<i>
Note that the entries for virtual destructors are actually pairs of entries.
The first performs the destruction without calling delete() on the object,
while the second calls delete() after destroying the object.
Both destroy any virtual bases;
a separate, non-virtual entry performs destruction of the object but
not its virtual base subobjects, and does not call delete().
</i>

<p>
<li>
<i>Secondary vtables</i> are copies of the vtables for base classes of the
current class
(copies in the sense that they have the same layout,
though virtual function pointers may point to overriding functions).

</ul>

<p>
The virtual pointer in the object points to the first virtual
function pointer.

<p>
<h4> Virtual Table Order </h4>

<p>
A virtual table's components are laid out in the following order,
analogous to the corresponding object layout.

<ol>
<p>
<li>
If vcall offsets are required,
they come first,
with ordering as defined in categories 3 and 4 below.

<p>
<li>
If virtual base offsets are required,
they come next, with ordering as defined in categories 3 and 4 below.

<p>
<li>
<a name=q2></a>
The offset to top field is next.
It is present if the class has virtual functions or bases.

<p>
<li>
The typeinfo pointer field is next.
It is present if the class has virtual functions.

<p>
<li>
The vtable address point points here,
i.e. this is the address of the vtable contained in an object's vptr.

<p>
<li>
Virtual function pointers come next,
in order of declaration of the corresponding member function in the class.
They appear both for newly introduced functions and overridden functions.

<p>
<li>
The secondary vtables are last.
They are laid out in the same order used for the bases themselves in
the object.

</ol>

<p>
<h4> Virtual Table Construction </h4>

<p>
In this section, we describe how to construct the vtable for an class,
given vtables for all of its base classes.
To do so, we divide classes into several categories,
based on their base class structure.

<p>
<h5> Category 0: Trivial </h5>

Structure:
<ul>
<li> No virtual base classes.
<li> No virtual functions.
</ul>

<p>
Such a class has no associated vtable,
and its objects contain no vptr.

<p>
<h5> Category 1: Leaf </h5>

Structure:
<ul>
<li> No inherited virtual functions.
<li> No virtual base classes.
<li> Declares virtual functions.
</ul>

<p>
The vtable contains offset-to-top and RTTI fields
followed by virtual function pointers.
There is one function pointer entry for each
virtual function declared in the class.

<p>
<h5> Category 2: Non-Virtual Bases </h5>

Structure:
<ul>
<li> Only non-virtual base classes.
<li> Inherits virtual functions.
</ul>

<p>
The class has a vtable for each base class that has a vtable.
The class's vtables are constructed from copies of the base class vtables.
The entries are the same, except:

<ul>
<p>
<li> The offset-to-top and RTTI fields
     contain information for the class,
     rather than for the base class. 

<p>
<li> The function pointer entries for virtual functions inherited from
     the base class and overridden by this class are replaced with the
     addresses of the overriding functions
     (or the corresponding adjustor secondary entry points).
</ul>

<p>
For a base class <code>Base</code>,
and a derived class <code>Derived</code> for which we are constructing
this set of vtables,
we shall refer to the vtable for <code>Base</code> as
<code>Base-in-Derived</code>.
The vptr of each base subobject of an object of the derived class will
point to the corresponding base vtable in this set.

<p>
The vtable copied from the primary base class is also called the
primary vtable;
it is addressed by the vtable pointer at the top of the object.
The other vtables of the class are called secondary vtables;
they are addressed by vtable pointers inside the object.

<p>
Following the function pointer entries that correspond to those of the
primary base class,
the primary vtable holds the following additional entries at its tail:
<ul>
<li> Entries for virtual functions introduced by this class.
<li> Entries for overridden virtual functions not already in the vtable.
     (These are also called replicated entries because they are already
     in the secondary vtables of the class.)
</ul>

The primary vtable, therefore,
has the base class functions appearing before the derived class functions.
The primary vtable can be viewed as two vtables accessed
from a shared vtable pointer. 

<p>
<i>Note</i>:
Another benefit of replicating virtual function entries is that it
reduces the number of this pointer adjustments during virtual calls.
Without replication,
there would be more cases where the this pointer would have to be
adjusted to access a secondary vtable prior to the call.
These additional cases would be exactly those where the function
is overridden in the derived class,
implying an additional thunk adjustment back to the original pointer.
Thus replication saves two adjustments for each virtual call to an
overridden function introduced by a non-primary base class. 

<p>
<h5> Category 3: Virtual Bases Only </h5>

<p>
Structure:
<ul>
<li> Only virtual base classes.
<li> Base classes are not empty or nearly empty.
</ul>

<p>
The class has a vtable for each virtual base class that has a vtable.
These are all secondary vtables and are constructed from copies of the
base class vtables according to the same rules as in Category 2,
except that the vtable for a virtual base A also includes a vcall
offset entry for each virtual function represented in A's primary
vtable and the secondary vtables from A's non-virtual bases.
The vcall offset entries are allocated from the inside out,
in the same order as the functions appear in A's vtables.

<p>
The class also has a vtable that is not copied from the virtual base
class vtables.
This vtable is the primary vtable of the class and is addressed by the
vtable pointer at the top of the object, which is not shared.
It holds the following function pointer entries: 

<ul>
<p>
<li> Entries for virtual functions introduced by this class.

<p>
<li> Entries for overridden virtual functions.
     (These are also called replicated entries,
     because they are already in the secondary vtables of the class.)
</ul>

<p>
The primary vtable also has virtual base offset entries
to allow finding the virtual base subobjects.
There is one virtual base offset entry for each virtual base class,
direct or indirect.
The entries are in the reverse of the inheritance graph order.
That is, the entry for the leftmost virtual
base is closest to the address point of the vtable.
If there is a primary base class,
its virtual base and vcall offsets come first
(i.e. closest to the vtable address point)
so that they are in their previously defined locations for the base,
followed by the additional entries required by the full derived class.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>The above rule for laying out the virtual offsets
is a specialization of the Category 4 rule below,
made possible by the absence of non-virtual bases.
It does not provide a different layout than the full Category 4 rule.
</i>


<p>
<h5> Category 4: Complex </h5>

<p>
Structure:
<ul>
<li> None of the above,
     i.e. directly or indirectly inherits both virtual and non-virtual
     base classes, or at least one nearly empty virtual base class.
</ul>

<p>
The rules for constructing vtables of the class are a combination of
the rules from Categories 2 and 3,
and for the most part can be determined inductively.
However the rules for placing virtual base offset entries in the
vtables requires elaboration. 

<p>
The primary vtable also has virtual base offset entries
to allow finding the virtual base subobjects.
There is one virtual base offset entry for each direct virtual base class,
and one for each indirect virtual base class
inherited via a direct virtual base class.
(Indirect virtual base classes inherited via direct non-virtual base classes
may be accessed via the the offset stored in the base's vtable.)
If an indirect virtual base class is inherited via both virtual and
non-virtual direct base classes,
no virtual base offset entry is included for it.
The entries are in the reverse of the inheritance graph order.
That is, the entry for the leftmost virtual
base is closest to the address point of the vtable.
If there is a primary base class,
its virtual base and vcall offsets come first
(i.e. closest to the vtable address point)
so that they are in their previously defined locations for the base,
followed by the additional entries required by the full derived class.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>For an S-as-T vtable,
the vbase offset entries from the primary vtable for T
are replaced with appropriate offsets given the completed hierarchy.
</i>

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>Consider the following inheritance hierarchy:
<code><pre>
  struct S {};
  struct T : virtual public S {};
  struct U : virtual public T {};
  struct V : public T, virtual public U {};
</pre></code>
<p>
T's vtable contains a virtual base offset for S.
U's vtable contains virtual base offsets for S and T.
V's vtable contains a virtual base offset for U,
but not for T because it is non-virtual,
nor for S because it is already present as a virtual base of T.
</i>

<p>
<a name=vcall>
<h4> Virtual Function Calling Convention </h4>
</a>

<p>
This section sketches the calling convention for virtual functions,
based on the above virtual table layout.

<p>
Note: for virtual functions not inherited from a virtual base, 
regular thunks are a suitable implementation,
since the implementation can emit them immediately before the
function to avoid the indirect branch penalty.
We use offsets in the vtable for functions that come from a virtual base,
because it is impossible to predict what the offset between the
current class and its virtual base will
be in classes derived from the current class.

<p>
The calling convention is as follows:

<ul>
<li>vtable layout:
<p>
For each virtual function defined in a class,
we add an entry to the primary vtable if one is not already there.
In particular, a definition which overrides a function inherited from
a secondary base gets a new slot in the primary vtable.
We do this to avoid useless adjustments when calling a virtual
function through a pointer to the most derived class.

<p>
When a class is used as a virtual base,
we add a vcall offset slot to the beginning of its vtable for each of
the virtual functions it provides,
whether in its primary or secondary vtables.
Derived classes which override these functions will use the slots to
determine the adjustment necessary.

<p>
<li>Caller:
<p>
The caller adjusts the 'this' argument to point to the class
that contains the unique final overrider (as defined in [class.virtual])
for the function being called.
The result provides both the 'this' argument and the vtable pointer
for finding the function we want.

<p>
<li>Callee:
<p>
Each virtual function 'f' defined in a class 'A'
has one entry point which takes an A*,
and performs no adjustment.
The primary vtable for A points to this entry point.

<p>
For each secondary vtable
from a non-virtual base class 'B' which defines f,
an additional entry point is generated
which performs the constant adjustment from
<font color=red>A* to B*</font>.

<p>
For each secondary vtable from a virtual base class 'C' which defines f,
an additional entry point is generated which performs the adjustment from
<font color=red>
A* to C* by adding the vcall offset for f stored in the secondary
vtable for A</font>.

<p>
For each secondary vtable from a base 'D' which is a non-virtual base
of a virtual base 'E',
an additional entry point is generated
<font color=red>
in the secondary vtable for 'E'
</font>
which first performs the constant adjustment from D* to E*,
then the adjustment from E* to A* by adding the vcall offset for f stored
in the secondary vtable for E.

<p>
<li>Implementation
<p>
Note that the ABI only specifies the multiple entry points;
how those entry points are provided is unspecified.
An existing compiler which uses thunks could be converted to use this
ABI by only adding support for the vcall offsets.
A more efficient implementation would be to emit all of the thunks
immediately before the non-adjusting entry point to the function.
Another might use predication rather than branches to reach the main function.
Another might emit a new copy of the function for each entry point;
this is a quality of implementation issue.
</ul>


<p> <hr> <p>
<a name=vtable-ctor>
<h3> Vtables During Object Construction (open issue C-4)</h3>

<p>
In some situations,
a special vtable called a construction vtable is used during
the execution of base class constructors and destructors.
These vtables are for specific cases of virtual inheritance.

<p>
During the construction of a class object, the object assumes the
type of each of its base classes, as each base class subobject is
constructed. RTTI queries in the base class constructor will return  
the type of the base class, and virtual calls will resolve to member  
functions of the base class rather than the complete class. Normally,  
this behavior is accomplished by setting, in the base class
constructor, the object's vtable pointers to the addresses of the
vtables for the base class.

<p>
However, if the base class has direct or indirect virtual bases, the  
vtable pointers have to be set to the addresses of construction
vtables. This is because the normal base class vtables may not hold  
the correct virtual base index values to access the virtual bases of  
the object under construction, and adjustment addressed by these
vtables may hold
the wrong this parameter adjustment if the adjustment is to cast
from a virtual base to another part of the object. The problem is
that a complete object of a base class and a complete object of a
derived class do not have virtual bases at the same offsets.

<p>
A construction vtable holds the virtual function addresses,
offset-to-top,
and RTTI information associated with the base class,
and virtual base offsets and addresses of adjustor entry points with their
parameter adjustments associated with objects of the complete class.

<p>
To ensure that the vtable pointers are set to the appropriate
vtables during base class construction, a table of vtable pointers,  
called the VTT, which holds the addresses of construction and
non-construction vtables is generated for the complete class. The
constructor for the complete class passes to each base class
constructor a pointer to the appropriate place in the VTT where the  
base class constructor can find its set of vtables. Construction
vtables are used in a similar way during the execution of base class  
destructors.

<p>
<font color=red>
<h4> VTT Order</h4>

<p>
An array of vtable addresses, called the VTT, is declared for each class
type that needs a construction vtable.&nbsp; A class needs a construction
vtable if it has:
<ol>
<li>
indirect or direct virtual base classes, or</li>

<li>
a virtual function that is overridden along a virtual path (to provide
correct vcall offset in most derived object).</li>
</ol>

<p>
The elements of the VTT&nbsp;array are in this order:
<ol>
<li>
Address of the vtable for the complete object, which includes subobject
vtables appended to it in the order which the base classes are allocated
in the complete object,</li>

<p>
<li>
Addresses of construction vtables for each non-virtual subobject that needs
a construction vtable.</li>

<br>This step is recursive, the addresses of construction vtables for each
subobject include the addresses in 1 and 2 for each subobject class that
has non-virtual subobjects that need construction vtables.
<li>
Addresses of construction vtables for each virtual subobject in initialization
(DFS) order.&nbsp; These addresses are as in #2 above, and can be recursive
for non-virtual bases within the virtual base subobjects.&nbsp; The virtual
VTT&nbsp;addresses are on the end because they are only passed to the virtual
base class constructors for the complete object.</li>
</ol>
All vtable addresses in the VTT&nbsp;point to the beginning address of
the vtable, not the address that is assigned to the vptr.

<p>
<h4> VTABLE Layout</h4>
The construction vtables for a complete object are appended to the vtable
in the order of their appearance in the VTT array.&nbsp;&nbsp; So the vtable
for a complete object of class C has these components:
<ol>
<li>
vtable that the primary vptr (the offset 0 one) points to</li>

<li>
base class subobject vtables in order of allocation, including virtual
base class subobject vtables</li>

<li>
nonvirtual and virtual construction vtables in order of appearance in the
VTT</li>

<li>
VTT&nbsp;array for C</li>
</ol>
We could separate the VTT&nbsp;array out of the vtable, and provide a new
VTT data item.&nbsp; We could also make the VTT static so it has no linkage
and is created in the modules that define the constructors and destructor
of a class.&nbsp;&nbsp; I don't think they would take that much space.
<br>&nbsp;

<p>
<h4> Construction VTABLE entries</h4>
The construction vtables for base class subobject B, has the same entries
in the same order as the vtable for the complete object, B.&nbsp; The entries
of the construction vtable have the following values:
<ol>
<li>
Virtual base class offsets relative to the complete object from B</li>

<li>
VCALL&nbsp;offsets relative to the complete object</li>

<li>
offset to top of B in B, should be 0.</li>

<li>
pointer to RTTI&nbsp;for B</li>

<li>
overridden virtual functions for B.</li>
</ol>
Within the construction vtable for a subobject B, the base class subobject
construction vtable for base class V of B in derived class D, has the following
entries:
<ol>
<li>
Virtual base class offsets relative to complete object from V to D</li>

<li>
VCALL&nbsp;offsets relative to a V&nbsp;in B in a complete object D</li>

<li>
offset to the B base class subobject from V in D (may not be the same as
offset of B in D)</li>

<li>
pointer to RTTI&nbsp;for B</li>

<li>
overridden virtual functions for V</li>
</ol>

<p>
<h4> Subobject Construction and Destruction</h4>
The complete object constructors and destructors call the subobject constructors
and destructors by passing the address of the subobject entry in the VTT
as the second parameter.&nbsp; The subobject ctor/dtors use the addresses
passed to initialize the primary vptr and vptrs that point to the classes
which either have virtual bases or override virtual functions with a virtual
step (have vcall offsets needing adjustment).
<p>Note: The EDG&nbsp;compiler passes the ctorvtbls by assigning them to
the subobject vptr and the subobject constructors get the array address
from the vptr.&nbsp; This didn't work when an exception is raised during
construction and the destructor didn't have the ctorvtbls address anymore.&nbsp;
There may be a way to make this work with the landing pad model, but I
haven't worked that out.
<p>Therefore the code for subobject constructor D which needs a construction
vtable with one base class subobject B that needs a construction vtable
would look like the following:

<code><pre>
     static vtable *__VTT__1D[3] = { D primary vtable, ctorvtbl for B in D }; 
     D(D *this, vtable **ctorvtbls) 
     {
         // Call subobject constructors with ctorvtbls index
	 // if that base needs it. 
         B((B*)this, &ctorvtbls[1]); 
         // etc... 
         // Initialize vptr with primary ctorvtbls address (first element) 
         this->vptr = ctorvtbls[0][n];  // where n is the index of
					// first virtual function in vtbl. 
         // Initialize vptrs of subobjects with ctorvtbls addresses
	 // for the bases 
         ((B*)this)->vptr = ctorvtbls[0][m];
		 // where m is the index of the first virtual function 
		 // for base class subobject B 
         // Code for constructor. 
      }
</pre></code>

<p>
<h4> Test Program</h4>
Following is a test program for this, that breaks on many compilers.

<code><pre>
/* 
This test program should output: 

V1 called 
V2 called 
C called 
C::foo called 7 
PASSED this == cp 
D called 
~C called 
C::foo called 7 
PASSED this == cp 
~V2 called 
~V1 called 
Int caught 
*/ 

extern "C" int printf(const char *,...); 
struct V1 {
        int v; 
        virtual int foo(); 
        V1(); 
        ~V1(); 
}; 
struct V2 : virtual V1 {
        int v2; 
        virtual int foo(); 
        V2(); 
        ~V2(); 
}; 
struct C : virtual V1, virtual V2 {
        int c; 
        virtual int foo(); 
        C(); 
        ~C(); 
}; 

struct B {
   int b; }; 
struct D : B, C {
        int d; 
        virtual int bar(); 
        D(); 
        ~D(); 
}; 
extern "C" int printf(const char *,...); 
main() 
{
  try {
        D *d = new D; 
        delete d; 
  } catch (int) {
        printf("Int caught\n"); 
  } 
} 

int V1::foo() {
   printf("V1::foo called\n"); return 1; } 
V1::V1() : v(5) {
   printf("V1 called\n"); } 
V1::~V1() {
   printf("~V1 called\n"); } 

int V2::foo() {
   printf("V2::foo called\n"); return 1; } 
V2::V2() : v2(6) {
   printf("V2 called\n"); } 
V2::~V2() {
   printf("~V2 called\n"); } 

int C::foo() {
   printf("C::foo called %d\n", c); return 1; } 
C::C() : c(7) {
        printf("C called\n"); 
        V1 *vv = this; vv->foo(); 
        C *cp = dynamic_cast<C *>(vv); 
        if (this == cp) {
            printf("PASSED this == cp\n"); 
        } else {
            printf("FAILED this != cp\n"); 
        } 
} 
C::~C() {
        printf("~C called\n"); 
        V1 *vv = this; vv->foo(); 
        C *cp = dynamic_cast<C *>(vv); 
        if (this == cp) {
            printf("PASSED this == cp\n"); 
        } else {
            printf("FAILED this != cp\n"); 
        } 
} 

int D::bar() {
   printf("D::bar called\n"); return 1; } 
D::D() : d(8) {
   printf("D called\n"); throw 5; } 
D::~D() {
   printf("~D called\n"); } 
</pre></code>

</font>



<p> <hr> <p>
<a name=array-new>
<h3> Operator <code>new</code> for Arrays </h3>

<p>
When operator <code>new</code> is used to create a new dynamic-length array,
a cookie is usually stored to remember the allocated length
(number of array elements)
so that it can be deallocated correctly.

<font color=red>
<p>
Specifically:
<ul>
<p>
<li> No cookie is required if the array element type T has a trivial
    destructor (C++ standard, 12.4/3).
<p>
<li> No cookie is required if the <code>new</code> operator being used
    is <code>::operator new[](size_t, void*)</code>.

<p>
<li> Otherwise, this ABI requires a cookie, setup as follows:
</font>
  <ul>
  <li> The cookie will have size <code>sizeof(size_t)</code>.
  <li> Let <code>align</code> be the maximum alignment of
  <code>size_t</code> and an element of the array to be allocated.
  <li> The space allocated for the array will be the space required
  by the array itself plus <code>align</code> bytes.
  <li> The alignment of the space allocated for the array will be
  <code>align</code> bytes.
  <li> The array data will begin at an offset of <code>align</code> bytes
  from the space allocated for the array.
  <li> The cookie will be stored in the <code>sizeof(size_t)</code> bytes
  immediately preceding the array data.
  </ul>

  <i>
  <p>
  These rules have the following consequences:
  <ul>
  <li> The array elements and the cookie are all aligned naturally.
  <li> Padding will be required if <code>sizeof(size_t)</code>
  is smaller than the array element alignment,
  and if present will precede the cookie.
  </ul>
  </i>

</ul>

<p>
<font color=red>
Given the above, the following is pseudocode for processing
<code>new(ARGS) T[n]</code>:
<code><pre>
  if T has a trivial destructor (C++ standard, 12.4/3)
    padding = 0
  else if we're using ::operator new[](size_t, void*)
    padding = 0
  else
    padding = max(sizeof(size_t), alignof(T))

  p = operator new[](n * sizeof(T) + padding, ARGS)
  p1 = (T*) ( (char *)p + padding )

  if padding > 0
    *( (unsigned long *)p1 - 1) = n

  for i = [0, n)
    create a T, using the default constructor, at p1[i]

  return p1
</pre></code>
</font>



<p> <hr> <p>
<a name=rtti>
<h3> Run-Time Type Information (RTTI) </h3>

<p>
The C++ programming language definition implies that information about
types be available at run time for three distinct purposes:
<ol type=a>
<li> to support the typeid operator,
<li> to match an exception handler with a thrown object, and
<li> to implement the dynamic_cast operator.
</ol>
(c) only requires type information about dynamic class types,
but (a) and (b) may apply to other types as well;
for example, when a pointer to an int is thrown,
it can be caught by a handler that catches "int const*".

<p>
It is intended that two type_info pointers point to equivalent type
descriptions if and only if the pointers are equal.
An implementation must satisfy this constraint,
e.g. by using symbol preemption, COMDAT sections, or other mechanisms.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
Note that the full structure described by an RTTI descriptor may
include incomplete types not required by the Standard to be completed,
although not in contexts where it would cause ambiguity.
Therefore, any cross-references within the RTTI to types not known to
be complete must be weak symbol references.
</i>

<p>
<h5>Place of emission</h5>

<p>
It is desirable to minimize the number of places where a
particular bit of RTTI is emitted.
For dynamic class types,
a similar problem occurs for virtual function tables,
and hence the RTTI descriptor should be emitted
with the primary vtable for that type.
For other types, they must be emitted at the location
where their use is implied:
the object file containing the typeid, throw or catch.

<p>
Basic type information (e.g. for "int", "bool", etc.)
will be kept in the run-time support library.
Specifically, the run-time support library
should contain type_info objects for the types
X, X* and X const*,
for every X in: void, bool, wchar_t, char, unsigned char, signed char,
short, unsigned short, int, unsigned int, long, unsigned long, long long,
unsigned long long, float, double, long double.
(Note that various other type_info objects for class types may reside
in the run-time support library by virtue of the preceding rules;
e.g., that of std::bad_alloc.)


<p>
<h5>The typeid operator</h5>

<p>
The typeid operator produces a reference to a std::type_info structure
with the following public interface:

<pre><code>
  struct std::type_info {
     virtual ~type_info();
     bool operator==(type_info const&) const;
     bool operator!=(type_info const&) const;
     bool before(type_info const&) const;
     char const* name() const;
  };
</pre></code>

<p>
Assuming that after linking and loading only one type_info structure is
active for any particular type symbol,
the equality and inequality operators can be
written as address comparisons:
to type_info structures describe the same type
if and only if they are the same structure (at the same address).
In a flat address space
(such as that of the IA-64 architecture),
the before() member is also easily written in terms of an address comparison.
The only additional piece of information that is required is the
NTBS that encodes the name.
The type_info structure itself can hold a pointer into a read-only segment
that contains the text bytes.


<p>
<h5>Matching throw expressions with handlers</h5>

<p>
When an object is thrown a copy is made of it and the type of that copy
is TT.
A handler that catches type HT will match that throw if:
<ul>
  <li> HT is equal to TT except that HT may be a reference and that HT
	may have top-level cv qualifiers
	(i.e., HT can be "TT cv", "TT&" or "TT cv&"); or
  <li> HT is a reference to a public and unambiguous base type of TT; or
  <li> HT has a pointer type to which TT can be converted by a standard
	pointer conversion (though only public,
	unambiguous derived-to-base conversions are permitted)
	and/or a qualification conversion.
</ul>

<p>
This implies that the type information must keep a description of the public,
unambiguous inheritance relationship of a type, as well as the const
and volatile qualifications applied to types.


<p>
<h5>The dynamic_cast operator</h5>

<p>
Although dynamic_cast can work on pointers and references,
from the point of view of representation we need only to worry
about polymorphic class types.
Also, some kinds of dynamic_cast operations are handled at compile time
and do not need any RTTI.
There are then three kinds of truly dynamic cast operations:
<ul>
<li> dynamic_cast&lt;void cv*>, which returns a pointer to the complete lvalue,
<li> dynamic_cast operation from a base class to a derived class, and
<li> dynamic_cast across the hierarchy which can be seen as a cast to
	the complete lvalue and back to a sibling base.
</ul>

<p>
The most common kind of dynamic_cast is base-to-derived in a singly
inherited hierarchy.

<p>
<a name=rtti-layout></a>
<h5>RTTI layout</h5>

<ol type=1>

<p>
<li>
The RTTI layout for a given type depends on whether a 32-bit or
64-bit mode is in effect.
The class definitions below are to be interpreted as following the
class layout rules for the host ABI.

<p>
<li>
Every vtable shall contain one entry describing the offset from a
vptr for that vtable to the origin of the object containing that vptr
(or equivalently: to the vptr for the primary vtable).
This entry is directly useful to implement dynamic_cast<void cv*>,
but is also needed for the other truly dynamic casts.
This entry is located two words ahead of the location
pointed to by the vptr (i.e., entry "-2").
This entry is present in all vtables,
even for classes having virtual bases but no virtual functions.

<p>
<li>
Every vtable shall contain one entry that is a pointer to an object
derived from std::type_info.
This entry is located at the word preceding the location
pointed to by the vptr (i.e., entry "-1").
The entry is allocated in all vtables;
for classes having virtual bases but no virtual functions,
the entry is zero.

<p>
std::type_info contains just two pointers:
<ul>
<li> its vptr
<li> a pointer to a NTBS representing the name of the type
</ul>

<p>
The possible derived types are:
<ul>
  <li> abi::__fundamental_type_info
  <li> abi::__pointer_type_info
  <li> abi::__array_type_info
  <li> abi::__function_type_info
  <li> abi::__enum_type_info
  <li> abi::__class_type_info
  <li> abi::__si_class_type_info
  <li> abi::__vmi_class_type_info
  <li> abi::__pointer_to_member_type_info
</ul>

<p>
<li>
abi::__fundamental_type_info adds no fields to std::type_info;

<p>
<li>
abi::__pointer_type_info adds two fields (in this order):
<ul>
  <p>
  <li> a word describing the cv-qualification of what is pointed to
    (e.g., "int volatile*" should have the "volatile" bit set in that word)
  <p>
  <li> a pointer to the std::type_info derivation for the unqualified type
    being pointed to
</ul>

<p>
Note that the first bits should not be folded into the pointer because
we may eventually need more qualifier bits (e.g. for "restrict").
The bit 0x1 encodes the "const" qualifier;
the bit 0x2 encodes "volatile".

<p>
<li>
abi::__array_type_info and abi::__function_type_info do not add fields
to std::type_info
(these types are only produced by the typeid operator;
they decay in other contexts).
abi::__enum_type_info does not add fields either.

<p>
<li>
Three different types are used to represent type information:

<ol type=a>
<p>
<li>
abi::__class_type_info is used for class types having no bases,
and is also a base type for the other two class type representations.

<p>
<li>
For classes containing only a single, public, non-virtual base
at offset zero (i.e. the derived class is dynamic iff the base is),
class abi::__si_class_type_info is used.
It adds to abi::__class_type_info
a single member pointing to the type_info structure for the base type,
declared "<code>__class_type_info const *type</code>".

<p>
<li>
For classes with bases that do not satisfy the
__si_class_type_info constraints,
abi::__vmi_class_type_info is used.
It is derived from abi::__class_type_info, and adds fields:
  <ul>
  <p>
<font color=red>
  <li> vmi_flags: a word with flags describing details
      about the class (most for use of the derived classes):
	<ul>
	<li> 0x01: class has non-diamond repeated inheritance
	<li> 0x02: class is diamond shaped
	<li> 0x04: class has publicly inherited base(s)
	<li> 0x08: class has non-publicly inherited base(s)
	</ul>
      All of these flags refer to both direct and indirect bases.
</font>
      The type of the _VMI_flags field is defined by each psABI,
      but must be at least 16 bits.
      For the 64-bit IA-64 ABI, it will be unsigned int (32 bits).

  <p>
  <li> vmi_base_count: a word with the number of direct base class
      descriptions that follow.
      The type of the _VMI_base_count field is defined by each psABI.
      For the 64-bit IA-64 ABI, it will be unsigned int (32 bits).

  <p>
  <li> vmi_bases[]: base class descriptions for every direct base;
       each description is of the type:
<pre><code>
      struct abi::__base_class_info {
         __class_type_info const *type;
	 long vmi_offset_flags;
      };
</pre></code>

      <p>
      The <code>type</code> member points to the RTTI for the base type.

      <p>
      The upper 56 bits of vmi_offset_flags are a signed offset.
      For a non-virtual base,
      this is the offset in the object of the base subobject.
      For a virtual base,
      this is the offset in the vtable of the
      virtual base offset for the virtual base referenced
      (in general, negative if introduced in this primary vtable,
      or positive if reused from a non-virtual base's vtable).

      <p>
      The lower byte of vmi_offset_flags contains flags,
      as given by the following masks:
	<ul>
	<li> 0x1: Base class is virtual
	<li> 0x2: Base class is public
	</ul>

  </ul>

<p>
Note that the resulting structure is variable-length,
with the actual size depending on the number of trailing base class
descriptions.

</ol>

<p>
<li>
The abi::__pointer_to_member_type_info type adds two fields to std::type_info:
<ul>
<li> a pointer to a abi::__class_type_info (e.g., the "A" in "int A::*")
<li> a pointer to a std::type_info corresponding to the member type
    (e.g., the "int" in "int A::*")
<li> a word describing the cv-qualification of what is pointed to
    (see abi::__pointer_type_info)
</ul>

</ol>

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
<font color=red>
Note that this ABI requires elsewhere that a vtable be emitted for a
dynamic type in the object where the first non-inline virtual function
member is defined, if any, or everywhere referenced if none.
Therefore, an implementation that has virtual function members in the
classes defined above should include at least one non-inline virtual
function member and define it in the library,
to avoid having user code inadvertently preempt the vtable.
</font>
</i>


<h5>std::type_info::name()</h5>
<p>
The null-terminated byte string returned by this routine is
the mangled name of the type.


<p>
<h5>The dynamic_cast algorithm</h5>

<p>
Dynamic casts to "void cv*" are inserted inline at compile time.
So are dynamic casts of null pointers and dynamic casts that are really
static.

<p>
This leaves the following test to be implemented in the run-time
library for truly dynamic casts of the form "dynamic_cast<T>(v)":
(see [expr.dynamic_cast] 5.2.7/8)

<ul>
<p>
<li>
If, in the most derived object pointed (referred) to by v, v points
(refers) to a public base class sub-object of a T object
[note: this can be checked at compile time],
and if only one object of type T is derived
from the sub-object pointed (referred) to by v,
the result is a pointer (an lvalue referring) to that T object.

<p>
<li>
Otherwise, if v points (refers) to a public base class sub-object
of the most derived object,
and the type of the most derived object has an
unambiguous public base class of type T,
the result is a pointer
(an lvalue referring)
to the T sub-object of the most derived object. 

<p>
<li>
Otherwise, the run-time check fails.
</ul>

<p>
The first check corresponds to a "base-to-derived cast" and the second
to a "cross cast".
These tests are implemented by abi::__dynamic_cast:

<pre><code>
   void* abi::__dynamic_cast ( const void *sub,
			       const abi::__class_type_info *src,
			       const abi::__class_type_info *dst,
			       std::ptrdiff_t src2dst_offset);
   /* sub: source address to be adjusted; nonnull, and since the
    *      source object is polymoprhic, *(void**)sub is a vptr.
    * src: static type of the source object.
    * dst: destination type (the "T" in "dynamic_cast<T>(v)").
    * obj2sub_offset: a static hint about the location of the
    *    source subobject with respect to the complete object;
    *    special negative values are:
    *       -1: no hint
    *       -2: src is not a public base of dst
    *       -3: src is a multiple public base type but never a
    *           virtual base type
    *    otherwise, the src type is a unique public nonvirtual
    *    base type of dst at offset obj2sub_offset from the
    *    origin of dst.
    */

</pre></code>

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
Rationale: 
<ul>
<p>
<li> A simple dynamic_cast algorithm that is efficient in the common
    case of base-to-most-derived cast case is preferable to more
    sophisticated ideas that handle deep-base-to-in-between-derived
    casts more efficiently at a slight cost to the common case.
    Hence, an earlier scheme of providing a hash-table into the
    list of base classes
    (as is done e.g. in the HP aC++ compiler)
    was dropped.
<p>
<li> For similar reasons,
    we only keep direct base information about a class type.
    Indirect base information can be found by chasing type_info pointers
    (and care should be taken to determine ambiguous base class types).
<p>
<li> The GNU egcs development team has implemented an idea of this ABI
    group to accelerate dynamic_cast operations by a-posteriori
    checking a "likely outcome".
    This is the purpose of the src2dst_offset hint.
    An implementation is free to always pass -1 (no hint),
    or to always ignore the hint in __dynamic_cast.
</ul>
</i>

<p>
<h5>The exception handler matching algorithm</h5>

<p>
Since the RTTI related exception handling routines are "personality specific",
no interfaces need to be specified in this document
(beyond the layout of the RTTI data).


<p> <hr> <p>
<a name=external-names>
<h3> External Names (a.k.a. Mangling) </h3>

<i>
&lt;To be specified.>
</i>

<p>
<hr>

<p>
Please send corrections to <a href=mailto:dehnert@sgi.com>Jim Dehnert</a>.

</BODY>
</HTML>
