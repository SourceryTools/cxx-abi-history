<HTML>

<HEAD>
<title>C++ ABI for IA-64: Data Layout</title>

<link rel=stylesheet href=small-table.css type="text/css">
<link rel=stylesheet href=code.css type="text/css">

<hr>

<font size=6><i><b>
<p>
C++ ABI for IA-64: Data Layout
</b></i></font>

<font size=-1>
<p>
<i>Revised 21 March 2000</i>

</center>

</HEAD>

<BODY>


<p> <hr> <p>
<a name=intro>
<h3> Introduction </h3>

In this document, we define the memory layout for C++ data objects,
including both predefined and user-defined data types,
as well as internal compiler generated objects such as virtual tables.
<font color=red>
In general, this document is written as a generic specification,
to be usable by C++ implementations on a variety of architectures.
However, it does contain processor-specific material for the IA-64
64-bit ABI, identified as such.
</font>

<p>
In general, text appearing in this document in color is either
tentative wording of agreements,
or proposals not yet agreed upon,
and should be taken as more subject to change than black material.

<p>
<font color=blue>
Note that the body of this document makes free use of a number of terms
which are defined in the <i><b>Definitions</b></i> section below.
</font>

<p> <hr> <p>
<h3> Contents </h3>

<ul>
<li> <a href=#general> General </a>
<li> <a href=#definitions> Definitions </a>
<li> <a href=#limits> Limits </a>
<li> <a href=#namespace> Namespace and Header </a>
<li> <a href=#pod> POD Data Types </a>
<li> <a href=#member-pointers> Member Pointers </a>
<li> <a href=#class-types> Non-POD Class Types </a>
<li> <a href=#vtable> Virtual Table Layout </a>
<li> <a href=#vcall> Virtual Function Calling Conventions </a>
<li> <a href=#vtable-ctor> Virtual Tables During Object Construction </a>
<li> <a href=#array-ctor> Array Constructors and Destructors </a>
<li> <a href=#guards> Initialization Guard Variables </a>
<li> <a href=#rtti> Run-Time Type Information (RTTI) </a>
<li> <a href=#mangling> External Names (a.k.a. Mangling)</a>
<li> <a href=#revisions> Revision History</a>
</ul>

<p> <hr> <p>
<h3> Outstanding Questions </h3>
<font color=red>
There are outstanding questions in the body of the document to be
clarified:

<ul>

<a href=#guards>
<li> Specify initialization guard variables.
</a>

<a href=#vmi>
<li> Is there any useful purpose for the has-public-base flag in
    <code>vmi_flags</code> of <code>__vmi_class_type_info</code>?
    (Action item 37.)
</a>

<a href=#mangling-builtin>
<li> Are the ABI extended types __int64 and __float80 typedefs
    (of long long and long double respectively),
    typedefs of other builtin types,
    or distinct types?
    The current mangling assumes the first.
</a>

</ul>
</font>

<p> <hr> <p>
<h3> Revisions </h3>

<p>
<font color=blue>[000320]</font>
Clarify class size limit.
Editorial changes in vtable components description.
Add alternate to construction vtable proposal.
Clarification in array cookie specification.
Removed COMMON proxy from class RTTI.
Extensive changes to mangling writeup.

<p>
<font color=blue>[000314]</font>
Construction vtable modifications.
RTTI modifications for incomplete class types.
Mangling rework: grammar, new constructs, function return types.


<p>
<font color=blue>[000309]</font>
Add limits section.
Specify NULL member pointer values.
Combine vtable content and order sections; clarify ordering.
Specify when distinct virtual function entries are needed for overriders.
Define (and modify) vector constructor/destructor runtime APIs.
Virtual base offsets are promoted from non-virtual bases.

<p>
<font color=blue>[000228]</font>
Add thunk definition.
Revise inheritance graph order definition.
Fix member function pointer description (no division by two).
Move bitfield allocation description (much modified)
to the non-virtual-base allocation description.
Replace virtual function calling convention description.

<p>
<a href=#revisions>Revision History</a>


<p> <hr> <p>
<a name=definitions>
<h3> Definitions </h3>

<p>
The descriptions below make use of the following definitions:

<dl>

<p>
<dt> <i>alignment</i> of a type T (or object X)</dt>
<dd>
A value A such that any object X of type T has an address satisfying
the constraint that &X modulo A == 0.

<p>
<dt> <i>direct base class order</i> </dt>
<dd>
When the direct base classes of a class are viewed as an ordered set,
the order assumed is the order declared, left-to-right.

<p>
<dt> <i>diamond-shaped inheritance</i> </dt>
<dd>
A class has diamond-shaped inheritance iff it has a virtual base class
that can be reached by distinct inheritance graph paths through
more than one direct base.

<p>
<dt> <i>dynamic class</i> </dt>
<dd>
A class requiring a virtual table pointer
(because it or its bases have one or more virtual member functions or
virtual base classes).

<p>
<dt> <i>empty class</i> </dt>
<dd>
A class with no non-static data members other than zero-width bitfields,
no virtual functions, no virtual base classes,
and no non-empty non-virtual base classes.

<p>
<dt> <i>inheritance graph</i> </dt>
<dd>
A graph with nodes representing a class and all of its subobjects,
and arcs connecting each node with its direct bases.

<p>
<dt> <i>inheritance graph order</i> </dt>
<dd>
The ordering on a class object and all its subobjects obtained
by a depth-first traversal of its inheritance graph,
where:

<ul>
<p>
<li> No node is visited more than once.
(So, a virtual base subobject, and all of its base subobjects,
will be visited only once.)

<p>
<li>
The subobjects of a node are visited in the order in which they
were declared.
(So, given <code>class A : public B, public C</code>,
A is walked first,
then B and its subobjects,
and then C and its subobjects.)
</ul>

<p>
<a name=q3></a>
<dt> <i>nearly empty class</i> </dt>
<dd>
A class that contains no data except its virtual pointer (if any) or
virtual bases.  In particular, it:
<ul>
<li> has no non-static data members other than zero-width bitfields,
<li> has no base classes that are not either empty, nearly empty,
     or virtual, and
<li> has at most one non-virtual, nearly empty base class.
</ul>
Such classes may be primary base classes even if virtual,
sharing a virtual pointer with the derived class.

<p>
<dt> <i>primary base class</i> </dt>
<dd>
For a dynamic class,
the unique base class (if any) with which it shares the virtual pointer
at offset 0.

<p>
<dt> <i>secondary vtable</i> </dt>
<dd>
The instance of a vtable for a base class
that is embedded in the vtable of a class derived from it.

<p>
<dt> <i>thunk</i> </dt>
<dd>
A segment of code associated (in this ABI) with a target function,
which is called instead of the target function for the purpose of
modifying parameters (e.g. <code>this</code>)
or other parts of the environment
before transferring control to the target function,
and possibly making further modifications after its return.
A thunk may contain as little as an instruction to be executed prior to
falling through to an immediately following target function,
or it may be a full function with its own stack frame that does
a full call to the target function.

<p>
<dt> <i>virtual table</i> (or <i>vtable</i>) </dt>
<dd>
A dynamic class has an associated table
(often several instances, but not one per object)
which contains information about its dynamic attributes,
e.g. virtual function pointers, virtual base class offsets, etc.

<p>
<dt> <i>vtable group</i> </dt>
<dd>
The primary vtable for a class along with all of the associated
secondary vtables for its base classes.

</dl>


<p> <hr> <p>
<a name=general>
<h3> General </h3>

<p>
In what follows, we define the memory layout for C++ data objects.
Specifically, for each type, we specify the following information about
an object O of that type:
<ul>
<li> the <i>size</i> of an object, <i>sizeof</i>(O);
<li> the <i>alignment</i> of an object, <i>align</i>(O); and
<li> the <i>offset</i> within O, <i>offset</i>(C),
     of each data component C, i.e. base or member.
</ul>

<p> For purposes internal to the specification,
we also specify:

<ul>
<li> <i>dsize</i>(O):
the <i>data size</i> of an object,
which intuitively is sizeof(O) minus the size of tail padding.

<p>
<li> <i>nvsize</i>(O):
the <i>non-virtual size</i> of an object,
which intuitively is dsize(O) minus the size of virtual bases.
It is always equal to <i>dsize</i>(O) for types without virtual bases.

<p>
<li> <i>nvalign</i>(O):
the <i>non-virtual alignment</i> of an object,
which intuitively is the alignment determined by ignoring virtual bases.
It is always equal to <i>align</i>(O) for types without virtual bases.

</ul>

<p> <hr> <p>
<a name=limits>
<h3> Limits </h3>

<p>
Various representations specified by this ABI impose limitations on
conforming user programs.
These include, for the 64-bit IA-64 ABI:

<ul>
<p>
<li>
The offset of a non-virtual base subobject in the full object containing
it must be representable by a 56-bit signed integer
(due to RTTI implementation).
<font color=red>
This implies a practical limit of 2**55 bytes on the size of a class.
</font>

</ul>


<p> <hr> <p>
<a name=namespace>
<h3> Namespace and Header </h3>

<p>
This ABI specifies a number of type and function APIs supplemental
to those required by the ISO C++ Standard.
A header file named <code>cxxabi.h</code> will be provided by
implementations that declares these APIs.
The reference header file included with this ABI definition
shall be the authoritative definition of the APIs.

<p>
These APIs will be placed in a namespace <code>__cxxabiv1</code>.
The header file will also declare a namespace alias <code>abi</code>
for <code>__cxxabiv1</code>.
It is expected that users will use the alias,
and the remainder of the ABI specification will use it as well.

<p>
In general,
API objects defined as part of this ABI are assumed to be extern "C++".
However, some (many?) are specified to be extern "C" if they:
<ul>
<li> are expected to be called by users from C code,
     e.g. <code>longjmp_unwind</code>; or
<li> are expected to be called only implicitly by compiled code,
     and are likely to be implemented in C.
     Note: this second exception has not yet been adopted.
</ul>



<p> <hr> <p>
<a name=pod>
<h3> POD Data Types </h3>

<p>
The size and alignment of C POD types is as specified by the base (C) ABI.
Type bool has size and alignment 1.
All of these types have data size and non-virtual size equal to their size.
(We ignore tail padding for PODs because the Standard does not allow us
to use it for anything else.)


<p> <hr> <p>
<a name=member-pointers></a>
<h3> Member Pointers </h3>

<p>
A pointer to data member is an offset from the base
address of the class object containing it,
represented as a <code>ptrdiff_t</code>.
It has the size and alignment attributes of a <code>ptrdiff_t</code>.
A NULL pointer is represented as -1.

<p>
A pointer to member function is a pair <ptr, adj> as follows:

<dl>
<p>
<dt> <code>ptr</code>:
<dd> For a non-virtual function, this field is a simple function pointer.
     (Under current base IA-64 psABI conventions,
     that is a pointer to a GP/function address pair.)
     For a virtual function,
     it is 1 plus the Vtable offset (in bytes) of the function,
     represented as a <code>ptrdiff_t</code>.
     The value zero represents a NULL pointer,
     independent of the adjustment field value below.

<p>
<dt> <code>adj</code>:
<dd> The required adjustment to <i>this</i>,
     represented as a <code>ptrdiff_t</code>.
</dl>

<p>
It has the size, data size, and alignment
of a class containing those two members, in that order.
(For 64-bit IA-64, that will be 16, 16, and 8 bytes respectively.)



<p> <hr> <p>
<a name=class-types></a>
<h3> Non-POD Class Types </h3>

For non-POD class types C, assume that all component types
(i.e. base classes and non-static data member types)
have been laid out, defining size, data size, non-virtual size,
alignment, and non-virtual alignment.
(See the description of these terms in
<a href=#general><b>General</b></a> above.)
Layout (of type C) is done using the following procedure.

<ol type=I>
<p>
<li> <h5> Initialization </h5>
  <ol type=1>
  <p>
  <li> Initialize sizeof(C) to zero, align(C) to one, dsize(C) to zero.

  <p>
  <li> If C is a dynamic class type:
      <ol type=a>
      <p>
      <li> Identify all virtual base classes, direct or indirect,
	   that are primary base classes for some other direct or indirect
	   base class.
	   Call these <i>indirect primary base classes</i>.

      <p>
      <li> If C has a dynamic base class,
	   attempt to choose a primary base class B.
	   It is the first (in direct base class order)
	   non-virtual dynamic base class, if one exists.
	   Otherwise, it is a nearly empty virtual base class,
	   the first one in inheritance graph order which
	   is not an indirect primary base class if any exist,
	   or just the first one if they are all indirect primaries.

	   <p>
	   Allocate the chosen primary base at offset zero, and set
	   sizeof(C) to sizeof(B), align(C) to nvalign(B),
	   dsize(C) to nvsize(B).
	   This step allocates only B's non-virtual part,
	   i.e. excluding any direct or indirect bases.

      <p>
      <li> Otherwise, allocate the vtable pointer for C at offset zero,
	   and set sizeof(C), align(C), and dsize(C) to the appropriate
	   values for a pointer (all 8 bytes for IA-64 64-bit ABI).
      </ol>
  </ol>

<p>
<li> <h5> Non-Virtual-Base Allocation </h5>
<p>
For each data component D (i.e. base or non-static data member)
except virtual bases,
first the non-virtual base classes in declaration order
and then the non-static data members in declaration order,
allocate as follows:

  <ol type=1>

  <p>
  <li> If D is a bitfield, i.e. declared as "<code>T [b]: n;"</code>,
       for some integral POD type T and bit count n,
       there are two cases depending on <code>sizeof(T)</code>
       and <code>n</code>:

       <ol type=a>
       <p>
       <li>
       If <code>sizeof(T)*8 >= n</code>,
       the bitfield is allocated as required by the underlying C psABI.
       That is, it will be placed in the next available n bits,
       subject to the constraint that it does not cross an alignment
       boundary for type <code>T</code>.
       The next available n bits are at offset dsize(C),
       unless the preceding byte is only partially filled by a bitfield,
       in which case the bitfield allocation can begin in that byte.
	<p>
	Update align(C) to max (align(C), align(T)).

       <p>
       <li>
       If <code>sizeof(T)*8 < n</code>,
       let T' be the largest integral POD type with
       <code>sizeof(T')*8 <= n</code>.
       The bitfield is allocated starting at the next offset aligned
       appropriately for T', with length n bits.
       The first <code>sizeof(T)*8</code> bits are used to hold the
       value of the bitfield,
       followed by <code>n - sizeof(T)*8</code> bits of padding.
	<p>
	Update align(C) to max (align(C), align(T')).
       </ol>

       <p>
       In either case,
       update sizeof(C) and dsize(C) to include the last byte
       containing (part of) the bitfield.

  <p>
  <li> Otherwise, if D is not an empty base class
	(including all data members),
	start at offset dsize(C),
	incremented if necessary to alignment nvalign(type(D)).
	Place D at this offset unless doing so would result in two
	components (direct or indirect) of the same type having the
	same offset.
	If such a component type conflict occurs,
	increment the candidate offset by nvalign(type(D)),
	and try again,
	repeating until success occurs
	(which will occur no later than sizeof(C) rounded up to the
	required alignment).

	<p>
	If D is a base class, this step allocates only its non-virtual
	part, i.e. excluding any direct or indirect virtual bases.

	<p>
	Update sizeof(C) to max (sizeof(C), offset(D)+nvsize(D)).
	Update align(C) to max (align(C), nvalign(D)).
	If D is a base class (not empty in this case),
	update dsize(C) to offset(D)+nvsize(D).
	If D is a data member,
	update dsize(C) to max (offset(D)+dsize(D), offset(D)+1).

  <p>
  <li> If D is an empty base class,
	its allocation is similar to case (2) above,
	except that additional candidate offsets are considered before
	starting at dsize(C).
	First, attempt to place D at offset zero.
	If unsuccessful (due to a component type conflict),
	proceed with attempts at dsize(C) as for non-empty bases.
	As for that case, if there is a type conflict at dsize(C)
	(with alignment updated as necessary),
	increment the candidate offset by nvalign(type(D)),
	and try again,
	repeating until success occurs.

	<p>
	Once offset(D) has been chosen,
	update sizeof(C) to max (sizeof(C), offset(D)+sizeof(D)).
	Note that nvalign(D) is 1, so no update of align(C) is needed.
	Similarly, since D is an empty base class,
	no update of dsize(C) is needed.

  </ol>

  <p>
  After all such components have been allocated,
  set nvsize(C) = dsize(C) and nvalign(C) = align(C).
  These values will not change during virtual base allocation.

<p><a name=a17></a>
<li> <h5> Virtual Base Allocation </h5>
<p>

<p>
Finally allocate any direct or indirect virtual base classes
(except the primary base class or any indirect primary base classes)
as we did non-virtual base classes
<font color=red>
in step II-2 (if empty) or II-3 (if non-empty),
</font>
in inheritance graph order.
Update sizeof(C) to max (sizeof(C), offset(D)+nvsize(D)).
If non-empty, also update align(C) and dsize(C) as in II-2.

<p>
The primary base class has already been allocated in I-2b.
Any indirect primary base class E of the current class C,
has been chosen as the primary base class of some other base class
(direct or indirect, virtual or non-virtual) of C,
will be allocated as part of that other base class,
and is not allocated here.
If E is a primary base class of more than one other base,
the instance used as its allocation in C shall be the first such
in the inheritance graph order.

<p>
<li> <h5> Finalization </h5>
<p>
Round sizeof(C) up to a non-zero multiple of align(C).

</ol>


<p> <hr> <p>
<a name=vtable></a>
<h3> Virtual Table Layout </h3>

<p>
<h4> General </h4>

<p>
A <i>virtual table</i> (<i>vtable</i>) is a table of information used
to dispatch virtual functions,
to access virtual base class subobjects,
and to access information for runtime type identification (RTTI).
Each class that has virtual member functions or virtual bases
has an associated set of vtables.
There may be multiple vtables for a particular class,
if it is used as a base class for other classes.
However, the vtable pointers within all the objects (instances)
of a particular most-derived class point to the same set of vtables.

<p>
A vtable consists of a sequence of offsets, data pointers,
and function pointers, as well as structures composed of such items.
We will describe below the sequence of such items.
Their offsets within the vtable are determined by that allocation
sequence and the natural ABI size and alignment,
just as a data struct would be.  In particular:
<ul>
<li> Offsets are of type <code>ptrdiff_t</code> unless otherwise stated.
<li> Data pointers have normal pointer size and alignment.
<li> Function pointers remain to be defined.
     One possibility is that they will be
     &lt;function address, GP address> pairs, with pointer alignment.
</ul>

<p>
In general, what we consider the address of a vtable
(i.e. the address contained in objects pointing to a vtable)
may not be the beginning of the vtable.
We call it the <i>address point</i> of the vtable.
The vtable may therefore contain components at either positive or
negative offsets from its address point.

<p>
<h4> Virtual Table Components and Order </h4>

<p>
Virtual tables may contain of the components described below.
If present, the components are present in the order described,
except for the exceptions specified.

<ul>
<p>
<li>
<i>Virtual call (vcall) offsets</i> are used
to perform pointer adjustment for overridden virtual functions.
These entries are allocated
<font color=red>
in the secondary vtable containing the virtual function pointer for the
overridden function when the corresponding
</font>
class is used as a virtual base,
to find the necessary adjustment from the base to the derived class,
if any.
When a virtual function is invoked via a virtual base,
but has been overridden in a derived class,
the overriding function adds this value to its <code>this</code> pointer
to get the address of the derived object where the function was overridden.
These values may be positive or negative.
These are first in the vtable if present,
ordered as defined in categories 3 and 4 below.

<p>
<li>
<a name=q1></a>
<i>Virtual Base (vbase) offsets</i> are used to access
the virtual bases of an object.
Such an entry is added to the derived class object address
(i.e. the address of its vtable pointer)
to get the address of a virtual base class.
Such an entry is required for each virtual base class.
The values can be positive or negative.

<br>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
However, in classes sharing a vtable with a primary base class,
the vcall and vbase offsets added by the derived class all come before
the vcall and vbase offsets required by the base class,
so that the latter may be laid out as required by the base class
without regard to additions from the derived class(es).
</i>

<p>
<li>
The <i>offset to top</i> holds the displacement to the top of the object
from the location within the object of the vtable pointer that addresses
this vtable,
as a&nbsp; <code>ptrdiff_t</code>.
It is always present.
The offset provides a way to find the top of the object from any base
subobject with a vtable pointer.
This is necessary for dynamic_cast&lt;void*> in particular.

<font color=red>
<p>
<i>In a complete object vtable,
and therefore in all of its primary base vtables,
the value of this offset will be zero.
For the secondary vtables of other non-virtual bases,
and of many virtual bases,
it will be negative.
Only in some construction vtables will some virtual base vtables have
positive offsets, due to a different ordering of the virtual bases in
the full object than in the subobject's standalone layout.
</i>
</font>

<p>
<li>
The <i>typeinfo pointer</i> points to the typeinfo object used for RTTI.
It is always present.
All entries in each of the vtables for a given class must point to the
same typeinfo object.
A correct implementation of typeinfo equality is to check pointer equality.
The typeinfo pointer is a valid pointer for polymorphic classes,
i.e. those with virtual functions,
and is zero for non-polymorphic classes.

<p>
<li>
The vtable address point points here,
i.e. this is the vtable address contained in an object's virtual pointer.
This address must have the alignment required for pointers.

<p>
<li>
<i>Virtual function pointers</i> are used for virtual function dispatch.
Each pointer holds either the address of a virtual function of the class,
or the address of a secondary entry point that performs certain
adjustments before transferring control to a virtual function.

<p>
<font color=red>
The form of a virtual function pointer is specified by the
processor-specific C++ ABI for the implementation.
In the specific case of 64-bit IA-64 shared library builds,
a virtual function pointer entry contains a pair of components
(each 64 bits):
</font>
the value of the target GP value and the actual function address.
That is, rather than being a normal function pointer,
which points to such a two-component descriptor,
a virtual function pointer entry is the descriptor.

<p>
The order of the virtual function pointers in a vtable is the order
of declaration of the corresponding member functions in the class.
There is an entry for any virtual function declared in a class,
whether it is a new function or overrides a base class function,
unless it overrides a function from the primary base,
and conversion between their return types does not require an adjustment.
(In the case of this exception,
the primary base and the derived class share the vtable,
and can share the virtual function entry because no adjustments are
necessary.)

<p>
When a derived class and its primary base share a vtable,
the virtual function entries introduced by the derived class follow
those for the primary base,
so that the layout of the primary base's embedded vtable is the same as
that of its standalone vtable.

<p>
The entries for virtual destructors are actually pairs of entries.
The first destructor, called the not-in-charge destructor,
performs the destruction without calling delete() on the object.
The second destructor, called the in-charge destructor,
calls delete() after destroying the object.
Both destroy any virtual bases;
a separate, non-virtual entry performs destruction of the object but
not its virtual base subobjects, and does not call delete().

</ul>

<p>
Following the primary vtable of a derived class are
<i>secondary vtables</i> for each of its base classes,
except any primary base(s) with which it shares its primary vtable.
These are copies of the vtables for the respective base classes
(copies in the sense that they have the same layout,
though the fields may have different values).
We call the collection consisting of a primary vtable along with all of
its secondary vtables a <i>vtable group</i>.
The order in which they occur is the same as the order in which the
base class subobjects are considered for allocation in the derived object:

<ul>
<p>
<li>
First are the vtables of direct non-primary, non-virtual bases,
in the order declared,
including their secondary vtables for non-virtual bases in the order
they appear in the standalone vtable group for the base.
(Thus the effect is that these vtables occur in inheritance graph order,
excluding primary bases and virtual bases.)

<p>
<li>
Then come the virtual base vtables,
also in inheritance graph order,
and again excluding primary bases
(which share vtables with the classes for which they are primary).
</ul>


<p>
<h4> Virtual Table Construction </h4>

<p>
In this section, we describe how to construct the vtable for an class,
given vtables for all of its base classes.
To do so, we divide classes into several categories,
based on their base class structure.

<p>
<h5> Category 0: Trivial </h5>

Structure:
<ul>
<li> No virtual base classes.
<li> No virtual functions.
</ul>

<p>
Such a class has no associated vtable,
and its objects contain no vptr.

<p>
<h5> Category 1: Leaf </h5>

Structure:
<ul>
<li> No inherited virtual functions.
<li> No virtual base classes.
<li> Declares virtual functions.
</ul>

<p>
The vtable contains offset-to-top and RTTI fields
followed by virtual function pointers.
There is one function pointer entry for each
virtual function declared in the class.

<p>
<h5> Category 2: Non-Virtual Bases </h5>

Structure:
<ul>
<li> Only non-virtual base classes.
<li> Inherits virtual functions.
</ul>

<p>
The class has a vtable for each base class that has a vtable.
The class's vtables are constructed from copies of the base class vtables.
The entries are the same, except:

<ul>
<p>
<li> The offset-to-top and RTTI fields
     contain information for the class,
     rather than for the base class. 

<p>
<li> The function pointer entries for virtual functions inherited from
     the base class and overridden by this class are replaced with the
     addresses of the overriding functions
     (or the corresponding adjustor secondary entry points).
</ul>

<p>
For a base class <code>Base</code>,
and a derived class <code>Derived</code> for which we are constructing
this set of vtables,
we shall refer to the vtable for <code>Base</code> as
<code>Base-in-Derived</code>.
The vptr of each base subobject of an object of the derived class will
point to the corresponding base vtable in this set.

<p>
The vtable copied from the primary base class is also called the
primary vtable;
it is addressed by the vtable pointer at the top of the object.
The other vtables of the class are called secondary vtables;
they are addressed by vtable pointers inside the object.

<p>
Following the function pointer entries that correspond to those of the
primary base class,
the primary vtable holds the following additional entries at its tail:
<ul>
<li> Entries for virtual functions introduced by this class.
<li> Entries for overridden virtual functions not already in the vtable.
     (These are also called replicated entries because they are already
     in the secondary vtables of the class.)
</ul>

The primary vtable, therefore,
has the base class functions appearing before the derived class functions.
The primary vtable can be viewed as two vtables accessed
from a shared vtable pointer. 

<p>
<i>Note</i>:
Another benefit of replicating virtual function entries is that it
reduces the number of this pointer adjustments during virtual calls.
Without replication,
there would be more cases where the this pointer would have to be
adjusted to access a secondary vtable prior to the call.
These additional cases would be exactly those where the function
is overridden in the derived class,
implying an additional thunk adjustment back to the original pointer.
Thus replication saves two adjustments for each virtual call to an
overridden function introduced by a non-primary base class. 

<p>
<h5> Category 3: Virtual Bases Only </h5>

<p>
Structure:
<ul>
<li> Only virtual base classes.
<li> Base classes are not empty or nearly empty.
</ul>

<p>
The class has a vtable for each virtual base class that has a vtable.
These are all secondary vtables and are constructed from copies of the
base class vtables according to the same rules as in Category 2,
except that the vtable for a virtual base A also includes a vcall
offset entry for each virtual function represented in A's primary
vtable and the secondary vtables from A's non-virtual bases.
The vcall offset entries are allocated from the inside out,
in the same order as the functions appear in A's vtables.

<p>
The class also has a vtable that is not copied from the virtual base
class vtables.
This vtable is the primary vtable of the class and is addressed by the
vtable pointer at the top of the object, which is not shared.
It holds the following function pointer entries: 

<ul>
<p>
<li> Entries for virtual functions introduced by this class.

<p>
<li> Entries for overridden virtual functions.
     (These are also called replicated entries,
     because they are already in the secondary vtables of the class.)
</ul>

<p>
The primary vtable also has virtual base offset entries
to allow finding the virtual base subobjects.
There is one virtual base offset entry for each virtual base class,
direct or indirect.
The entries are in the reverse of the inheritance graph order.
That is, the entry for the leftmost virtual
base is closest to the address point of the vtable.
If there is a primary base class,
its virtual base and vcall offsets come first
(i.e. closest to the vtable address point)
so that they are in their previously defined locations for the base,
followed by the additional entries required by the full derived class.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>The above rule for laying out the virtual offsets
is a specialization of the Category 4 rule below,
made possible by the absence of non-virtual bases.
It does not provide a different layout than the full Category 4 rule.
</i>


<p>
<h5> Category 4: Complex </h5>

<p>
Structure:
<ul>
<li> None of the above,
     i.e. directly or indirectly inherits both virtual and non-virtual
     base classes, or at least one nearly empty virtual base class.
</ul>

<p>
The rules for constructing vtables of the class are a combination of
the rules from Categories 2 and 3,
and for the most part can be determined inductively.
However the rules for placing virtual base offset entries in the
vtables requires elaboration. 

<p>
The primary vtable also has virtual base offset entries
to allow finding the virtual base subobjects.
There is one virtual base offset entry for each direct virtual base class,
and one for each indirect virtual base class
inherited via a direct virtual base class.
(Indirect virtual base classes inherited via direct non-virtual base classes
may be accessed via the the offset stored in the base's vtable.)
If an indirect virtual base class is inherited via both virtual and
non-virtual direct base classes,
no virtual base offset entry is included for it.
The entries are in the reverse of the inheritance graph order.
That is, the entry for the leftmost virtual
base is closest to the address point of the vtable.
If there is a primary base class,
its virtual base and vcall offsets come first
(i.e. closest to the vtable address point)
so that they are in their previously defined locations for the base,
followed by the additional entries required by the full derived class.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>For an S-as-T vtable,
the vbase offset entries from the primary vtable for T
are replaced with appropriate offsets given the completed hierarchy.
</i>

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>Consider the following inheritance hierarchy:
<code><pre>
  struct S {};
  struct T : virtual public S {};
  struct U : virtual public T {};
  struct V : public T, virtual public U {};
</pre></code>
<p>
T's vtable contains a virtual base offset for S.
U's vtable contains virtual base offsets for S and T.
V's vtable contains a virtual base offset for U,
but not for T because it is non-virtual,
nor for S because it is already present as a virtual base of T.
</i>

<p>
<a name=vcall>
<h4> Virtual Function Calling Convention </h4>
</a>

<p>
This section sketches the calling convention for virtual functions,
based on the above virtual table layout.
<i>See also the <a href=abi-examples.html#vcall>ABI examples</a>
document for motivating examples and potential implementations.</i>

<p>
We explain, at a high level,
what information must be present in the vtable for a class A
which declares a virtual function f in order that,
given an pointer of type A*,
the caller can call the virtual function f.
This section does not specify exactly where that information is located
(see above),
nor does it specify how to convert a pointer to a class
derived from A to an A*,
if that is required.

<p>
When this section uses the term <i>function pointer</i> it is understood
that this term may refer either to a traditional function pointer
(i.e., a pointer to a GP/address pair) or a GP/address pair itself.
Which of these alternatives is actually used
is specified elsewhere in the ABI,
but is independent of the description in this section.

<p>
Throughout this section,
we assume that A is the class for which we are creating a vtable,
B is the most derived class in the hierarchy,
and C is the class that contains C::f,
the unique final overrider for A::f.
This section specifies the contents of the f entry in the A-in-B vtable.
(If A is primary base in the hierarchy,
then the A-in-B vtable will be shared with the derived class vtable --
but the contents of the A portion of that vtable
will still be as specified here.)

<p>
In all cases, the <i>non-adjusting entry point</i> for a virtual
function expects the `this' pointer to point to an instance of the
class in which the virtual function is defined.
In other words, the non-adjusting entry point for C::f will expect
that its `this' pointer points to a C object.

<p>
We say that a subobject X is a <i>morally virtual</i> base of Y
if X is an indirect or direct base class of Y,
and if X is either a virtual base of Y,
or the direct or indirect base of a virtual base of Y.


<p>
The calling convention is as follows:

<ul>
<li>Vtable Components:
<p>
For each virtual function defined in a class C,
we add an entry to its vtable if one is not already there
(i.e. if it is not overriding a function in its primary base).
In particular, a definition which overrides a function inherited from
a secondary base gets a new slot in the primary vtable.
We do this to avoid useless adjustments when calling a virtual
function through a pointer to the most derived class.

<p>
The content of this entry for class A is a function pointer,
as determined by one of the following cases.
Recall that we are dealing with a hierarchy where B is most derived,
A is a direct (or indirect) base of B defining f,
and C contains the unique final overrider C::f of A::f.

<ol type=1>
<p>
<li> A = C
<p>
(In this case, we are creating either the primary vtable for A,
or the A-in-B secondary vtable.)
<p>
The vtable contains a function pointer pointing to the
non-adjusting entry point for A::f.

<p>
<li> A = C
<p>
In this case, we are creating the A-in-B secondary vtable.
<p>
The vtable contains a pointer to an entry point that performs the
adjustment from an A* to a C*,
and then transfers control to the non-adjusting entry point for C::f.
</ol>

<p>
When a class is used as a virtual base,
we add a vcall offset slot to the beginning of its vtable for each of
the virtual functions it provides,
whether in its primary or secondary vtables.
Derived classes which override these functions may use the slots to
determine the adjustment necessary.

<p>
<li>Callee:
<p>
For each direct or indirect base A of C that is not a morally virtual
base of C,
the compiler must emit, in the same object file as the code for C::f,
an <i>A-adjusting entry point</i> for C::f.
This entry point will expect that its <code>this</code> pointer
points to an A*,
and will convert it to a C* before transferring control
to the non-adjusting entry point for C::f.

<p>
For each direct or indirect virtual base V of C such that either V declares f,
or is derived from a class that declares f,
the compiler must emit, in the same object file as the code for C::f,
a <i>V-adjusting entry point</i> for C::f.
This entry point will expect that its <code>this</code> pointer
points to the unique virtual V subobject of C.
(Note that there may in general be multiple V subobjects of C,
but that only one of them will be virtual.)
This entry point must examine the V vtable given by its
<code>this</code> pointer,
extract the vcall offset corresponding to f located in that vtable,
and add this offset to the <code>this</code> pointer.
(Note that, as specified in the data layout document,
when V is used as a virtual base,
its vtable contains vcall offsets for every virtual function
declared in V or any of its bases.)
Then,
this entry point must transfer control to the non-adjusting entry point.

<p>
For each morally virtual base M of C such that M is <i><b>not</b></i>
a virtual base,
and such that M declares f,
the compiler must emit,
in the same object file as the code for C::f,
an <i>M-adjusting entry point</i> for C::f.
This entry point will expect that its <code>this</code> pointer
points to an A*,
and will convert it to a V*,
where V is the nearest virtual base to M along the path from C to M.
Then, it will convert the V* to a C* by using the vcall offset
stored in the V's vtable.
(Note that one implementation of the M-adjusting entry point
is to convert from M* to V*
and then transfer control to the V-adjusting entry point.)

<p>
<li>Caller:
<p>
When calling a virtual function f,
through a pointer of static type B*,
the caller

<ul>
<p>
<li>Selects a (possibly improper) subobject A of B
    such that A declares f.
    (In general, A may be the same as B.)
    (Note that A need not define f;
    it may contain either a definition of f,
    or a declaration of f as a pure virtual function.)

<p>
<li>Converts the B* to point to this subobject.
    (Call the resulting pointer `a'.)

<p>
<li>Uses the vtable pointer contained in the A subobject to locate
    the function pointer through which to perform the call.

<p>
<li>Calls through this function pointer,
    passing `a' as the <code>this</code> pointer.
</ul>

<i>
<p>
(Note that in general it will be optimal to select the class which
contained the final overrider (i.e., C)
as the class to which the B* should be converted.
This class is always a satisfactory choice,
since it is known to contain a definition of f.
In addition, if the dynamic type of the object is B,
then C::f will be the function ultimately selected by the call,
which means that C's vtable will
contain a pointer to the non-adjusting entry point,
meaning that no additional adjustments to the <code>this</code>
pointer will be required.

<p>
However, there may be cases in which choosing a different base
subobject could be superior.
For example, if there is an alternate base D which also declares f,
and a pointer to the D subobject is already available,
then it may be better to use the D subobject rather
than converting the B* to a C*,
in order to avoid the cost of the conversion.)
</i>


<p>
<li>Implementation
<p>
Note that the ABI only specifies the multiple entry points;
how those entry points are provided is unspecified.
An existing compiler which uses thunks could be converted to use this
ABI by only adding support for the vcall offsets.
A more efficient implementation would be to emit all of the thunks
immediately before the non-adjusting entry point to the function.
Another might emit a new copy of the function for each entry point;
this is a quality of implementation issue.
<i>See further discussion of implementation in the
<a href=abi-examples.html#vcall-impl>ABI examples</a> document.</i>
</ul>


<p> <hr> <p>
<a name=vtable-ctor>
<h3> Vtables During Object Construction (open issue C-4)</h3>

<p>
In some situations,
a special vtable called a construction vtable is used during
the execution of base class constructors and destructors.
These vtables are for specific cases of virtual inheritance.

<p>
During the construction of a class object, the object assumes the
type of each of its base classes, as each base class subobject is
constructed. RTTI queries in the base class constructor will return  
the type of the base class, and virtual calls will resolve to member  
functions of the base class rather than the complete class. Normally,  
this behavior is accomplished by setting, in the base class
constructor, the object's vtable pointers to the addresses of the
vtables for the base class.

<p>
However, if the base class has direct or indirect virtual bases, the  
vtable pointers have to be set to the addresses of construction
vtables. This is because the normal base class vtables may not hold  
the correct virtual base index values to access the virtual bases of  
the object under construction, and adjustment addressed by these
vtables may hold
the wrong this parameter adjustment if the adjustment is to cast
from a virtual base to another part of the object. The problem is
that a complete object of a base class and a complete object of a
derived class do not have virtual bases at the same offsets.

<p>
A construction vtable holds the virtual function addresses,
offset-to-top,
and RTTI information associated with the base class,
and virtual base offsets and addresses of adjustor entry points with their
parameter adjustments associated with objects of the complete class.

<p>
To ensure that the vtable pointers are set to the appropriate
vtables during base class construction, a table of vtable pointers,  
called the VTT, which holds the addresses of construction and
non-construction vtables is generated for the complete class. The
constructor for the complete class passes to each base class
constructor a pointer to the appropriate place in the VTT where the  
base class constructor can find its set of vtables. Construction
vtables are used in a similar way during the execution of base class  
destructors.

<p>
<h4> VTT Order</h4>

<p>
An array of vtable addresses, called the VTT,
is declared for each class type that needs a construction vtable.
A class needs a construction vtable if it has
indirect or direct virtual base classes.
<font color=red>
(Otherwise,
each base class may be initialized using its complete object vtable group.)
</font>

<p>
The elements of the VTT array are in this order:

<p>
<table border=1 cellpadding=5>

<tr> <th> Proposal A </th> </tr>
<tr> <td> <font color=red size=-1>
<ol>
<li>
Address of the vtable for the complete object,
which includes subobject vtables appended to it
as described in <a href=#vtable>Virtual Table Layout</a> above.

<p>
<li>
Addresses of construction vtables for each non-virtual subobject that needs
a construction vtable,
ordered as a VTT for the subobject.

<p>
This step is recursive:
the addresses of construction vtables for each subobject include the
addresses in 1 and 2 for each subobject class that
has non-virtual subobjects that need construction vtables.

<p>
<li>
Addresses of construction vtables for each virtual subobject in
initialization (DFS) order.
These addresses are as in #2 above,
and can be recursive for non-virtual bases within the virtual base subobjects.
The virtual VTT addresses are on the end because they are only passed
to the virtual base class constructors for the complete object.

</ol>

</font></td></tr>

<tr> <th> Proposal B </th> </tr>
<tr> <td> <font color=green size=-1>
<ol>
<li>
Address of the primary vtable for the complete object,

<li>
For each non-virtual subobject that needs a construction vtable, provide:

<ol>
<li>
Address of the primary construction
vtable for the subobject,

<li>
Address of any secondary construction
vtable for the subobject that either has virtual bases or has a virtual
function that is overridden along a virtual path in the complete object
constructor.
</ol>
This step is recursive between 1 and
2 -&nbsp; the addresses of construction vtables for each subobject include
the addresses in 1 and 2 for each subobject class that has non-virtual
subobjects that need construction vtables.
<li>
Addresses of secondary vtables that
either have virtual bases or virtual functions overridden on a virtual
path.

<li>
Addresses of construction vtables for
each virtual subobject in initialization (DFS) order.&nbsp; These addresses
are as in #2 above, and can be recursive for non-virtual bases within
the virtual base subobjects.&nbsp; The virtual VTT addresses are on the
end because they are only passed to the virtual base class constructors
for the complete object.
</ol>

</font></td></tr>

</table>

All vtable addresses in the VTT point to the beginning address of the vtable,
not the address that is assigned to the vptr.

<p>
<h4> Construction VTABLE Layout</h4>
The construction vtables for a complete object are appended to the vtable
in the order of their appearance in the VTT array.
So the vtable structures for a complete object of class C include,
<font color=red>
in no particular order:
</font>

<ul>
<li>
the main vtable group for C,
i.e. the vtable to which the primary vptr (at offset 0) points,
along with its base class subobject vtables in order of allocation,
including virtual base class subobject vtables;

<li>
the construction vtable groups for nonvirtual and virtual bases; and

<li>
the VTT array for C, providing location information for the above.
</ul>

<p>
<font color=red>
The VTT array is referenced via its own mangled external name,
and the construction vtable groups are accessed via the VTT array,
so the latter do not have external names.
</font>


<p>
Issues:
<ul>
<li>
We could separate the VTT array from the vtable,
and provide a new VTT data item.
<font color=purple>
We will do so.
</font>
<li>
We could also make the VTT static so it has no linkage
and is created in the modules that define the constructors and destructor
of a class.  I don't think they would take that much space.
<font color=purple>
We will not do this.
To avoid replicating the construction vtables, which are big,
we need to allocate them with the main vtable with a known interface.
So there's no benefit to putting the VTT elsewhere.
</font>
<li>
The subobject construction vtables do not need to be contiguous to the
normal vtable, since they will be accessed via the VTT.
<font color=purple>
We will do so.
</font>
</ul>

<p>
<h4> Construction VTABLE entries</h4>

<p>
<table border=1 cellpadding=5>

<tr> <th> Proposal A </th> </tr>
<tr> <td> <font color=red size=-1>

The construction vtable group for a base class subobject B
(of derived class D)
has the same entries in the same order as the main vtable group
for a complete object B,
as described in <a href=#vtable>Virtual Table Layout</a> above.

</font></td></tr>

<tr> <th> Proposal B </th> </tr>
<tr> <td> <font color=green size=-1>

The construction vtable group for a
base class subobject B (of derived class D)
does not have the same entries in the same
order as the main vtable group for a complete object B,
as described in <a href=#vtable>Virtual Table Layout</a> above.
Some of the base class subobject vtables may not need construction vtables,
so will not be present in the construction vtable group,
even though they are present in the main vtable group for the complete object.

</font></td></tr>

</table>

<p>
The <i>values</i> of some construction vtable entries will differ
from the corresponding entries in either the main vtable
group for B or the vtable group for B-in-D,
primarily because the virtual bases of B will be at different relative
offsets in a D object than in a standalone B object,
as follows:

<ol>
<li>
Virtual base class offsets reflect the positions of the virtual base
classes in the full D object.

<li>
Similarly, vcall offsets reflect the relative positions of the
overridden and overriding classes within the complete object D.

<li>
The offset-to-top fields refer to B
(and B's in particular will therefore be zero).

<li>
The RTTI pointers point to B's RTTI.

<li>
Only functions in B and its base classes are considered for virtual
function resolution.
</ol>


<p>
<h4> Subobject Construction and Destruction</h4>

<p>
The complete object (in-charge) constructors and destructors
find the VTT via its mangled name.
They pass the address of the subobject
entry in the VTT as a second parameter when calling
the subobject (not-in-charge) constructors and destructors.
The subobject ctor/dtors use the addresses passed to initialize
the primary vptr and vptrs that point to the classes which either have
virtual bases or override virtual functions with a virtual step
(have vcall offsets needing adjustment).

<p>
<table border=1 cellpadding=5>

<tr> <th> Proposal B </th> </tr>
<tr> <td> <font color=green size=-1>

If the not-in-charge constructor calls constructors for base class
subobjects that do not need construction vtables,
the construction vtable parameter is not passed to the base class
subobject constructor,
and the base class subobject constructors use
their complete object vtables for initialization.

</font></td></tr>

</table>

<p>
<i>
Note: The EDG compiler passes the constructor vtables
by assigning them to the subobject vptr
and the subobject constructors get the array address from the vptr.
This doesn't work when an exception is raised during construction,
and the destructor doesn't have the constructor vtable's address anymore.
There may be a way to make this work with the landing pad model,
but I haven't worked that out.
</i>

<p>Therefore the code for subobject constructor D which needs a construction
vtable with one base class subobject B that needs a construction vtable
would look like the following:

<p>
<table border=1 cellpadding=5>

<tr> <th> Proposal A </th> </tr>
<tr> <td> <font color=red>

<code><pre>
     static vtable *__VTT__1D[3] =
	{ D primary vtable,
	  ctorvtbl for B in D }; 

     D(D *this, vtable **ctorvtbls) 
     {
         // Call subobject constructors with ctorvtbls index
	 // if that base needs it. 
         B((B*)this, &ctorvtbls[1]); 
         // etc... 
         // Initialize vptr with primary ctorvtbls address (first element) 
         this->vptr = ctorvtbls[0][n];  // where n is the index of
					// first virtual function in vtbl. 
         // Initialize vptrs of subobjects with ctorvtbls addresses
	 // for the bases 
         ((B*)this)->vptr = ctorvtbls[0][m];
		 // where m is the index of the first virtual function 
		 // for base class subobject B 
         // Code for constructor. 
      }
</pre></code>

</font></td></tr>

<tr> <th> Proposal B </th> </tr>
<tr> <td> <font color=green>

<code><pre>
     static vtable *__VTT__1D[3] =
	{ D primary vtable,
	  ctorvtbl for B in D,
	  D secondary vtables }; 

     D(D *this, vtable **ctorvtbls) 
     {
         // Call subobject constructors with ctorvtbls index
	 // if that base needs it. 
	 if ( base B is not BORING ) {
	    B ( (B*)this, &ctorvtbls[1] ); 
	 } else {
	    BORING ( (BORING *)this );
	 }

         // etc... 

         // Initialize vptr with primary ctorvtbls address (first element) 
         this->vptr = ctorvtbls[0][n];  // where n is the index of
					// first virtual function in vtbl. 

         // Initialize vptrs of subobjects with ctorvtbls addresses
	 // for the bases 
	 if ( base B is not BORING ) {
	    ((B*)this)->vptr = ctorvtbls[2][m];
		 // where m is the index of the first virtual function 
		 // for base class subobject B 
	  
	 } else {
	    ((BORING *)this)->vptr = ctorvtbls[3][p];
	 }

         // Code for constructor. 
      }
</pre></code>

</font></td></tr>

</table>

<p>
A test program for this can be found in the
<a href=abi-examples.html#vtable-ctor>ABI Examples</a> document.

</font>



<p> <hr> <p>
<a name=array-ctor>
<h3> Array Constructors and Destructors </h3>

<p>
<a name=array-cookies>
<h4> Operator <code>new</code> Cookies </h4>

<p>
When operator <code>new</code> is used to create a new dynamic-length array,
a cookie is usually stored to remember the allocated length
(number of array elements)
so that it can be deallocated correctly.

<p>
Specifically:
<ul>
<p>
<li> No cookie is required if the array element type T has a trivial
    destructor (12.4 [class.dtor])
    and the usual (array) deallocation function
    (3.7.3.2 [basic.stc.dynamic.deallocation])
    function does not take two arguments.

    <p>
    (Note: if the usual array deallocation function takes two arguments,
<font color=red>
    then it is a member function whose second argument is of type size_t.
</font>
    The standard guarantees (12.5 [class.free])
    that this function will be passed the
    number of bytes allocated with the previous array new expression.

<p>
<li> No cookie is required if the <code>new</code> operator being used
    is <code>::operator new[](size_t, void*)</code>.

<p>
<li> Otherwise, this ABI requires a cookie, setup as follows:
  <ul>
  <li> The cookie will have size <code>sizeof(size_t)</code>.
  <li> Let <code>align</code> be the maximum alignment of
  <code>size_t</code> and an element of the array to be allocated.
  <li> Let <code>padding</code> be the maximum of
  <code>sizeof(size_t)</code> and <code>align</code> bytes.
  <li> The space allocated for the array will be the space required
  by the array itself plus <code>padding</code> bytes.
  <li> The alignment of the space allocated for the array will be
  <code>align</code> bytes.
  <li> The array data will begin at an offset of <code>align</code> bytes
  from the space allocated for the array.
  <li> The cookie will be stored in the <code>sizeof(size_t)</code> bytes
  immediately preceding the array data.
  </ul>

  <i>
  <p>
  These rules have the following consequences:
  <ul>
  <li> The array elements and the cookie are all aligned naturally.
  <li> Padding will be required if <code>sizeof(size_t)</code>
  is smaller than the array element alignment,
  and if present will precede the cookie.
  </ul>
  </i>

</ul>

<p>
Given the above, the following is pseudocode for processing
<code>new(ARGS) T[n]</code>:
<code><pre>
  if T has a trivial destructor (C++ standard, 12.4/3)
    padding = 0
  else if we're using ::operator new[](size_t, void*)
    padding = 0
  else
    padding = max(sizeof(size_t), alignof(T))

  p = operator new[](n * sizeof(T) + padding, ARGS)
  p1 = (T*) ( (char *)p + padding )

  if padding > 0
    *( (unsigned long *)p1 - 1) = n

  for i = [0, n)
    create a T, using the default constructor, at p1[i]

  return p1
</pre></code>

<p>
<a name=array-runtime>
<h4> Constructor/Destructor Runtime Support </h4>

<p>
An ABI-compliant system shall provide several runtime routines for use
in array construction and destruction.
They may be used by compilers, but their use is not required.
The required APIs are:

<dl>

<dt><code><pre>
void * abi::__cxa_vec_new (
		size_t element_count,
		size_t element_size,
		size_t padding_size,
		void (*constructor) ( void *this ),
		void (*destructor) ( void *this ) );
</pre></code></dt>
<dd>
Given the number and size of elements for an array,
and the size of prefix padding for a cookie,
allocate space for the array preceded by the specified padding,
initialize the cookie if the padding is non-zero,
and call the given constructor on each element.
Return the address of the array proper,
after the padding.
If allocation throws, rethrow.
If the constructor throws an exception,
call the given destructor for any already-constructed elements,
delete the space,
and rethrow the exception.
If the destructor throws an exception...
</dd>

<dt><code><pre>
void abi::__cxa_vec_ctor (
		void *array_address,
		size_t element_count,
		size_t element_size,
		void (*constructor) ( void *this ),
		void (*destructor) ( void *this ) );
</pre></code></dt>
<dd>
Given the (data) address of an array,
not including any cookie padding,
and the number and size of its elements,
call the given constructor on each element.
If the constructor throws an exception,
call the given destructor for any already-constructed elements,
and rethrow the exception.
If the destructor throws an exception...
If the constructor (destructor) pointer is NULL,
no constructor (destructor) call is to be made.
</dd>

<dt><code><pre>
void abi::__cxa_vec_dtor (
		void *array_address,
		size_t element_count,
		size_t element_size,
		void (*destructor) ( void *this ) );
</pre></code></dt>
<dd>
Given the (data) address of an array,
the number of elements,
and the size of its elements,
call the given destructor on each element.
If the destructor throws an exception,
rethrow after destroying the remaining elements if possible.
If the destructor throws a second exception, call terminate.
If padding_size is 0, the destructor pointer must be NULL.
If the destructor pointer is NULL,
no destructor call is to be made.
</dd>

<dt><code><pre>
void abi::__cxa_vec_delete (
		void *array_address,
		size_t element_size,
		size_t padding_size,
		void (*destructor) ( void *this ) );
</pre></code></dt>
<dd>
Given the (data) address of an array,
the size of prefix padding for the cookie,
and the size of its elements,
call the given destructor on each element,
using the cookie to determine the number of elements,
and then delete the space.
If the destructor throws an exception,
rethrow after destroying the remaining elements if possible.
If the destructor throws a second exception, call terminate.
If padding_size is 0, the destructor pointer must be NULL.
If the destructor pointer is NULL,
no destructor call is to be made.
</dd>

</dl>



<p> <hr> <p>
<a name=guards>
<h3> Initialization Guard Variables </h3>

<p>
Associated with each function-scope static variable requiring runtime
construction is a guard variable which is used to guarantee that
construction occurs only once.
Its name is mangled based on the mangling of the guarded object name,
to allow distinct instances of the function
(e.g. due to inlining) to use the same guard.

<p>
The size and content of the guard variable is not yet defined.
The specification will depend partially on the chosen approach to
threading support.



<p> <hr> <p>
<a name=rtti>
<h3> Run-Time Type Information (RTTI) </h3>

<p>
The C++ programming language definition implies that information about
types be available at run time for three distinct purposes:
<ol type=a>
<li> to support the typeid operator,
<li> to match an exception handler with a thrown object, and
<li> to implement the dynamic_cast operator.
</ol>
(c) only requires type information about dynamic class types,
but (a) and (b) may apply to other types as well;
for example, when a pointer to an int is thrown,
it can be caught by a handler that catches "int const*".

<p>
It is intended that two type_info pointers point to equivalent type
descriptions if and only if the pointers are equal.
An implementation must satisfy this constraint,
e.g. by using symbol preemption, COMDAT sections, or other mechanisms.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
Note that the full structure described by an RTTI descriptor may
include incomplete types not required by the Standard to be completed,
although not in contexts where it would cause ambiguity.
Therefore, any cross-references within the RTTI to types not known to
be complete must be weak symbol references.
</i>

<p>
<h5>Place of emission</h5>

<p>
It is desirable to minimize the number of places where a
particular bit of RTTI is emitted.
For dynamic class types,
a similar problem occurs for virtual function tables,
and hence the RTTI descriptor should be emitted
with the primary vtable for that type.
For other types, they must be emitted at the location
where their use is implied:
the object file containing the typeid, throw or catch.

<p>
Basic type information (e.g. for "int", "bool", etc.)
will be kept in the run-time support library.
Specifically, the run-time support library
should contain type_info objects for the types
X, X* and X const*,
for every X in: void, bool, wchar_t, char, unsigned char, signed char,
short, unsigned short, int, unsigned int, long, unsigned long, long long,
unsigned long long, float, double, long double.
(Note that various other type_info objects for class types may reside
in the run-time support library by virtue of the preceding rules;
e.g., that of std::bad_alloc.)


<p>
<h5>The typeid operator</h5>

<p>
The typeid operator produces a reference to a std::type_info structure
with the following public interface:

<pre><code>
  struct std::type_info {
     virtual ~type_info();
     bool operator==(type_info const&) const;
     bool operator!=(type_info const&) const;
     bool before(type_info const&) const;
     char const* name() const;
  };
</pre></code>

<p>
Assuming that after linking and loading only one type_info structure is
active for any particular type symbol,
the equality and inequality operators can be
written as address comparisons:
to type_info structures describe the same type
if and only if they are the same structure (at the same address).
In a flat address space
(such as that of the IA-64 architecture),
the before() member is also easily written in terms of an address comparison.
The only additional piece of information that is required is the
NTBS that encodes the name.
The type_info structure itself can hold a pointer into a read-only segment
that contains the text bytes.


<p>
<h5>Matching throw expressions with handlers</h5>

<p>
When an object is thrown a copy is made of it and the type of that copy
is TT.
A handler that catches type HT will match that throw if:
<ul>
  <li> HT is equal to TT except that HT may be a reference and that HT
	may have top-level cv qualifiers
	(i.e., HT can be "TT cv", "TT&" or "TT cv&"); or
  <li> HT is a reference to a public and unambiguous base type of TT; or
  <li> HT has a pointer type to which TT can be converted by a standard
	pointer conversion (though only public,
	unambiguous derived-to-base conversions are permitted)
	and/or a qualification conversion.
</ul>

<p>
This implies that the type information must keep a description of the public,
unambiguous inheritance relationship of a type, as well as the const
and volatile qualifications applied to types.


<p>
<h5>The dynamic_cast operator</h5>

<p>
Although dynamic_cast can work on pointers and references,
from the point of view of representation we need only to worry
about polymorphic class types.
Also, some kinds of dynamic_cast operations are handled at compile time
and do not need any RTTI.
There are then three kinds of truly dynamic cast operations:
<ul>
<li> dynamic_cast&lt;void cv*>, which returns a pointer to the complete lvalue,
<li> dynamic_cast operation from a base class to a derived class, and
<li> dynamic_cast across the hierarchy which can be seen as a cast to
	the complete lvalue and back to a sibling base.
</ul>

<p>
The most common kind of dynamic_cast is base-to-derived in a singly
inherited hierarchy.

<p>
<a name=rtti-layout></a>
<h5>RTTI layout</h5>

<ol type=1>

<p>
<li>
The RTTI layout for a given type depends on whether a 32-bit or
64-bit mode is in effect.
The class definitions below are to be interpreted as following the
class layout rules for the host ABI.

<p>
<li>
Every vtable shall contain one entry describing the offset from a
vptr for that vtable to the origin of the object containing that vptr
(or equivalently: to the vptr for the primary vtable).
This entry is directly useful to implement dynamic_cast&lt;void cv*>,
but is also needed for the other truly dynamic casts.
This entry is located two words ahead of the location
pointed to by the vptr (i.e., entry "-2").
This entry is present in all vtables,
even for classes having virtual bases but no virtual functions.

<p>
<li>
Every vtable shall contain one entry that is a pointer to an object
derived from std::type_info.
This entry is located at the word preceding the location
pointed to by the vptr (i.e., entry "-1").
The entry is allocated in all vtables;
for classes having virtual bases but no virtual functions,
the entry is zero.

<p>
std::type_info contains just two pointers:
<ul>
<li> its vptr
<li> a pointer to a NTBS representing the name of the type
</ul>

<p>
The possible derived types are:
<ul>
  <li> abi::__fundamental_type_info
  <li> abi::__pointer_type_info
  <li> abi::__array_type_info
  <li> abi::__function_type_info
  <li> abi::__enum_type_info
  <li> abi::__class_type_info
  <li> abi::__si_class_type_info
  <li> abi::__vmi_class_type_info
  <li> abi::__pointer_to_member_type_info
</ul>

<p>
<li>
abi::__fundamental_type_info adds no fields to std::type_info;

<p>
<li>
abi::__pointer_type_info adds two fields (in this order):
<ul>
  <p>
  <li> a flag word describing the cv-qualification
      and other attributes of the type pointed to
      (e.g., "int volatile*" should have the
      "volatile" bit set in that word);
      and
  <p>
  <li> a pointer to the std::type_info derivation for the unqualified type
    being pointed to.
</ul>

<p>
Note that the flag bits should not be folded into the pointer to
allow future definition of additional flags.
It contains:
<ul>
<li> 0x1: const qualifier
<li> 0x2: volatile qualifier
<li> 0x4: restrict qualifier
<li> 0x8: incomplete target type
</ul>

<p>
If the target type of the pointer is an incomplete class type,
<font color = red>
directly or indirectly,
</font>
a dummy class RTTI is generated for the incomplete type
that will not resolve to the final complete class RTTI
(because the latter need not exist),
possibly by making it a local static object,
and the incomplete target type flag is set
<font color=red>
in each pointer RTTI that references it directly or indirectly.
</font>

<p>
Two abi::__pointer_type_info objects are compared for equality
(i.e. of the types represented)
by checking for equal target type RTTI pointers unless either or both
have the incomplete flag set,
in which case the pointed-to RTTI structures must be checked for equality
(described below).

<p>
<li>
abi::__array_type_info and abi::__function_type_info do not add fields
to std::type_info
(these types are only produced by the typeid operator;
they decay in other contexts).
abi::__enum_type_info does not add fields either.

<p>
<li>
Three different types are used to represent type information:

<ol type=a>
<p>
<li>
abi::__class_type_info is used for class types having no bases,
and is also a base type for the other two class type representations.

<p>
This RTTI class may
also be used for incomplete class types when referenced by a pointer RTTI,
in which case it must be prevented from preempting
the RTTI for the complete class type,
for instance by emitting it as a static object (without external linkage).

<p>
Two abi::__class_type_info objects are compared for equality
(i.e. of the types represented)
<font color=red>
by comparison of the name NTBS in their std::type_info bases.
</font>

<p>
<li>
For classes containing only a single, public, non-virtual base
at offset zero (i.e. the derived class is dynamic iff the base is),
class abi::__si_class_type_info is used.
It adds to abi::__class_type_info
a single member pointing to the type_info structure for the base type,
declared "<code>__class_type_info const *type</code>".

<a name=vmi>
<p>
<li>
For classes with bases that do not satisfy the
__si_class_type_info constraints,
abi::__vmi_class_type_info is used.
It is derived from abi::__class_type_info, and adds fields:
  <ul>
  <p>
  <li> vmi_flags: a word with flags describing details
      about the class (most for use of the derived classes):
	<ul>
	<li> 0x01: class has non-diamond repeated inheritance
	<li> 0x02: class is diamond shaped
	<li> 0x04: class has non-publicly inherited base(s)
	<li> 0x08: class has publicly inherited base(s)
	      <font color=red> (See action item #37.) </font>

	</ul>
      All of these flags refer to both direct and indirect bases.
      The type of the _VMI_flags field is defined by each psABI,
      but must be at least 16 bits.
      For the 64-bit IA-64 ABI, it will be unsigned int (32 bits).

  <p>
  <li> vmi_base_count: a word with the number of direct base class
      descriptions that follow.
      The type of the _VMI_base_count field is defined by each psABI.
      For the 64-bit IA-64 ABI, it will be unsigned int (32 bits).

  <p>
  <li> vmi_bases[]: base class descriptions for every direct base;
       each description is of the type:
<pre><code>
      struct abi::__base_class_info {
         __class_type_info const *type;
	 long vmi_offset_flags;
      };
</pre></code>

      <p>
      The <code>type</code> member points to the RTTI for the base type.

      <p>
      The upper 56 bits of vmi_offset_flags are a signed offset.
      For a non-virtual base,
      this is the offset in the object of the base subobject.
      For a virtual base,
      this is the offset in the vtable of the
      virtual base offset for the virtual base referenced
      (in general, negative if introduced in this primary vtable,
      or positive if reused from a non-virtual base's vtable).

      <p>
      The lower byte of vmi_offset_flags contains flags,
      as given by the following masks:
	<ul>
	<li> 0x1: Base class is virtual
	<li> 0x2: Base class is public
	</ul>

  </ul>

<p>
Note that the resulting structure is variable-length,
with the actual size depending on the number of trailing base class
descriptions.

</ol>

<p>
<li>
The abi::__pointer_to_member_type_info type adds two fields to std::type_info:
<ul>
<li> a pointer to a abi::__class_type_info (e.g., the "A" in "int A::*")
<li> a pointer to a std::type_info corresponding to the member type
    (e.g., the "int" in "int A::*")
<li> a word describing the cv-qualification of what is pointed to
    (see abi::__pointer_type_info)
</ul>

</ol>

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
Note that this ABI requires elsewhere that a vtable be emitted for a
dynamic type in the object where the first non-inline virtual function
member is defined, if any, or everywhere referenced if none.
Therefore, an implementation should include at least one
non-inline virtual function member and define it in the library,
to avoid having user code inadvertently preempt the vtable.
Since the Standard requires a virtual destructor,
and it will rarely be called,
it is a good candidate for this role.
</i>


<h5>std::type_info::name()</h5>
<p>
The null-terminated byte string returned by this routine is
the mangled name of the type.


<p>
<h5>The dynamic_cast algorithm</h5>

<p>
Dynamic casts to "void cv*" are inserted inline at compile time.
So are dynamic casts of null pointers and dynamic casts that are really
static.

<p>
This leaves the following test to be implemented in the run-time
library for truly dynamic casts of the form "dynamic_cast&lt;T>(v)":
(see [expr.dynamic_cast] 5.2.7/8)

<ul>
<p>
<li>
If, in the most derived object pointed (referred) to by v, v points
(refers) to a public base class sub-object of a T object
[note: this can be checked at compile time],
and if only one object of type T is derived
from the sub-object pointed (referred) to by v,
the result is a pointer (an lvalue referring) to that T object.

<p>
<li>
Otherwise, if v points (refers) to a public base class sub-object
of the most derived object,
and the type of the most derived object has an
unambiguous public base class of type T,
the result is a pointer
(an lvalue referring)
to the T sub-object of the most derived object. 

<p>
<li>
Otherwise, the run-time check fails.
</ul>

<p>
The first check corresponds to a "base-to-derived cast" and the second
to a "cross cast".
These tests are implemented by abi::__dynamic_cast:

<pre><code>
   void* abi::__dynamic_cast ( const void *sub,
			       const abi::__class_type_info *src,
			       const abi::__class_type_info *dst,
			       std::ptrdiff_t src2dst_offset);
   /* sub: source address to be adjusted; nonnull, and since the
    *      source object is polymoprhic, *(void**)sub is a vptr.
    * src: static type of the source object.
    * dst: destination type (the "T" in "dynamic_cast&lt;T>(v)").
    * obj2sub_offset: a static hint about the location of the
    *    source subobject with respect to the complete object;
    *    special negative values are:
    *       -1: no hint
    *       -2: src is not a public base of dst
    *       -3: src is a multiple public base type but never a
    *           virtual base type
    *    otherwise, the src type is a unique public nonvirtual
    *    base type of dst at offset obj2sub_offset from the
    *    origin of dst.
    */

</pre></code>

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>
Rationale: 
<ul>
<p>
<li> A simple dynamic_cast algorithm that is efficient in the common
    case of base-to-most-derived cast case is preferable to more
    sophisticated ideas that handle deep-base-to-in-between-derived
    casts more efficiently at a slight cost to the common case.
    Hence, an earlier scheme of providing a hash-table into the
    list of base classes
    (as is done e.g. in the HP aC++ compiler)
    was dropped.
<p>
<li> For similar reasons,
    we only keep direct base information about a class type.
    Indirect base information can be found by chasing type_info pointers
    (and care should be taken to determine ambiguous base class types).
<p>
<li> The GNU egcs development team has implemented an idea of this ABI
    group to accelerate dynamic_cast operations by a-posteriori
    checking a "likely outcome".
    This is the purpose of the src2dst_offset hint.
    An implementation is free to always pass -1 (no hint),
    or to always ignore the hint in __dynamic_cast.
</ul>
</i>

<p>
<h5>The exception handler matching algorithm</h5>

<p>
Since the RTTI related exception handling routines are "personality specific",
no interfaces need to be specified in this document
(beyond the layout of the RTTI data).


<p> <hr> <p>
<a name=mangling>
<h3> External Names (a.k.a. Mangling) </h3>

<font color=red>
This section is still a proposal.
</font>

<p>
This section specifies the <i>mangling</i>, i.e. encoding,
of external names
(external in the sense of being visible outside the object file where
they occur).
The encoding is formalized as a derivation grammar along with the
explanatory text,
in a modified BNF with the following conventions:
<ul>
<li> Non-terminals are delimited by diamond braces: "&lt;>".
<li> Italics in non-terminals are modifiers to be ignored,
     e.g. &lt;<i>function</i> name> is the same as &lt;name>.
<li> Spaces are to be ignored.
<li> Text beginning with '#' is comments, to be ignored.
<li> Tokens in square brackets "[]" are optional.
<li> Tokens are placed in parentheses "()" for grouping purposes.
<li> '*' repeats the preceding item 0 or more times.
<li> '+' repeats the preceding item 1 or more times.
<li> All other characters are terminals, representing themselves.
</ul>

<p>
See the separate <a href=abi-mangling.html>table</a>
summarizing the encoding characters used as terminals.

<p>
In the various explanatory examples,
we use <code>Ret?</code> for an unknown function return type
(i.e. that is not given by the mangling),
or <code>Type?</code> for an unknown data type.

<p>
<h4> Loose Ends </h4>

<p>
<ul>
<li> Mangling of special entities: helper variables for thread protection, ...
<font color=red>
<li> Qualifier for extern "C" function types.
<li> Mangling local names for RTTI matching.
<li> Clarify substitution dictionary contents.
</font>
<li> Complete glossary of Sx abbreviations.
<li> Proof of nonambiguity
<li> ILP-32 conventions?
<li> Revise examples.
</ul>

<p>
<h4> General structure </h4>

<p>
Entities with C linkage and global namespace variables are not mangled.
Mangled names have the general structure:
<pre><font color=blue><code>
    &lt;mangled-name> ::= _Z &lt;encoding>
<font color=red>
    &lt;encoding> ::= &lt;name> [&lt;encoding-type>]
		# See <a href=#mangling-type>Type Encodings</a> below
    &lt;encoding-type> ::= &lt;type>
		    ::= &lt;bare-function-type>
		    ::= &lt;substitution> # See <a href=#mangling-compression>Compression</a> below
</font>
</pre></font></code>

<font color=red>
Thus, a name is mangled by prefixing "_Z" to an encoding of its name,
and in some cases its type.
At this top level,
function types do not have the delimiters required when nested
(see below).
</font>

<pre><font color=blue><code>
<font color=red>
    &lt;name> ::= &lt;nested-name>
	   ::= &lt;unqualified-name>
	   ::= &lt;local-name>	# See <a href=#mangling-scope>Scope Encoding</a> below
	   ::= &lt;substitution> # See <a href=#mangling-compression>Compression</a> below
</pre></font></code>

<font color=red>
Names of objects nested in namespaces or classes are identified as a
delimited sequence of names identifying the enclosing scopes.
For compression purposes
(discussed <a href=#mangling-compression>below</a>),
only a prefix of this nesting can be substituted.
In addition, when naming a class member function,
CV-qualifiers may be prefixed to the compound name,
encoding the <code>this</code> attributes.
Note that if member function CV-qualifiers are required,
the delimited form must be used even if the remainder of the name is
a single substitution.
</font>

<pre><font color=blue><code>
<font color=red>
    &lt;nested-name> ::= N &lt;qualified-name> E
    &lt;qualified-name> ::= &lt;CV-qualifier> &lt;qualified-name>
		     ::= &lt;compound-name>
		     ::= &lt;substitution>
    &lt;compound-name> ::= &lt;nesting-prefix> &lt;unqualified-name>
		   ::= &lt;unqualified-name>
		   ::= &lt;substitution>
    &lt;nesting-prefix> ::= &lt;nesting-prefix> &lt;nesting-qualifier>
		     ::= &lt;nesting-qualifier>
		     ::= &lt;substitution>
    &lt;nesting-qualifier> ::= &lt;<i>namespace</i> source-name>
			::= &lt;class-enum-name>
</font>

    &lt;unqualified-name> ::= &lt;<i>function</i> source-name>
		       ::= &lt;<i>function</i> source-name> &lt;template-args>
		       ::= &lt;operator-name>
		       ::= &lt;operator-name> &lt;template-args>
		       ::= &lt;special-name> # ctors, vtables, ...

    &lt;source-name> ::= &lt;<i>length</i> number> &lt;identifier>
    &lt;number> ::= &lt;<i>decimal integer</i>>
    &lt;identifier> ::= &lt;<i>unqualified source code identifier</i>>
</pre></font></code>

<p>
&lt;number> is a pseudo-terminal representing a decimal integer,
giving the character length of the following identifier.
&lt;number>s appearing in mangled names never have leading zeroes,
except for the value zero, represented as '0'.
&lt;identifier> is a pseudo-terminal representing the unqualified
identifier for the entity in the source code.

<p>
&lt;type> is used to disambiguate overloaded functions,
but also to distinguish the various virtual tables associated
with a given complete class type.
&lt;type> is omitted for variables and static data members.

<p>
<a name=mangling-operator>
<h4> Operator Encodings </h4>

<p>
Operators appear as function names,
and in nontype template argument expressions.
Unlike Cfront,
unary and binary operators using the same symbol have different encodings.
All operators are encoded using exactly two letters,
the first of which is lowercase.

<pre><font color=blue><code>
  &lt;operator-name> ::= nw	# new           
		  ::= na	# new[]
		  ::= dl	# delete        
		  ::= da	# delete[]      
		  ::= ng	# - (unary)     
		  ::= ad	# & (unary)     
		  ::= de	# * (unary)     
		  ::= co	# ~             
		  ::= pl	# +             
		  ::= mi	# -             
		  ::= ml	# *             
		  ::= dv	# /             
		  ::= rm	# %             
		  ::= an	# &             
		  ::= or	# |             
		  ::= eo	# ^             
		  ::= aS	# =             
		  ::= pL	# +=            
		  ::= mI	# -=            
		  ::= mL	# *=            
		  ::= dV	# /=            
		  ::= rM	# %=            
		  ::= aN	# &=            
		  ::= oR	# |=            
		  ::= eO	# ^=            
		  ::= ls	# <<            
		  ::= rs	# >>            
		  ::= lS	# <<=           
		  ::= rS	# >>=           
		  ::= eq	# ==            
		  ::= ne	# !=            
		  ::= lt	# <             
		  ::= gt	# >             
		  ::= le	# <=            
		  ::= ge	# >=            
		  ::= nt	# !             
		  ::= aa	# &&            
		  ::= oo	# ||            
		  ::= pp	# ++            
		  ::= mm	# --            
		  ::= cm	# ,             
		  ::= pm	# ->*           
		  ::= pt	# ->            
		  ::= cl	# ()            
		  ::= ix	# []            
		  ::= qu	# ?             
		  ::= cv	# (cast)        
		  ::= sz	# sizeof        
		  ::= vx &lt;source-name>	# vendor extended operator

</pre></font></code>

<p>
Vendors who define builtin extended operators (e.g. __alignof)
shall encode them as a 'vx' prefix followed by the name in &lt;length,ID> form.


<p>
<a name=mangling-special>
<h4> Other Special Functions and Entities </h4>
<pre><font color=blue><code>
  &lt;special-name> ::= TV	# virtual table
			# &lt;type> is vtable's class type
		 ::= TT	# VTT structure (construction vtable index)
			# &lt;type> is VTT's class type
		 ::= TI	# typeinfo structure
			# &lt;type> is typeinfo's class type
		 ::= TD	# typeinfo common proxy
			# &lt;type> is typeinfo's class type
<font color=red>
		 ::= Th[n] &lt;<i>offset</i> number> _ &lt;<i>base</i> name> &lt;<i>base</i> function-type>
			# non-virtual base override thunk
			# <i>base</i> is the nominal target function of thunk
			# No &lt;type> other than base function's
		 ::= Tv &lt;<i>vcall offset</i> number> _ &lt;<i>base</i> name> &lt;<i>base</i> function-type>&lt;<i>base class</i> type>
			# virtual base override thunk
			# <i>base</i> is the nominal target function of thunk
			# No &lt;type> other than base function's
</font>

		 ::= C1	# complete object (in-charge) constructor
			# for class &lt;type>
		 ::= C2	# base object (not-in-charge) constructor
			# for class &lt;type>
		 ::= C3	# complete object (in-charge) allocating constructor
			# for class &lt;type>
		 ::= C4	# base object (not-in-charge) allocating constructor
			# for class &lt;type>
		 ::= D0	# deleting (in-charge) destructor
			# for class &lt;type>
		 ::= D1	# complete object (in-charge) destructor
			# for class &lt;type>
		 ::= D2	# base object (not-in-charge) destructor
			# for class &lt;type>

		 ::= GV &lt;<i>object</i> name>	# Guard variable for one-time initialization
			# No &lt;type>

</pre></font></code>

<p>
Virtual function override thunks come in two forms.
Those overriding from a non-virtual base,
with fixed <code>this</code> adjustments,
use a "Th" prefix and encode the required adjustment offset,
probably negative, indicated by a 'n' prefix,
and the encoding of the target function.
Those overriding from a virtual base,
with <code>this</code> adjustments obtained from a vcall offset,
use a "Tv" prefix and
encode the absolute value of the offset in the vtable of the vcall offset,
the encoding of the target function,
and the type of the base class declaring the overridden function.
The target function encodings of both incorporate the function type;
no additional type is encoded for the thunk itself.


<p>
<a name=mangling-type>
<h4> Type encodings </h4>

<p>
Types are encoded as follows:

<pre><font color=blue><code>
  &lt;type> ::= &lt;builtin-type>
	 ::= &lt;function-type>
	 ::= &lt;class-enum-type>
	 ::= &lt;array-type>
	 ::= &lt;pointer-to-member-type>
	 ::= &lt;template-param>

</pre></font></code>

<p>
Types are qualified (optionally) by single-character prefixes encoding
cv-qualifiers and/or pointer, reference, complex, or imaginary types:

<pre><font color=blue><code>
<font color=red>
  &lt;type> ::= &lt;CV-qualifier>
</font>
	 ::= P &lt;type>	# pointer-to
	 ::= R &lt;type>	# reference-to
	 ::= C &lt;type>	# complex pair (C 2000)
	 ::= G &lt;type>	# imaginary (C 2000)
<font color=red>
	 ::= U &lt;source-name> &lt;type>	# vendor extended type qualifier
</font>
<font color=red>
  &lt;CV-qualifier> ::= K &lt;type>	# const
		 ::= V &lt;type>	# volatile
		 ::= r &lt;type>	# restrict (C 2000)
</font>

</pre></font></code>

<p>
<font color=red>
Vendors who define extended type qualifiers (e.g. near, far for pointers)
shall encode them as a 'U' prefix followed by the name in &lt;length,ID> form.
</font>

<a name=mangling-builtin>
<p>
Builtin types are represented by single-letter codes:

<pre><font color=blue><code>
  &lt;builtin-type> ::= v	# void
		 ::= w	# wchar_t
		 ::= b	# bool
		 ::= c	# char
		 ::= a	# signed char
		 ::= h	# unsigned char
		 ::= s	# short
		 ::= t	# unsigned short
		 ::= i	# int
		 ::= j	# unsigned int
		 ::= l	# long
		 ::= m	# unsigned long
		 ::= x	# long long, __int64
		 ::= y	# unsigned long long, __int64
		 ::= n	# __int128
		 ::= o	# unsigned __int128
		 ::= f	# float
		 ::= d	# double
		 ::= e	# long double, __float80
		 ::= g	# __float128
		 ::= z	# ellipsis
		 ::= u &lt;source-name>	# vendor extended type

</pre></font></code>

<p>
Note that the encodings of __int64 and __float80 are based on the
assumption that the base psABI will treat them as typedefs,
which is not yet confirmed.

<p>
Vendors who define builtin extended types shall encode them
as a 'u' prefix followed by the name in &lt;length,ID> form.

<p>
<font color=red>
Function types are composed from their parameter types and possibly the
result type.
Except at the outer level type of an &lt;encoding-type>,
or in the &lt;encoding> of an otherwise delimited external name
&lt;template-parameter> or &lt;local-name> function encoding,
these types are delimited by an "F..E" pair.
For purposes of substitution
(see <a href=#mangling-compression>Compression</a> below),
delimited and undelimited function types are considered the same.
</font>

<p>
The type of nontemplate function objects
(e.g. the &lt;type> in function name manglings,
or the target function type in thunk manglings)
includes only the parameter types.
For template functions,
or for function type specifications such as function parameters,
&lt;type> includes the return type followed by the parameter types.
Empty parameter lists declared conventionally as <code>(void)</code>
are not encoded with a void parameter specifier (v).
Member functions do not encode the full type of their <code>this</code>
parameter.
<font color=red>
A "Y" prefix for the bare function type encodes extern "C".
If there are any cv-qualifiers of <code>this</code>,
they are encoded at the beginning of the &lt;qualified-name>
as described above.
</font>

<pre><font color=blue><code>
<font color=red>
  &lt;function-type> ::= F &lt;bare-function-type>* E
  &lt;bare-function-type> ::= [Y] &lt;<i>param</i> type>*
</font>

</pre></font></code>

<p>
Simple class and enum types are encoded with the length of their source
code identifier, followed by the identifier.
Class names can optionally be followed by the encoding of a template
argument list.
Nested class names are preceded by the nesting qualifiers
(namespace or class names), all enclosed in N/E brackets.
<font color=red>
Thus, the class type encoding is the same as function name encoding,
except that no CV-qualifiers are present in a nested name specification.
</font>

<pre><font color=blue><code>
<font color=red>
  &lt;class-enum-type> ::= &lt;nested-name>
		    ::= &lt;class-enum-name>
  &lt;class-enum-name> ::= &lt;<i>class-enum</i> source-name>
		    ::= &lt;<i>class-enum</i> source-name>  &lt;template-args>
</font>
</pre></font></code>

<p>
<font color=red>
Array types encode the dimension (number of elements) and the element type.
Note that "array" parameters to functions are encoded as pointer types.
For variable length arrays,
the dimension (but not the '_' separator) is omitted.
</font>

<pre><font color=blue><code>
<font color=red>
  &lt;array-type> ::= A [&lt;<i>dimension</i> number>] _ &lt;<i>element</i> type>
</font>

</pre></font></code>

<p>
Pointer-to-member types encode the class and member types.

<pre><font color=blue><code>
  &lt;pointer-to-member-type> ::= M &lt;<i>class</i> type> &lt;<i>member</i> type>

</pre></font></code>

<p>
Template parameters (including nontype and template template parameters)
encode the parameter number.
Objects appearing within multiple levels of template number the
<font color=red>
top-level parameters 1..n, the next level n+1..n+m, etc.
</font>

<pre><font color=blue><code>
  &lt;template-param> ::= T &lt;<i>parameter</i> number> _

</pre></font></code>

<p>
Template argument lists appear after the unqualified template name,
and are bracketed by I/E.
This is used for name specializations in particular,
but also in types and scope identification.

<pre><font color=blue><code>
  &lt;template-args> ::= I &lt;template-arg>+ E
  &lt;template-arg> ::= &lt;type>			# type
  &lt;template-arg> ::= L &lt;type> &lt;<i>value</i> number> E	# literal
  &lt;template-arg> ::= LZ &lt;encoding> E		# external name
  &lt;template-arg> ::= X &lt;expression> E		# expression

</pre></font></code>

<p>
Type arguments appear using their regular encoding.
For example, the template class "A&lt;char, float>" is encoded as "1AIcfE".
A slightly more involved example is
a dependent function parameter type "A&lt;T2>::X"
(T2 is the second template parameter)
which is encoded as "N1AIT2_E1XE",
where the "N...E" construct is used to describe a qualified name.

<p>
Literal arguments, e.g. "A&lt;42L>",
are encoded with their type and value.
Negative integer values are preceded with "n";
for example, "A&lt;-42L>" becomes "1AILln42EE".
The bool value false is encoded as 0, true as 1.
If floating-point arguments are accepted as an extension,
their values should be encoded using a fixed-length lowercase hexadecimal
string corresponding to the internal representation (IEEE on IA-64),
high-order bytes first, without leading zeroes.
For example: "Lfbff000000E" is -1.0f.

<p>
A reference to an entity with external linkage is encoded with
"L&lt;mangled name>E".
For example:
<code><pre>
          void foo(char); // mangled as _Z3fooc
          template&lt;void (&)(char)> struct CB;
          // CB&lt;foo> is mangled as "2CBIL_Z3foocEE"
</pre></code>

<p>
An expression, e.g., "B&lt;(J+1)/2>",
is encoded with a prefix traversal of the operators involved,
delimited by "X...E".
The operators are encoded using their two letter mangled names.
For example, "B&lt;(J+1)/2>", if J is template parameter 1,
becomes "1BI Xdv pl T1_ Li1E Li2E E E"
(the blanks are present only to visualize the decomposition).

<pre><font color=blue><code>
  &lt;expression> ::= &lt;<i>unary</i> operator-name> &lt;expression>
	       ::= &lt;<i>binary</i> operator-name> &lt;expression> &lt;expression>
	       ::= &lt;expr-primary>
  &lt;expr-primary> ::= &lt;template-param>
		 ::= L &lt;type> &lt;<i>value</i> number> E	# literal
		 ::= L &lt;mangled-name> E		# external name

</pre></font></code>


<p>
<a name=mangling-scope>
<h4> Scope Encoding </h4>

<p>
A nonlocal scope is encoded as the qualifier of a qualified name:
it can be the top-level name qualification or it can appear inside
&lt;type> to denote dependent types or bind specific names as arguments.
Qualified names are encoded as:
<code><pre>
   N &lt;qual 1> ... &lt;qual N> &lt;unqual name> E
</pre></code>
where each &lt;qual K> is the encoding of a namespace name or a class name
(with the latter possibly including a template argument list).

<p>
Occasionally entities in local scopes must be mangled too
(e..g., because inlining or separate template compilation causes
multiple translation units to require access to that entity).
Local entities that might be mangled are
numbered in lexical order starting with "1".
The numbered entities are:
<ul>
<li> local static variables
<li> local class types
<li> string literals
</ul>

<p>
The local name encoding is then:
<pre><font color=blue><code>
   &lt;local-name> = Z &lt;<i>function</i> encoding> E &lt;number> _ &lt;<i>entity</i> name>

</pre></font></code>

where &lt;entity-name> is either the entity's unqualified name
or "0" (zero) if it is a string literal.

<p>
Example:
<code><pre>
   namespace N {
      inline char* f(int i) {
         static char *p = "IA-64 C++ ABI";  // p = 1, "..." = 2
         {  struct X {                      // X = 3
               void g() {}
            };   }
         return p[i];
      }
   }
</pre></code>

<ul>
<li> "<code>_ZZN1N1fEiE1_1p</code>":
    encoding of N::f:p (first local mangled entity)
<li> "<code>_ZZN1N1fEiE2_0</code>":
    encoding of N::f:"IA-64 C++ ABI"
<li> "<code>_ZNZN1N1fEiE3_1X1gE</code>":
    encoding of N::f:X::g()
    (third local mangled entity used as a class-qualifier)
</ul>



<p>
<a name=mangling-compression>
<h4> Compression </h4>
<font color=red>

<p>
To minimize the length of external names,
we use two mechanisms,
a substitution encoding to eliminate repetition of name components,
and abbreviations for certain common names.
Each non-terminal in the grammar above for which &lt;substitution>
appears on the RHS,
types, names, and qualified name prefixes,
is both a source of future substitutions
and a candidate for being substituted.

<p>
Logically, the substitutable components of a mangled name are
considered in the order they would be identified when interpreting the
mangled name in the above grammar,
that is left-to-right, a larger structure before its components.
If a components has been encountered before,
it is substituted as described below and added to a list
of substitutable components that have been encountered so far.
If not, its components are considered,
and it is added to the list after they have been processed.
Thus, large structures are considered for substition before their components,
but are added to the list after their components.

<p>
Substitution is according to the production:

<pre><font color=blue><code>
  &lt;substitution> ::= S &lt;number> _

</pre></font></code>

The &lt;number> identifies the number-th most recently encoded component,
(in right-to-left order, starting at "1").
All substitutable components are so numbered,
including those that have been substituted already,
but the substitution occurs only if "S&lt;number>_"
is strictly shorter than the unsubstituted encoding.
A component is less recent than the structure of which it is a part.
For example:

<code><pre>
   "_ZN1N1TIiiE2mfES5_IddE": Ret? N::T&lt;int, int>::mf(N::T&lt;double, double>)
</pre></code>

since at the point where S5_ appears:
<code><pre>
   "S1_" == N::T&lt;int, int>::mf
   "S2_" == N::T&lt;int, int>
   "S3_" == int
   "S4_" == int
   "S5_" == N::T (template is less recent than template-id)
   "S6_" == N (qualifier is less recent than qualified entity)
</pre></code>

<p>
Note that substitutable components are the represented symbolic constructs,
not their associated mangling character strings.
Thus, a substituted object matches its unsubstituted form,
and a delimited &lt;function-type> matches its &lt;bare-function-type>.

<p>
In addition,
the following catalog of abbreviations of the form "Sx" are used:
<pre><font color=blue><code>
   &lt;substitution> ::= St # ::std::
   &lt;substitution> ::= Sb # ::std::basic_string
   &lt;substitution> ::= Ss # ::std::basic_string &lt; char,
						 ::std::char_traits&lt;char>,
						 ::std::allocator&lt;char> >
   &lt;substitution> ::= Si # ::std::basic_istream&lt;char,  std::char_traits&lt;char> >
   &lt;substitution> ::= So # ::std::basic_ostream&lt;char,  std::char_traits&lt;char> >
   &lt;substitution> ::= Sd # ::std::basic_iostream&lt;char, std::char_traits&lt;char> >

</pre></font></code>

<p>
The abbreviation St is always an initial qualifier,
i.e. appearing as the first element of a compound name.
It does not require N...E delimiters unless
either followed by more than one additional composite name component,
or preceded by CV-qualifiers for a member function.
This adds the case:
<pre><font color=blue><code>
   &lt;name> ::= St &lt;unqualified-name> # ::std::

</pre></font></code>

For example:
<code><pre>
   "_ZSt5state": ::std::state
   "_ZNSt3_In4wardE": ::std::_In::ward
</pre></code>

</font>


<p>
<a name=mangling-examples>
<h4> Examples </h4>

<table border=1 cellpadding=4>
<tr><th> Mangled name <br><i>(ignore spaces)</i> </th>
<th> Source name </th> </tr>

<tr class=small><td> f </td>
<td> C function or variable "f" or a global namespace variable "f"</td></tr>

<tr class=small><td> _Z1f </td>
<td> Ret? f(); <i>or</i> Ret? f(void); </td></tr>

<tr class=small><td> _Z1fi </td>
<td> Ret? f(int); </td></tr>

<tr class=small><td> _Z3foo3bar </td>
<td> Ret? foo(bar); </td></tr>

<tr class=small><td> _Zrm1X1X </td>
<td> Ret? operator%(X, X); </td></tr>

<tr class=small><td> _ZplR1XR1X </td>
<td> Ret? operator+(X&, X&); </td></tr>

<tr class=small><td> _ZlsRK1XS1_ </td>
<td> Ret? operator(X const&, X const&);
<br> (Note: strlen("S1_")&lt;strlen("RK1X")) </td></tr>

<tr class=small><td> _Z1fIiEvi </td>
<td> void f&lt;int>(/*nondependent*/int);
<br> (Note: the return type is always explicitly encoded for template
functions taking parameters.)</td></tr>

<tr class=small><td> _Z5firstI3DuoEvS2_ </td>
<td> void first&lt;Duo>(/*nondependent*/Duo);
<br>(Note: "S1_" would refer to the "void" return type.) </td></tr>

<tr class=small><td> _Z5firstI3DuoEvT1_ </td>
<td> void first&lt;Duo>(/*T1=*/Duo); </td></tr>

<tr class=small><td> _ZN1N1fE </td>
<td> Ret? N::f(); </td></tr>

<tr class=small><td> _ZN6System5Sound4beepE </td>
<td> Ret? System::Sound::beep(); </td></tr>

<tr class=small><td> _ZN5Arena5levelE </td>
<td> Type? Arena::level; </td></tr>

<tr class=small><td> _ZN5StackIiiE5levelE </td>
<td> Type? Stack&lt;int, int>::level; </td></tr>

<tr class=small><td> _Z1fI1XE vPV N1AIT1_E1T </td>
<td> void f&lt;X>(A&lt;/*T1=*/X>::T volatile*); </td></tr>

<tr class=small><td> _ZngILi42EE vN1AIXplT1_Li2EE1TE </td>
<td> void operator-&lt;/*int J=*/42>(A&lt;J+2>::T); </td></tr>

<tr class=small><td> _Z4makeI7FactoryiE T1_IT2_E </td>
<td> /*T1=*/Factory&lt;/*T2=*/int> make&lt;Factory, int>();
<br> // T1 == template template parameter </td></tr>

<tr class=small><td> _Z3foo 5Hello5WorldS1_S3_ </td>
<td> void foo(Hello,World,World,Hello)
<br> // S1_ counts as a type in numbering </td></tr>

<tr class=small><td> _Z3fooPM2ABi </td>
<td> foo(int AB::**)
<br> // M is a pointer, P adds another level </td></tr>

</table>


<p>
<hr>

<p> <hr> <p>
<a name=revisions>
<h3> Revision History </h3>

<p>
<font color=blue>[000228]</font>
Add thunk definition.
Revise inheritance graph order definition.
Fix member function pointer description (no division by two).
Move bitfield allocation description (much modified)
to the non-virtual-base allocation description.
Replace virtual function calling convention description.

<p>
<font color=blue>[000217]</font>
Add excess-size bitfield specification.
Add namespace/header section.
Touch up array new cookies.
Remove construction vtable example to new file.
Add mangling proposal.

<p>
<font color=blue>[000214]</font>
Complete array new cookie specification.
Remove unnecessary RTTI flags.
Correct repeated inheritance flag description.
Move all type_info subclasses in namespace abi, not namespace std.
Note requirements for an implementation to prevent users from emitting
invalid vtables for RTTI classes.
Include construction vtable proposal.

<p>
<font color=blue>[000203]</font>
Incorporate discussion of 3 Febrary.
Remove __reference_type_info (issue A-22).
Restructure struct RTTI and flags (issue A-23).
Clarify __base_class_info layout.

<p>
<font color=blue>[000125]</font>
Incorporate discussion of 20 January, generally clarifications.
Resolved A-19 (choice of a primary virtual base).
Answered Nathan's questions about RTTI.
Included RTTI "Deliberations" as rationale notes in the specification,
or removed redundant ones.
Added array operator new section.

<p>
<font color=blue>[000119]</font>
Clarify when virtual base offsets are required.
Note that a vtable has offset-to-top and RTTr entries for classes with
virtual bases even if there are no virtual functions.
Resolve allocation of a virtual base class that is a primary base for
another base (A-17).
Resolve choice of a primary virtual base class that is a primary base for
another base (A-19).
Describe the (non-)effect of virtual bases on the alignment of the
non-virtual part of a class as the base of another class (A-18).

<p>
<font color=blue>[991230]</font>
Integrate proposed resolution of A-16, A-17 in base class layout.
Add outstanding questions list, and clean up questions in text.

<p>
<font color=blue>[991229]</font>
Clarify definition of nearly empty class, layout of virtual bases.

<p>
<font color=blue>[991203]</font>
Added description of vfunc calling convention from Jason.

<p>
<font color=blue>[991104]</font>
Noted pair of vtable entries for virtual destructors.

<p>
<font color=blue>[991019]</font>
Modified RTTI proposal for 14 October decisions.

<p>
<font color=blue>[991006]</font>
Added RTTI proposal.

<p>
<font color=blue>[990930]</font>
Updated to new vtable layout proposal.

<p>
<font color=blue>[990811]</font>
Described member pointer representations, virtual table layout.

<p>
<font color=blue>[990730]</font>
Selected first variant for empty base allocation; removed others.

<p>
<hr>

<p>
Please send corrections to <a href=mailto:dehnert@sgi.com>Jim Dehnert</a>.

</BODY>
</HTML>
