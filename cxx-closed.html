<HTML>

<HEAD>
<title>C++ ABI Closed Issues</title>

<link rel=stylesheet href=small-table.css type="text/css">
<link rel=stylesheet href=code.css type="text/css">

<hr>

<font size=6><i><b>
<p>
C++ ABI Closed Issues
</b></i></font>

<font size=-1>
<p>
<i>Revised 20 December 1999</i>

</center>

</HEAD>

<BODY>

<p> <hr> <p>
<h3> Issue Status </h3>

In the following sections,
the <b><i>class</i></b> of an issue attempts to classify it on the
basis of what it likely affects.
The identifiers used are:

<table>
<tr> <td> call </td>
<td> Function call interface, i.e. call linkage </td>
</tr>

<tr> <td> data </td>
<td> Data layout </td>
</tr>

<tr> <td> lib </td>
<td> Runtime library support </td>
</tr>

<tr> <td> lif </td>
<td> Library interface, i.e. API </td>
</tr>

<tr> <td> g </td>
<td> Potential gABI impact </td>
</tr>

<tr> <td> ps </td>
<td> Potential psABI impact </td>
</tr>

<tr> <td> source </td>
<td> Source code conventions (i.e. API, not ABI) </td>
</tr>

<tr> <td> tools </td>
<td> May affect how program construction tools interact </td>
</tr>
</table>

<p> <hr> <p>
<h3> A.  Object Layout Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-1 </td>
<td> Vptr location </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where is the Vptr stored in an object (first or last are the usual answers).
</td> </tr>

</table>

<p>
<font color=blue>[990610 All]</font>
Given the absence of addressing modes with displacements on IA-64,
the consensus is to answer this question with "first."

<p>
<font color=blue>[990617 All]</font>
Given a Vptr and only non-polymorphic bases,
which (Vptr or base) goes at offset 0?
<ul>
<li> HP: Vptr at end, but IA-64 is different because no load displacement
<li> Sun: Vptr at 0 probably preferred
<li> g++: Vptr at end today
</ul>
<p>
Tentative decision:  Vptr always goes at beginning.

<p>
<font color=blue>[990624 All]</font>
Accepted tentative decision.
Rename, close this issue, and open separate issue (B-6) for Vtable layout.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-2 </td>
<td> Virtual base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where are the virtual base subobjects placed in the class layout?
How are data member accesses to them handled?
</td> </tr>

</table>

<p>
<font color=blue>[990610 Matt]</font>
With regard to how data member accesses are handled,
the choices are to store either a pointer or an offset in the Vtable.
The concensus seems to be to prefer an offset.

<p>
<font color=blue>[990617 All]</font>
Any number of empty virtual base subobjects (rare) will be placed at
offset zero.
If there are no non-virtual polymorphic bases,
the first virtual base subobject with a Vpointer will be placed at
offset zero.
Finally, all other virtual base subobjects will be allocated at the
end of the class, left-to-right, depth-first.

<p>
<font color=blue>[990624 All]</font>
Define an empty object as one with no non-static, non-empty data members,
no virtual functions,
no virtual base classes,
and no non-empty non-virtual base classes.
Define a nearly empty object as one which contains only a Vptr.
The above resolution is accepted, restated as follows:

<p>
Any number of empty virtual base subobjects
(rare, because they cannot have virtual functions or bases themselves)
will be placed at offset zero, subject to the conflict rules in A-3
(i.e. this cannot result in two objects of the same type at the same
address).
If there are no non-virtual polymorphic base subobjects,
the first nearly empty virtual base subobject will be placed at offset zero.
Any virtual base subobjects not thus placed at offset zero will be
allocated at the end of the class,
in left-to-right, depth-first declaration order.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-3 </td>
<td> Multiple inheritance </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990701 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the class layout in the presence of multiple base classes.
</td> </tr>

</table>

<p>
<font color=blue>[990617 All]</font>
At offset zero is the Vptr whenever there is one,
as well as the primary base class if any (see A-7).
Also at offset zero is any number of empty base classes,
as long as that does not place multiple subobjects of the same type at
the same offset.
If there are multiple empty base classes such that placing two of them
at offset zero would violate this constraint, the first is placed there.
(First means in declaration order.)

<p>
All other non-virtual base classes are laid out in declaration order at
the beginning of the class.
All other virtual base subobjects will be allocated at the
end of the class, left-to-right, depth-first.

<p>
The above ignores issues of padding for alignment,
and possible reordering of class members to fit in padding areas.
See issue A-9.

<p>
<font color=blue>[990624 All]</font>
There remains an issue concerning the selection of the primary base
class (see A-7), but we are otherwise in agreement.
We will attempt to close this on 1 July, modulo A-7.

<p>
<font color=blue>[990701 All]</font>
This issue is closed.
A full description of the class layout can be found in issue A-9.
(At this time, A-7 remains to be closed,
waiting for the Taligent rationale.)

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-4 </td>
<td> Empty base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where are empty base classes allocated?
(An empty base class is one with no non-static data members,
no virtual functions, no virtual base classes,
and no non-empty non-virtual base classes.)
</td> </tr>

</table>

<p>
<font color=blue>[990624 All]</font>
Closed as a duplicate of A-3.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-5 </td>
<td> Empty parameters </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990701 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
When passing a parameter with an empty class type by value,
what is the convention?
</td> </tr>

</table>

<p>
<font color=blue>[990623 SGI]</font>
We propose that no parameter slot be allocated to such parameters,
i.e. that no register be used,
and that no space in the parameter memory sequence be used.
This implies that the callee must allocate storage at a unique address
if the address is taken (which we expect to be rare).

<p>
<font color=blue>[990624 All]</font>
In addition to the address-taken case,
care is required if the object has a non-trivial copy constructor.
HP observes that in (some?) such cases,
they perform the construction at the call site and pass the object by
reference.

<p>
<font color=blue>[990625 SGI -- Jim]</font>
I understand that the Standard explicitly allows elimination of
even non-trivial copy construction in some cases.
Is this one of them?  Where should I look?
Also, of course, varargs processing for elided empty parameters would
need to be careful.

<p>
I have opened a new issue (C-7) for passing copy-constructed
parameters by reference.
Since doing so would turn an empty value parameter
into a non-empty reference parameter,
this issue can ignore such cases.

<p>
<font color=blue>[990701 All]</font>
An empty parameter will not occupy a slot in the parameter sequence
unless:
<ol>
<li> its type is a class with a non-trivial copy constructor; or
<li> it corresponds to the variable part of a varargs parameter list.
</ol>

<p>
Daveed and Matt will pursue the question of when copy constructors may
be ignored for parameters with the Core committee,
and if they identify cases where the constructors may clearly be
omitted, those (empty) parameters will also be elided.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A6></a> <td> A-6 </td>
<td> RTTI .o representation </td>
<td> data call ps </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991028 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the data structure to be used for RTTI, that is:
<ul>
<li> for user <code>type_info</code> calls;
<li> for dynamic_cast implementation; and
<li> for exception-handling.
</ul>
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Defined in the
<a href=abi-layout.html#rtti>ABI data layout document</a>.
</tr>

</table>

<p>
<font color=blue>[990701 All]</font>
Daveed will put together a proposal by the 15th (action #13);
the group will discuss it on the 22nd.

<p>
<font color=blue>[990805 All]</font>
Daveed should have his proposal together for discussion.
Michael Lam will look into the Sun dynamic cast algorithm.

<p>
It was noted that appropriate name selection along with the normal
DSO global name resolution should be sufficient to produce a unique
address for each class' RTTI struct,
which address would then be a suitable identifier for comparisons.

<p>
<font color=blue>[990812 Sun -- Michael]</font>
Sun has provided a description,
<a href=Sun-RTTI-990812.html>in a separate page</a>,
describing their implementation.
They are filing for a patent on the algorithms described.

<p>
<font color=blue>[990819 EDG -- Daveed]</font>
(Proposal replaced by later version on 6 October.)

<p>
<font color=blue>[990826 All]</font>
Discussion centered on whether the representation should include all
base classes or just the direct ones,
and in the former case how hashing might be handled.
It was agreed that the __qualifier_type_info variant is not needed,
and it is now striken in the above proposal.
Also, a pointer-to-member variant is needed.
Christophe will provide a description of the HP hashing approach,
and Daveed will update the specification.

<p>
<font color=blue><hr><p>[991006 EDG -- Daveed]</font>

<p>
<h5>Run-time type information</h5>

<p>
The C++ programming language definition implies that information about
types be available at run time for three distinct purposes:
<ol type=a>
<li> to support the typeid operator,
<li> to match an exception handler with a thrown object, and
<li> to implement the dynamic_cast operator.
</ol>
(c) only requires type information about polymorphic class types,
but (a) and (b) may apply to other types as well;
for example, when a pointer to an int is thrown,
it can be caught by a handler that catches "int const*".


<p>
<h5>Deliberations</h5>
<p>
The following conclusions were arrived at by the attending members of
the C++ IA-64 ABI group:

<ul>
<p>
<li> The exact layout for type_info objects is dependent on whether a
    32-bit or 64-bit model is supported.
<p>
<li> Advantage should be taken of COMDAT sections and symbol preemption:
    two type_info pointers point to equivalent types if and only if the
    pointers are equal.
<p>
<li> A simple dynamic_cast algorithm that is efficient in the common
    case of base-to-most-derived cast case is preferrable over more
    sophisticated ideas that handle deep-base-to-in-between-derived
    casts more efficiently at a slight cost to the common case.
    Hence, the original scheme of providing a hash-table into the
    list of base classes
    (as is done e.g. in the HP aC++ compiler)
    has been dropped.
<p>
<li> The GNU egcs development team has implemented an idea of this ABI
    group to accelerate dynamic_cast operations by a-posteriori
    checking a "likely outcome".
    The interface of std::__dynamic_cast therefore keeps the
    src2dst_offset hint.
<p>
<li> std::__extended_type_info is dropped.
</ul>

<p>
The full proposal has been incorporated in the
<a href=abi-layout.html#rtti>ABI data layout document</a>.

<p>
<font color=blue><hr><p>[991014 all]</font>
<ol>
<p>
<li>
Do we keep pointers to direct bases only, or to indirect bases as well?
It is believed that keeping pointers to indirect bases speeds
up dynamic_cast by a constant factor,
but at the cost of extra space even when dynamic_cast is never used.
There is a general preference for keeping direct bases only.

<p>
<li>
The current proposal has a flag to differentiate single
inheritance from multiple inheritance case.
Jason suggests instead splitting the two cases into two separate classes,
and there was general agreement that this is a good idea.

<p>
<li>
The current proposal has separate classes for various kinds of
non-class types.
Jason suggests merging all non-class types into a single class.
Nobody had strong feelings,
or strong arguments either for or against this change.
In the absence of a consensus in favor of this change,
we'll keep the proposal as is.

<p>
<li>
Minor changes:
There's a typo in the pointer to member part, which Daveed will fix.
Jason suggests flipping the sign on the offset, and nobody objected.
</ol>

<p>
ACTION ITEMS: Daveed---make these changes.  Jim---incorporate these
changes into the open issues list.  We are almost ready to close this
issue; we intend to close it at the 28 October meeting, after we've
all had a change to go over the modified writeup.


<p>
<font color=blue><hr><p>[991028 all]</font>
The current definition,
in the <a href=abi-layout.html#rtti>ABI data layout document</a>,
has been updated with Daveed's changes,
and is accepted.
Note that we are back to using a pointer to RTTI in the vtable
(see B-8), since we need uniqueness,
and since we need an external symbol in any case,
the ABI will make no statement about where RTTI is allocated.
It is likely that implementations will use COMDAT for it.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A7></a> <td> A-7 </td>
<td> Vptr sharing with primary base class </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990729 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It is in general possible to share the virtual pointer with a
polymorphic base class (the <i>primary</i> base class).
Which base class do we use for this?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Share with the first non-virtual polymorphic base class,
or if none with the first nearly empty virtual base class.
</td> </tr>

</table>

<p>
<font color=blue>[990617 All]</font>
It will be shared with the first polymorphic non-virtual base class,
or if none, with the first nearly empty polymorphic virtual base class.
(See A-2 for the definition of <i>nearly empty</i>.)

<p>
<font color=blue>[990624 All]</font>
HP noted that Taligent chooses a base class with virtual bases before
one without as the primary base class),
probably to avoid additional "this" pointer adjustments.
SGI observed that such a rule would prevent users from controlling the
choice by their ordering of the base classes in the declaration.
The bias of the group remains the above resolution,
but HP will attempt to find the Taligent rationale before this is decided.

<p>
<font color=blue>[990729 All]</font>
Close with the agree resolution.
If a convincing Taligent rationale is found, we can reconsider.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-8 </td>
<td> (Virtual) base class alignment </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
A (virtual) base class may have a larger alignment constraint than a
derived class.
Do we agree to extend the alignment constraint to the derived class?
(An alternative for virtual bases:
allow the virtual base to move in the complete object.)
</td> </tr>

</table>

<p>
<font color=blue>[990623 SGI]</font>
We propose that the alignment of a class be the maximum alignment of
its virtual and non-virtual base classes,
non-static data members, and Vptr if any.

<p>
<font color=blue>[990624 All]</font>
Above proposal accepted.
(SGI observation:
the size of the class is rounded up to a multiple of this alignment,
per the underlying psABI rules.)

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> <a name=A9>A-9</a> </td>
<td> Sorting fields as allowed by [class.mem]/12 </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The standard constrains ordering of class members in memory only if
they are not separated by an access clause.
Do we use an access clause as an opportunity to fill the gaps left by padding?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
See separate writeup of <a href=abi-layout.html>Data Layout</a>.
</td> </tr>

</table>

<p>
<font color=blue>[990610 all]</font>
Some participants want to avoid attempts to reorder members differently
than the underlying C struct ABI rules.
Others think there may be benefit in reordering later access sections
to fill holes in earlier ones, or even in base classes.

<p>
<font color=blue>[990617 all]</font>
There are several potential reordering questions, more or less independent:
<ol>
<li> Do we reorder whole access regions relative to one another?
<li> Do we attempt to fill padding in earlier access regions with
	initial members from later regions?
<li> Do we fill the tail padding of non-POD base classes with members from
	the current class?
<li> Do we attempt to fill interior padding of non-POD base classes with later
	members?
</ol>

<p>
There is no apparent support for (1),
since no simple heuristic has been identified with obvious benefits.
There is interest in (2), based on a simple heuristic which might
sometimes help and will never hurt.
However, it is not clear that it will help much,
and Sun objects on grounds that they prefer to match C struct layout.
Unless someone is interested enough to implement and run experiments,
this will be hard to agree upon.
G++ has implemented (3) as an option,
based on specific user complaints.
It clearly helps HP's example of a base class containing a word and flag,
with a derived class adding more flags.
Idea (4) has more problems, including some non-intuitive (to users) layouts,
and possibly complicating the selection of bitwise copy in the compiler.

<p>
<font color=blue>[990624 all]</font>
We will not do (1), (2), or (4).  We will do (3).
Specifically, allocation will be in modified declaration order as follows:
<ol>
<li> Vptr if any, and the primary base class per A-7.
<li> Any empty base classes allocated at offset zero per A-3.
<li> Any remaining non-virtual base classes.
<li> Any non-static data members.
<li> Any remaining virtual base classes.
</ol>
Each subobject allocated is placed at the next available position that
satisfies its alignment constraints, as in the underlying psABI.
This is interpreted with the following special cases:
<ol>
<li> The "next available position" after a non-POD class subobject
	(base class or data member) with tail padding is at the
	beginning of the tail padding, not after it.
	(For POD objects, the tail padding is not "available.")
<li> Empty classes are considered to have alignment and size 1,
	consisting solely of one byte of tail padding.
<li> Placement on top of the tail padding of an empty class must avoid
	placing multiple subobjects of the same type at the same
	address.
</ol>
After allocation is complete,
the size is rounded up to a multiple of alignment (with tail padding).

<p>
<font color=blue>[990722 all]</font>
The precise placement of empty bases when they don't fit at offset zero
remained imprecise in the original description.
Accordingly, a precise layout algorithm is described in
a separate writeup of <a href=abi-layout.html#class-types>Data Layout</a>.

<p>
<font color=blue>[990729 all]</font>
The layout writeup was accepted,
with the first choice for empty base placement.
That is, if placement at offset zero doesn't work,
it will be placed like a normal base/member.
The concensus was that this won't happen often,
and such bases will often overlap with the preceding tail padding or
following components anyway.
Jim will modify the writeup accordingly.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-10 </td>
<td> Class parameters in registers </td>
<td> call </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990710 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The C ABI specifies that structs are passed in registers.
Does this apply to small non-POD C++ objects passed by value?
What about the copy constructor and <code>this</code> pointer in that case?
</td> </tr>

</table>

<p>
<font color=blue>[990701 all]</font>
A separate issue (C-7) deals with cases where a non-trivial copy
constructor is required; we ignore those cases here.
Our conclusion is that, without a non-trivial copy constructor,
we need not be concerned about the class object moving in the process
of being passed, and there is no need to use a mechanism different from
the base ABI C struct mechanism.
At the same time, if we do use the underlying C struct mechanism,
the user has complete control of the passing technique,
by choosing whether to pass by value or reference/pointer.

<p>
Therefore, except in cases identified by issue C-7 for different treatment,
class parameters will be passed using the underlying C struct protocol.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A11></a> <td> A-11 </td>
<td> Pointers to member functions </td>
<td> data </td>
<td> closed </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> 990812 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How should pointers to member functions be represented?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
As a pair of values, described below.
</td> </tr>

</table>

<p>
<font color=blue>[990729 All]</font>
Jason described the g++ implementation, which is a three-member struct:
<ol>
<li> The adjustment to <i>this</i>.
<li> The Vtable index plus one of the function, or -1.
     (Zero is a NULL pointer.)
<li> If (2) is an index, the offset from the full object to the member
     function's Vtable.  If -1, a pointer to the function (non-virtual).
</ol>

<p>
A concern about covariant returns was raised.
It was observed that, given our decision to use distinct Vtable entries
for distinct return types, no further concern is required here.
Others will describe their representations.
IBM has an alternative, but it is believed to be patented by Microsoft.

<p>
<font color=blue>[990805 All]</font>
It is agreed that a two-element struct will be used for a pointer to a
member function, with elements as follows:

<dl>
<p>
<dt> <code>ptr</code>:
<dd> For a non-virtual function, this field is a simple function pointer.
     (Under current base IA-64 psABI conventions,
     this is a pointer to a GP/function address pair.)
     For a virtual function,
     it is 1 plus twice the Vtable offset of the function.
     The value zero is a NULL pointer.

<p>
<dt> <code>adj</code>:
<dd> The required adjustment to <i>this</i>.
</dl>

<p>
Although we agreed to close this, SGI suggests a minor modification.
Since the Vtable offset of a virtual function will always be even,
we suggest that it not be doubled before adding 1.
This is because shifts are more restricted on many processors than
other integer ALU operations (shifters are large structures),
so an XOR or NAND will often be cheaper than a right shift.

<p>
<font color=blue>[990812 All]</font>
Close this issue with the suggested modification.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-12 </td>
<td> Merging secondary vtables </td>
<td> data </td>
<td> closed </td>
<td> Sun </td>
<td> 990610 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Sun merges the secondary Vtables for a class (i.e. those for
non-primary base classes) with the primary Vtable by appending them.
This allows their reference via the primary Vtable entry symbol,
minimizing the number of external symbols required in linking,
in the GOT, etc.
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Concatenate the Vtables associated with a class in the same order
that the corresponding base subobjects are allocated in the object.
</td> </tr>

</table>

<p>
<font color=blue>[990701 Michael Lam]</font>
Michael will check what the Sun ABI treatment is and report back.

<p>
<font color=blue>[990729 All]</font>
A separate issue raised in conjunction with A-7 is whether to include
Vfunc pointers in the primary Vtable for functions defined only in the
base classes and not overridden.
If the primary and secondary Vtables are concatenated,
this is no longer an issue,
since all can be referenced from the primary Vptr.

<p>
<font color=blue>[990805 All]</font>
All of the Vtables associated with a class will be concatenated,
and a single external symbol used
(to be identified as part of the mangling issue F-1).
The order of the tables will be the same as the order of base class
subobjects in an object of the class,
i.e. first the primary Vtable,
then the non-virtual base classes in declaration order,
and finally the virtual base classes in depth-first declaration order.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-13 </td>
<td> Parameter struct field promotion </td>
<td> call </td>
<td> closed </td>
<td> SGI </td>
<td> 990603 </td>
<td> 990701 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It is possible to pass small classes either as memory images,
as is specified by the base ABI for C structs,
or as a sequence of parameters, one for each member.
Which should be done, and if the latter,
what are the rules for identifying "small" classes?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
No special treatment will be specified by the ABI.
</td> </tr>

</table>

<p>
<font color=blue>[990701 all]</font>
Define no special treatment for this case in the ABI.
A translator with control over both caller and callee may choose to optimize.



<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <td> A-14 </td>
<td> Pointers to data members </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990729 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How should pointers to data members be represented?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Represented as one plus the offset from the base address.
</td> </tr>

</table>

<p>
<font color=blue>[990729 SGI]</font>
We suggest an offset from the base address of the class,
represented as a <code>ptrdiff_t</code>.

<p>
<font color=blue>[990805 All]</font>
Such pointers are represented as one plus the offset from the base
address of the class, as a <code>ptrdiff_t</code>.
NULL pointers are zero.


<p> <hr> <p>
<h3> B.  Virtual Function Handling Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B1></a> <td> B-1 </td>
<td> Adjustment of "this" pointer (e.g. thunks) </td>
<td> data call </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991202 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
There are several methods for adjusting the <i>this</i> pointer
for a member function call,
including thunks or offsets located in the vtable.
We need to agree on the mechanism used,
and on the location of offsets, if any are needed.
To maximize performance on IA64,
a slightly unusual approach such as using secondary entry points
to perform the adjustment may actually prove interesting. 
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
See the <a href=abi-layout#vcall>writeup in the ABI data layout
specification.
</td> </tr>

</table>

<p>
<font color=blue>[990623 HP -- Christophe]</font>

<p>
<h4>Open Issues Relevant To This Discussion</h4>

<ol>
<p>
<li>
Keeping all of a class in a single load module.
The vtable contains the target address and one copy of the target GP.
This implies that it is not in text, and that it is generated by dld.

<p>
<li>
Detailed layout of the virtual table.

<p>
<li>
How can we share class offsets?

</ol>


<p>
<h4> 1. Scope and "State of the Art"</h4>

<p>
The following proposal applies only to calls to virtual functions  
when a this pointer adjustment is required from a base class to a  
derived class.
Essentially, this means multiple inheritance, and the  
existence of two or more virtual table pointers (vptr)
in the complete object.
The multiple vptrs are required so that the layout  
of all bases is unchanged in the complete object.
There will be one additional vptr for each base class which already
required a vptr,  
but cannot be placed in the whole object so that it shares its vptr  
with the whole object.
Note: when the vptr is shared,
the base class  is said to be the "primary base class",
and there is only one such class.

<p>
For the primary base class, no pointer adjustment is needed.
For all  other bases, a pointer to the whole object is not a pointer
to the base class,
so whenever a pointer to the base class is needed,  
adjustment will occur.

<p>
In particular, when calling a virtual function,
one does not know in advance in which class the function was actually defined.
Depending on the actual class of the object pointed to,
pointer adjustment may be needed or not,
and the pointer adjustment value may vary from class to class.
The existing solution is to have the vtable point not to the function itself,
but to a "thunk" which does pointer adjustment when needed,
and then jumps to the actual function.  
Another possibility is to have an offset in the vtable,
which is used by the called function.
However, more often than not, this implies adding zero.

<p>
Virtual bases make things slightly more complicated.
In that case, the data layout is such that there is only
one instance of the virtual base in the whole object.
Therefore, the offset from a this  
pointer to a same virtual base may change along the inheritance tree.  
This is solved by placing an offset in the virtual table,
which is used to adjust the this pointer to the virtual base.


<p>
<h4> 2. Proposal and Rationale </h4>

<p>
My proposal is to replace thunks with offsets,
with two additional tricks:
<ul>
<li>
Give a virtual function two entry points,
so as to bypass the adjustment when it's known to be zero.
<li>
Moving the adjustment at call-site,
where it can be scheduled more easily,
using a "reasonable" value,
so that the adjustment is bypassed even more often.
</ul>

<p>
The thunks are believed to cost more on IA64 than they would on  
other platforms.
The reason is that they are small islands of code spread throughout the code,
where you cannot guarantee any cache locality.
Since they immediately follow an indirect branch,
chances are we will always encounter both a branch misprediction and a  
I-cache miss in a row.

<p>
On the other hand,
a virtual function call starts by reading the virtual function address.
Reading the offset immediately thereafter should almost never cause a
D-cache miss (cache locality should be good).
More often than not, no adjustment is needed,
or the adjustment will be done at call site correctly.
In the worst case scenario, we perform two adjustments,
one static at call site, and one dynamic in the callee,
but this case should be really infrequent.


<p>
<h4> 3. New Calling Convention </h4>

<p>
The new calling convention requires that the 'this' pointer on entry  
points to the class for which the virtual function is just defined.  
That is, for A::f(),
the pointer is an A* when the main entry of the function is reached.
If the actual pointer is not an A*,
then an adjusting entry point is used,
which immediately precedes the function.

<p>
In the following, we will assume the following examples:
<p>
<code><pre>
    struct A { virtual void f(); };
    struct B { virtual void g(); };
    struct C: A, B { }
    struct D : C { virtual void f(); virtual void g(); }
    struct E: Other, C { virtual void f(); virtual void g(); }
    struct F: D, E { virtual void f(); }

    void call_Cf(C *c) { c->f(); }
    void call_Cg(C *c) { c->g(); }
    void call_Df(D* d) { d->f(); }
    void call_Dg(D* d) { d->g(); }
    void call_Ef(E* e) { e->f(); }
    void call_Eg(E* e) { e->g(); }
    void call_Ff(F *ff) { ff->f(); }
    void call_Fg(F *ff) { ff->g(); }	// Invalid: ambiguous
</pre></code>

<dl>
<p>
<dt> a) Call site:
<dd>
The caller performs adjustment to match the class of the last  
overrider of the given function.

<ul>
<p>
<li> call_Cf will assume that the pointer needs to be cast to an A*,  
since C::f is actually A::f. Since A is the primary base class, no  
adjustment is done at call site.

<p>
<li> call_Cg is similar, but assumes that the actual type is a B*, and  
performs the adjustment, since B is not the primary base class.

<p>
<li> call_Df and call_Dg will assume that the pointer needs to be cast  
to a D*, which is where D::f is defined. No adjustment is performed  
at call site.
</ul>
</dd>


<p>
<dt> b) Callee
<dd>
<ul>
<p>
<li> A::f and B::g are defined in classes where there is a single vptr.  
They don't define a secondary entry point. Because of call-site  
conventions, they expect to always be called with the correct type.

<p>
<li> D::f is defined in a class where there is more than one vptr, so  
it needs a secondary entry point and an entry 'convert_to_D' in the  
vtable. That's because it can be potentially called with either an A*  
or a B*. There are two vtables, one for A in D, one for B in D. The  
D::f entry in A in D points to the non-adjusting entry point, since A  
shares its vptr.

<p>
<li> D::g requires a secondary entry point, that will read the same  
offset 'convert_to_D' from the vtable.

<p>
<li> E also will require a 'convert_to_E' entry in the vtable, but this  
time, the vtable for A in C will have to point to an adjusting entry  
point, since A no longer shares the vptr with E (assuming Other has  
a vptr). This vtable is also the vtable of C in E.
</ul>
</dd>


<p>
<dt> c) Offsets in the vtable
<dd>
Offsets have to be placed in the vtable at a position which does not  
conflict with any offset in the inheritance tree.

<p>
convert_to_D and convert_to_E are likely to be at the same offset in  
the vtable. This is not a problem, even if D and E are used in the  
same class, such as F, because this is the same offset in different  
vtables.

<ul>
<p>
<li> call_Fg is invalid, because it is ambiguous.

<p>
<li> A notation such as ((E*) ff)->g() can be used to disambiguate, but  
in that case, we don't use the same vtable (either the E in F or D  
in F vtable). The E in F vtable uses that offset as 'convert_to_E',  
whereas the D in F vtable uses that offset as 'convert_to_D'.

<p>
<li> Similarly, call_Cf called with an F object will actually be called  
with the E in F or D in F, which disambiguates which C is actually  
used. The actual C* passed will have been adjusted by the caller  
unambiguously, or the call will be invalid.

<p>
<li> For functions overriden in F, an entry 'convert_to_F' is created  
anyway. This entry will not overlap with either convert_to_E or  
convert_to_D.
</ul>

<p>
The fact that an offset is reserved does not mean that it is  
actually used. A vtable need to contain the offset only if it refers  
to a function that will use it. An offset of 0 is not needed, since  
the function pointer will point to the non-adjusting entry point in  
that case.
</dd>

</dl>


<p>
<h4> 4. Cases where adjustment is performed </h4>

<ul>
<p>
<li> For call_Cf: No adjustment is done at call site. No adjustment is  
done at callee site if the dynamic type is C,  or D, or D in F (that  
is, F casted to an E).

<p>
<li> For call_Cg: Adjustment to B* is done at call-site. No further  
adjustment is needed if the dynamic type is C, D, or D in F. On the  
other hand, a second adjustment may happen for an E or E in F,  
because C is not their primary base.
</ul>

<p>
In other words, adjustment is made only when necessary, and at a  
place where it is better scheduled than with thunks. The only bad  
case is double adjustment for call_Cg called with an E*. This case  
can probably be considered rare enough, compared to calls such as  
call_Cg called with a C*, where we now actually do the adjustment at  
the call-site.


<p>
<h4> 5. Comparing the code trails </h4>

<p>
Currently, the sequence for a virtual function call in a shared  
library will look as follows. I'm assuming +DD64, there would be some  
additional addp4 in +DD32. The trail below is the dynamic execution  
sequence. In bold and between #if/#endif, the affected code.

<p>
<code><pre>
        // Compute the address of the vptr in the object,
	// from the this pointer
        // Optional, since vptroffset is often 0.
	// This also adjusts to the class of the final overrider
        addi            Rthis=vptroffset_of_final_overrider,Rthis
        ;;
        // Load the vptr in a register
        ld8             Rvptr=[Rthis]
        ;;
        // Add the offset to get to the function descriptor pointer
	// in the vtable.  Never zero, this instruction is always generated
        addi            Rfndescr=fndescroffset,Rvptr
        ;;
        // (Assuming inlined stub) Load the function address and new GP
        ld8             Rfnaddr=[Rfndescr],8
        ;;
        // Load the new GP
        ld8             GP=[Rfndescr]
        mov             BRn=Rfnaddr
        ;;
        // Perform the actual branch to the target

        // ...
        // ... Branch misprediction almost always, followed by
        // ... I-Cache miss almost always if jumping to a thunk
        br.call B0=BRn

#if OLD_ADJUST
thunk_A::f_from_a_B:
        // If the 'adjustment_from_B_to_A is the 'adjustment_to_A' above,
        // then in the new case, the vtable directly points to A::f
        addi            Rthis,adjustment_from_B_to_A

        // In most cases, we can probably generate a PC-relative branch here
        // It is unclear whether we would correctly predict that branch
        // (since it is assumed that we arrive here immediately following
        // a misprediction at call site)
        br              A::f
#endif // OLD_ADJUST

// This occurs less often than OLD_ADJUST
// (it does not happen when call-site adjustment is correct)
#if NEW_ADJUST
adjusting_entry_A::f
        // Can't be executed in less than 3 cycles?
        addi            Rvptr=class_adjustment_offset,Rvptr
        ;;
        // This loads data which is close to the fn descriptor,
        // so it's likely to be in the D-cache
        ld8             Rvptr=[Rvptr]
        ;;
        add             Rthis=Rthis,Rvptr
#endif

A::f:
        alloc   ...
</pre></code>

<p>
<font color=blue>[990812 All]</font>
Discussion of B-6 raises questions of impact on the above approach.
Christophe will look at the issues.

<p>
<font color=blue>[990826 Cygnus -- Jason]</font>
[An alternative suggestion from Jason via email.]

<p>
Rather than per-function offsets, we have per-target type offsets.
These offsets (if any) are stored at a negative index from the vptr.
When a derived class D overrides a virtual function F from a base class B,
if no previously allocated offset slot can be reused,
we add one to the beginning of the vtable(s) of the closest base(s)
which are non-virtually derived from B.
In the case of non-virtual inheritance, that would be D's vtable;
in simple virtual inheritance, it would be B's.
The vtables are written out in one large block,
laid out like an object of the class,
so if B is a non-virtual base of D,
we can find the D vtable from the B vptr.

<p>
D::f then recieves a B*, loads the offset from the vtable,
and makes the adjustment to get a D*.
The plan is to also have a non-adjusting vtable entry in D's vtable,
so we don't have to do two adjustments to call D::f with a D*;
the implementation of this is up to the compiler.
I expect that for g++,
we will do the adjustment in a thunk which just falls into the main function.

<p>
The performance problems with classic thunks occur when the thunk is
not close enough to the function it jumps to for a pc-relative branch.
This cannot be avoided in certain cases of virtual inheritance,
where a derived class must whip up a thunk for a new adjustment
to a method it doesn't override.

<p>
In this case, we will only ever have one thunk per function,
so we don't even have to jump.
Except in the case of covariant returns, that is,
where we will have one per return adjustment.
But we know all necessary adjustments at the
point of definition of the function,
so they can all be within pc-relative branch range.

<p>
[Extensive discussion followed by email --
this suggestion is not completely correct,
but may be the basis of a workable solution.]

<p>
<font color=blue>[990831 Cygnus -- Ian]</font>
A couple of observations ...

<p>
<b>On the state of the art:</b>

<p>
The Microsoft approach is worth mentioning.
(I haven't seen it discussed --
though perhaps that is because of the patent situation.)

<p>
It allows zero-adjusting (i.e. non-thunking) calls for (almost)
every virtual function call in a non-virtual,
multiple inheritance hierarchy.

<p>
For those that are unfamiliar,
the idea is that all calls go via the base class vft and overriding
functions expect a pointer to the base class type.
(That is, if D::f overrides B::f, it expects the first
parameter to be of type B*, not D*.)
The callee does the necessary static adjustment to get to the
derived class 'this' pointer as needed.

<p>
It avoids requiring a thunk,
and it's often the case that the cost is zero in the callee because
the this-adjustment can be folded into other offset computations.

<p>
On the balance,
it could well win over all the other approaches being discussed here.
[Though, it may lose in some specific cases vs. Christophe's approach
where one would create additional extra entries in
the derived class vft.]

<p>
<b>On when to make extra virtual function table entries for functions:</b>

<p>
One of Cristophe's suggestions is sort-of separate
from the rest of the discussion:
making extra entries in the derived class' vft for some
overridden virtual functions.
It has the benefit of giving you a faster calls if you happen to be in
(or near) the derived class -- at the expense of space in the vft.

<p>
Of course, you can always make the call through the introducing base class,
so these extra entries are a pure space/time performance trade off
(w/ some unpredictable D-cache effects) and the cost/benefit analysis
will depend a little on what the rest of the strategy looks like.

<p>
The same idea is potentially applicable,
no matter what strategy you actually use for vft layout,
and different criteria for deciding what extra entries to make are possible.
For example,
creating an extra entry when overriding a function introduced in a
virtual base has the added benefit of avoiding a cast to a virtual
base at the call site.

<p>
<font color=blue>[990909 All]</font>
We are getting closer --
understanding of the alternatives is improving,
and Christophe may agree with the Jason/Brian proposal after more thought.
To make sure we really understand what we're agreeing to,
Jason and Christophe will write up more precise proposal(s).


<p><font color=blue><hr><p>[991111 jason] </font>
<p>
<h4> Final virtual calling convention: </h4>
<p>
We have decided that for virtual functions not inherited from a virtual base, 
regular thunks will work fine,
since we can emit them immediately before the
function to avoid the indirect branch penalty;
we will use offsets in the
vtable for functions that come from a virtual base,
because it is impossible to predict what the offset between the
current class and its virtual base will
be in classes derived from the current class.

<p>
The calling convention is as follows:

<ul>
<li>vtable layout:
<p>
For each virtual function defined in a class,
we add an entry to the primary vtable if one is not already there.
In particular, a definition which overrides a function inherited from
a secondary base gets a new slot in the primary vtable.
We do this to avoid useless adjustments when calling a virtual
function through a pointer to the most derived class.

<p>
When a class is used as a virtual base,
we add a vcall offset slot to the beginning of its vtable for each of
the virtual functions it provides,
whether in its primary or secondary vtables.
Derived classes which override these functions will use the slots to
determine the adjustment necessary.

<p>
<li>Caller:
<p>
As in Christophe's proposal above,
the caller adjusts the 'this' argument to 
point to the class which last overrode the function being called.
The result provides both the 'this' argument and the vtable pointer
for finding the function we want.

<p>
<li>Callee:
<p>
Each virtual function 'f' defined in a class 'A' has one entry point
which takes an A*, and performs no adjustment.
The primary vtable for A points to this entry point.

<p>
For each secondary vtable from a non-virtual base class 'B' which
defines f,
an additional entry point is generated which performs the constant
adjustment from B* to A*.

<p>
For each secondary vtable from a virtual base class 'C' which defines f,
an additional entry point is generated which performs the adjustment
from C* to A* using the vcall offset for f stored in the secondary
vtable for C.

<p>
For each secondary vtable from a base 'D' which is a non-virtual base
of a virtual base 'E',
an additional entry point is generated which
first performs the constant adjustment from D* to E*,
then the adjustment from E* to A* using the vcall offset for f stored
in the secondary vtable for E.

<p>
<li>Implementation
<p>
Note that the ABI only specifies the multiple entry points;
how those entry points are provided is unspecified.
An existing compiler which uses thunks could be converted to use this
ABI by only adding support for the vcall offsets.
A more efficient implementation would be to emit all of the thunks
immediately before the non-adjusting entry point to the function.
Another might use predication rather than branches to reach the main function.
Another might emit a new copy of the function for each entry point;
this is a quality of implementation issue.
</ul>

<p><font color=blue><hr><p>[991202 all] </font>
Adopt Jason's writeup.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B2></a> <td> B-2 </td>
<td> Covariant return types </td>
<td> call </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990722 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
There are several methods for adjusting the 'this' pointer of the
returned value for member functions with covariant return types.
We need to decide how this is done.
Return thunks might be especially costly on IA64,
so a solution based on returning multiple pointers may prove more interesting.
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Provide a separate Vtable entry for each return type.
</td> </tr>

</table>

<p>
<font color=blue>[990610 Matt]</font>
One possibility is to have two Vtable entries,
which might point to different functions, different entrypoints,
or a real entrypoint and a thunk.
Another is to return two result pointers (base/derived),
and have the caller select the right one.

<p>
<font color=blue>[990715 All]</font>
Daveed presented his multiple-return-value scheme,
including an example that involved virtual base classes,
return values that are pointers to nonpolymorphic classes,
and other equally horrible things.

<p>
Consensus: we need to get the horrible cases correct,
but speed only matters in the simple case.
The simple case: class B has a virtual function f returning a B1*
and class D has a virtual function f returning a D1*,
where all four classes are polymorphic,
B is a primary base of D, and B1 is a primary base of D1.
(The really important case is where B1 is B and D1 is D,
but that simplification doesn't make any difference.)

<p>
Jason: Would the usual multiple-entry-point scheme work just as well?
That is, would it be just as fast as Daveed's scheme in the simple case,
and still preserve enough information for the more complicated cases?
It appears so, but we don't have a proof.
Jason will try to provide one.


<p>
<font color=blue>[990716 Cygnus -- Jason]</font>
Proof?
You always know what types a given override must be able to return,
and you know how to convert from the return type to those base types.
You know from the entry point which type is desired.
Seems pretty straightforward to me.



<p>
<font color=blue>[990716 Cygnus -- Jason]</font>
The alternative I was talking about yesterday goes something like this:

<p>
When we have a non-trivial covariant return situation,
we create a new entry in the vtable for the new return type.
The caller chooses which vtable entry to use based on the type they want.

<p>
This could be implemented several ways,
at the discretion of the vendor:

<ol>
<p>
<li>
Multiple entry points to one function,
with an internal flag indicating which type to return.
<p>
<li>
Thunks which intercept the function's return and modify the return value.
Note that unlike the case of calling virtual functions,
for covariant returns we always know which adjustments will be needed,
so we don't have to pay for a long branch.
We do, however, lose the 1-1 correspondence between calls and returns,
which apparently affects performance on the Pentium Pro.
<p>
<li>
Function duplication.
</ol>

<p>
The advantage of this approach to the complex case is that we don't have to
do a dynamic_cast when faced with multiple levels of virtual derivation.
It is also strictly simpler;
Daveed's model already requires something like
this in cases of multiple inheritance.

<p>
Of course, we can always mix and match;
we could choose to only do this in cases of virtual inheritance,
or use Daveed's proposal and do this only in
cases of repeated virtual inheritance.
In that case, the multiple returns
would just be an optimization for the single virtual inheritance case.

<p>
Since we don't seem to care about the performance of
anything but single nonvirtual inheritance,
it seems simpler not to bother with multiple returns.

<p>
The remaining question is how to handle the case of nontrivial
nonvirtual inheritance:
do we use multiple slots or have the caller do the adjustment?
My inclination is to have the caller adjust.

<p>
WRT patents,
the idea of having the function return the base-most class and having
the caller adjust is parallel to the patented Microsoft scheme whereby
they pass the base-most class as the 'this' argument to virtual functions,
but the word 'return' does not appear anywhere in the patent,
so it seems safe.


<p>
<font color=blue>[990722 All]</font>
The group was generally agreed that the simplicity of multiple entries
in the vtable outweighed any space/performance advantage of more
complex schemes (e.g. the method Daveed described on 15 July).
Discussion focussed on whether it is worthwhile to eliminate some of
the entries in cases where they are unnecessary because the caller
knows the required conversion,
namely when the return type has a unique non-virtual subobject of the
original return type.

<p>
Agreement was reached to avoid the complication of eliminating some of
the Vtable entries.
Thus, the Vtable will have one entry for each accessible return type of
a covariant virtual function.
These may be implemented in a variety of ways,
e.g. duplicated functions, separate entrypoints, or stubs,
and the ABI need not specify the choice.
The location of the Vtable entries is part of the separate Vtable
layout issue B-6.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> B-3 </td>
<td> Allowed caching of vtable contents </td>
<td> call </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The contents of the vtable can sometimes be modified,
but the concensus is that it is nonetheless always allowed to "cache" elements,
i.e. to retain them in registers and reuse them,
whenever it is really useful.
However, this may sometimes break "beyond the standard" code,
such as code loading a shared library that replaces a virtual function.
Can we all agree when caching is allowed? 
</td> </tr>
<tr> <td colspan=7>
<b> Resolution </b>:
Caching is allowed.
</td> </tr>

</table>

<p>
<font color=blue>[990604 HP -- Christophe]</font>
Mike (Ball) gave me what I believe is an excellent definition of  
when caching is allowed.  I'd like him to present it.

<p>
<font color=blue>[990805 All]</font>
Christophe explained that the rule is simply that,
within a call to a member function of the class,
the class Vtable may not be modified.
Between such calls, no assumption may be made.
With this observation, the issue is closed.

<p>
<font color=blue>[990812 All]</font>
The rule is even simpler.
Once a program changes the type of a pointer's target,
the pointer is invalidated, and its value may not be reused.
Therefore, a code sequence which repeatedly refers to the same pointer
value is invalid if the pointee's vtable has been changed.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B4></a> <td> B-4 </td>
<td> Function descriptors in vtable </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
For a runtime architecture where the caller is expected to load the GP
of the callee (if it is in, or may be in, a different DSO), e.g. HP/UX,
what should vtable entries contain?
One possibility is to put a function address/GP pair in the vtable.
Another is to include only the address of a thunk which loads the GP
before doing the actual call.
</td> </tr>
<tr> <td colspan=7>
<b> Resolution </b>:
The Vtable will contain a function address/GP pair.
</td> </tr>

</table>

<p>
<font color=blue>[990624 All]</font>
Note that putting GP in the Vtable prevents putting it in shared memory.
See B-7.

<p>
<font color=blue>[990805 All]</font>
It was decided that special representations to accomodate shared memory
would be expensive and therefore undesirable.
Therefore, the decision is to put the function address/GP pair in the
vtable, avoiding the cost of an extra indirection in using it.

<p>
<font color=blue>[991007 IBM -- Brian]</font>
A while ago Jason was worried about COM compatibility.
Part of that is to ensure that vtables can be expressed in C.
But the resolution of issue B-4 says that a vtable contains
function descriptors rather than function descriptor pointers.

<p>
From the standpoint of call performance that is a good thing,
but the result can't be built in C.
I know that we at least will also have to rewrite parts of our
C++ runtime that hand-build vtables.
Neither of these are critical for IBM but may be for others.

<p>
<font color=blue>[991103 Cygnus -- Richard Henderson]</font>
<pre>
> The ia64 C++ ABI committee has decided to use the descriptors.
> If this doesn't make sense (i.e. if there's no way to express
> such a thing to the assembler), now's the time to let us know...:)

You mean you want the vtable to look like

      struct { void *code, *gp } vtable[];

There are no suitable IA-64 relocations to express this.
</pre>

<p>
<font color=blue>[991106 SGI -- Jim]</font>
Richard Henderson of Cygnus points out that the IA-64 relocations
don't support doing this (inserting a function descriptor in data).
However, the R_IA_64_IPLT*SB relocations do perform the correct action.
The problem is that they are currently specified to be valid only
in executables and shared objects.
I believe that the problem can be solved by simply removing this restriction.
The static linker support required shouldn't be major --
it would presumably just pass the relocations through to the linked
object and let the dynamic linker deal with them.

<p>
The above issue has been raised with the IA-64 base ABI group.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B5></a> <td> B-5 </td>
<td> Where are vtables emitted? </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 991118 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
In C++, there are various things with external linkage that can be
defined in multiple translation units,
while the ODR requires that the program
behave as if there were only a single definition.
From the user's standpoint, this applies to inlines and templates.
From the implementation's perspective,
it also applies to things like vtables and RTTI info.
(We call this <i>vague linkage</i>.)
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Vtables will be emitted with the key function (first virtual function
that is not inline at the point of class definition), if any.
If no key function, emit everywhere used (i.e. referred to by name).
Place in a comdat group in all cases.
</td> </tr>

</table>

<p>
<font color=blue>[990624 Cygnus -- Jason]</font>
There are several ways of dealing with vague linkage items:
<ol>
<li> Emit them everywhere and only use one.
<li> Use some heuristic to decide where to emit them.
<li> Use a database to decide where to emit them.
<li> Generate them at link time.
</ol>

<p>
#3 and #4 are feasible for templates,
but I consider them too heavyweight to be used for other things.

<p>
The typical heuristic for #2 is "with the first non-inline,
non-abstract virtual function in the class".
This works pretty well,
but fails for classes that have no such virtual function,
and for non-member inlines.
Worse, the heuristic may produce different results in different
translation units,
as a method could be defined inline after being declared non-inline
in the class body.
So we have to handle multiple copies in some cases anyway.

<p>
The way to handle this in standard ELF is weak symbols.
If all definitions are marked weak,
the linker will choose one
and the others will just sit there taking up space.

<p>
Christophe mentioned the other day that the HP compiler used the
typical heuristic above,
and handled the case of different results by encoding the
key function in the vtable name.
But this seems unnecessary when we can just choose one of multiple defns.

<p>
A better solution than weak symbols alone would be to set things up so
that the linker will discard the extra copies.
Various existing implementations of this are:

<ol>
<p>
<li>
The Microsoft PE/COFF defn includes support for COMDAT sections,
which key off of the first symbol defined.
One copy is chosen, others are discarded.
You can specify conditions to the linker
(must have same contents, must have same size).

<p>
<li>
The IBM XCOFF platform includes a garbage-collecting linker;
sections that are not referenced in a sweep from main are discarded.
In xlC, template instantiations are emitted in separate sections,
with encoded names;
at link time, one copy is renamed to the real mangled name,
and the others are discarded by garbage collection.
</ol>

<p>
The GNU ELF toolchain does a variant of #1 here;
any sections with names beginning with ".gnu.linkonce."
are treated as COMDAT sections.
It seems more sensible to me to key off of the section name
than the first symbol name as in PE.

<p>
The GNU linker recently added support for garbage collection,
and I've been thinking about changing our handling of vague
linkage to make use of it, but haven't.

<p>
I propose that the ia64 base ABI be extended to
provide for either COMDAT sections or garbage collection,
and that we use that support for vague linkage.

<p>
I further propose that we not use heuristics to
cut down the number of copies ahead of time;
they usually work fine, but can cause problems in some situations,
such as when not all of the class's members are in the same symbol space.
Does the ia64 ABI provide for controlling which symbols
are exported from a shared library?

<p>
A side issue: What do we want to do with
dynamically-initialized variables?
The same thing, or use COMMON?
I propose COMMON.

<p>
See also G-3, for vague linkage of inlined routines and their static variables.

<p>
<font color=blue><hr><p>[990624 SGI summarizing others]</font>
HP uses COMDAT for many cases, keying from the symbol names.
HP also uses some heuristics.
HP observes that IA-64 objects will already be large.
From the base ABI discussions,
any use of WEAK or COMMON symbols will need to take care not to depend
on vendor-specific treatment.

<p>
Defining a COMDAT mechanism doesn't preclude using heuristics to avoid
some copies up front.
A COMDAT mechanism should also specify how to get rid of associated
sections like debugging info, unless the identical mechanism works.

<p>
<font color=blue><hr><p>[990629 HP -- Christophe]</font>
First, the "usual" heuristic
(which is usual because it dates back to Cfront)
is to emit vtables in the translation unit that contains  
the definition of the first non inline, non pure virtual function.  
That is, for:
<pre><code>
        struct X {
                void a();
                virtual void f() { return; }
                virtual void g() = 0;
                virtual void h();
                virtual void i();
        };
</code></pre>
the vtable is emitted only in the TU that contains the definition of h().

<p>
This breaks and becomes non-portable if:
<ul>
<li>There is no such thing. In that case,
    you generally emit duplicate versions of vtables
<li>There is a "change of mind",
    such as having the above class followed by:
    <code><p>
    <dd>inline void X::h() { f(); }
    </code>
</ul>

<p>
Now, the COMDAT issue is as follows:
a COMDAT section is, in some cases, slightly more difficult to handle
(at least, that's the impression Jason gave me).
For statics with runtime initialization,  
what you can do is reserve COMMON space ('easier'),
then initialize that space at runtime.
As I said, the problem is if two compilers disagree on whether this
is a runtime or a compile time initialization, such as in :
<pre><code>
	int f() { return 1; }
	int x = f();	// Static (COMDAT) or Dynamic (COMMON) initialization?
</code></pre>

<p>
So I personally recommend that we put everything in COMDAT.

<p>
<font color=blue>[990715 All]</font>
Consensus so far: use a heuristic for vtable and typeinfo emission,
based on the definition of the key function.
(The first virtual function that is not
declared inline in the class definition.)
The vtable must be emitted where the key function is defined,
it may also be emitted in other translation units as well.
If there is no key function then the vtable must be emitted in any
translation unit that refers to the vtable in any way.

<p>
Implication: the linker must be prepared to discard duplicate vtables.
We want to use COMDAT sections for this
(and for other entities with vague linkage.)

<p>
Open issue: the elf format allows only 16 bits for section identifiers,
and typically two of those bits are already taken up for other things.
So we've only got 16k sections available,
which is unacceptable if we're creating lots of small sections.

<p>
Jason - COMDATs disappear into text and data at link time,
so the issue is really only serious if we've got more than 16k vtables
(or template instantiations, etc.)
in a single translation unit.

<p>
Daveed - HP has gotten around this problem by hacking their ELF files
to steal another 8 bits from somewhere else.

<p>
Jack - a new kind of section table could be a viable solution.
However, it would break everything if we did it for ia32.
Is a solution that only works on ia64 acceptable?
Note also that the elf section table has its own string table,
which we wouldn't be able to share with the new kind of section table.
Index and link fields often point into section table,
we would have to figure out how to deal with this.
(Jack is not opposed to the idea of an alternate section table,
he is just pointing out some of the issues we will have to resolve.)


<p>
<font color=blue><hr><p>[990805 All]</font>
We need a specific proposed representation for COMDAT.
IBM's version is restricted to one symbol per section.
Jim will look for Microsoft's PECOFF definition.
Anyone else with a usable definition should send it.

<p>
<font color=blue><hr><p>[revised 991012 SGI]</font>
<h2> C++ ABI:  COMDAT Proposal </h2>

<p>
<h3> Revisions </h3>

<p>
<font color=blue>[991007]</font>
Change default to simply group; COMDAT semantics is option.
Don't support removal based on duplication of non-COMDAT sections.
Just remove symbols defined relative to removed sections.

<p>
<h3> Introduction </h3>

<p>
C++ has many situations where the compiler may need to emit code or data,
but may not be able to identify a unique compilation unit
where it should be emitted.
The approach chosen by the C++ ABI group to deal with this problem,
is to allow the compiler to emit the required information in multiple
compilation units,
in a form which allows the linker to remove all but one copy.
This is essentially the idea called COMDAT in several existing
implementations.

<p>
Various other implementations (notably Windows NT) and proposals obtain
more generality by varying the duplicate removal semantics.
The most obviously useful variant supports grouping of sections for
removal purposes, but treats duplication as an error,
using it to support link-time removal of unreferenced sections.
The proposal below treats this simple grouping as the default semantics,
and provides duplicate removal as an option.

<p>
Our objectives include:

<ul>

<p>
<li>
Use existing structures as far as possible,
to minimize impact on existing tools.

<p>
<li>
Minimize impact on the linker by defining the unit of duplication
as a section.

<p>
<li>
Maximize generality.
The C++ needs are rather varied,
and similar needs from other languages should also be handled.

<p>
<li>
In general, duplicated code or data sections are accompanied by
additional duplicated sections, e.g. containing debug information.
We want to define a mechanism which can deal with arbitrary such
associations, without predicting them in advance.

</ul>

<p>
<h3> Proposal </h3>

<p>
The proposal below is based on the HP definition,
with minor modifications and more precise definitions.

<p>
<h4> SHF_GROUP: Group Member Sections </h4>

A section which is part of a group,
and is to be retained or discarded with the group as a whole,
is identified by a new section header attribute:

<dl>
<dt> SHF_GROUP
<dd> This section is a member (perhaps the only one) of a group of sections,
    and the linker should retain or discard all or none of the members.
    This section must be referenced in a SHT_GROUP section (see below).
</dl>

<p>
This attribute flag may be set in any section header,
and no other modification or indication is made in the grouped sections.
All additional information is contained in the associated
SHT_GROUP section (see below).

<p>
<h4> SHT_GROUP: Section Group Definition </h4>

<p>
Some sections occur in interrelated groups.
For instance, an out-of-line definition of an inline function might require,
in addition to its .text section,
a read-only data section containing literals referenced,
one or more debug information sections,
and/or other informational sections.
Furthermore, there may be internal references among these sections that
would not make sense if one of them were removed or
replaced by a duplicate from another object.
Therefore, we assume that such groups are to be included or omitted
from the linked object as a unit.
(Except for the GRP_COMDAT flag described below,
this definition does not specify the circumstances under which the
members of a group might be discarded from the linked object.)

<p>
To facilitate this, we define a SHT_GROUP section:

<p>
The section header attributes of a Group Section are:

<p>
<TABLE align=center BORDER=2 CELLSPACING=2 CELLPADDING=2>

<TR>
<TD><b> name </b></TD>
<TD> unspecified </TD>
</TR>

<TR>
<TD><code> sh_type </code></TD>
<TD><code> SHT_GROUP </code></TD>
</TR>

<TR>
<TD><code> sh_link </code></TD>
<TD><code> .symtab </code> section index </TD>
</TR>

<TR>
<TD><code> sh_info </code></TD>
<TD> symbol index </TD>
</TR>

<TR>
<TD><code> sh_flags </code></TD>
<TD> none </TD>
</TR>

<TR>
<TD><code> sh_entsize </code></TD>
<TD> size of section indices (<code>4</code>) </TD>
</TR>

<TR>
<TD> requirements </TD>
<TD> may not be stripped </TD>
</TR>

</TABLE>

<p>
The section group's <code> sh_link </code> field identifies a symbol
table section, and its <code> sh_info </code> field the index of a
symbol in that section.
The name of that symbol is treated as the identifier of the section group.

<p>
The section data of a SHT_GROUP section is a flag word
followed by a sequence of section indices.
The flag word may contain the following flags:

<dl>
<dt> GRP_COMDAT (0x1)
<dd>
This is a COMDAT group.
It may duplicate another COMDAT group in another object file,
where duplication is defined as having the same identifying symbol name.
In such cases, only one of the duplicate groups should be retained by
the linker, and the remaining groups should be discarded.
</dd>
</dl>

<p>
The section indices in the SHT_GROUP section identify
the sections which make up the group.

<p>
The <code>sh_size</code> value is <code>sh_entsize</code> times
one plus the number of sections in the group.

<p>
The linker may choose to discard a section in a group,
i.e. not include its data in the linked object,
based on COMDAT duplicate semantics (above),
or for other implementation-defined reasons
(e.g. removing unreferenced code).
If it does so, the group semantics requires that all of the group
members be removed as a unit.

<p>
<i>
(Note, however, that this is not intended to imply that special-case
behavior like removing debug information requires removing the sections
to which it refers, even if they are in a group.
We could clarify this issue by tying the removal semantics to the
section which contains the identifying symbol,
but this seems overly restrictive and unnecessary.
</i>

<p>
<h4> Requirements </h4>

<ul>
<p>
<li>
References to the sections comprising a group,
from sections outside the group,
must be made via global UNDEF symbols,
referencing global symbols defined as addresses in the group sections.
They may not reference local symbols for addresses in the group's
sections, including section symbols.

<p>
<li>
There may not be non-symbol references to the sections comprising a
COMDAT group from sections outside the group, e.g. in sh_link fields.
For example, relocations of one of the group's sections must be in a
relocation section which is also part of the group.

<p>
The above rules allow a group to be removed without leaving
dangling references, with only minimal processing of the symbol table.

<p>
<li>
An entry in a symbol table section not in the group,
with a definition that is relative to one of the group's sections,
should be removed if the group is discarded.

<p>
<li>
The SHT_GROUP section must precede the sections in the group
(in the section table).

</ul>

<p>
<h4> Questions </h4>
<i>

<ul>

<p>
<li>
Do we want flags to specify checking prior to removal of duplicates,
e.g. for identical sections, same defined global symbols, etc.?
If so, should there be one flags word per section index,
instead of per group?
<dd>
Answer:  No flags besides GRP_COMDAT.  Only one flags word needed.
</dd>

<p>
<li>
Do we want more control over when global symbols are removed vs. being
converted to UNDEF?
Alternatively, should we simply require that all symbols defined as
addresses in the group be removed,
and that references to them from outside do so via distinct UNDEF
global symbols?
<dd>
Answer:  Just remove symbols defined relative to removed sections.
</dd>

<p>
<li>
Do we want to replace the symbol rule by simply requiring that any
symbols defined as addresses in the group be defined in a .symtab
section that is itself in the group?
<dd>
Answer:  No.  Removing symbols is not hard, and is already done in
other circumstances in many implementations.
</dd>

<p>
<li>
Why use a symbol to identify a (COMDAT) group instead of the group
section name?
<dd>
Answer:  These will be very common in C++,
and the typical names in C++ can be extremely long
(for template instantiations often multiple kilobytes in current
implementations, and probably 100+ characters on average even if better
mangling is adopted).
Virtually all such sections must already define a real global symbol,
and duplicating such long names in the section name string table is
undesirable space overhead.
</dd>

<p>
<li>
What is the name of a group section?
<dd>
Answer:
It is unspecified, because it has no significance to the linker.
It is recommended that it be something like .group,
possibly with a short suffix to distinguish multiple groups in an
object if necessary,
but we place no requirement on the name.
</dd>

</ul>
</i>

<p>
<font color=blue><hr><p>[revised 991012 SGI]</font>
<h2> gABI:  Section Indices </h2>

<p>
<h3> Revisions and Status </h3>

<p>
[991007]
Change section/flag names, move ELF header extension to section header 0.

<p>
<h3> Background </h3>

<p>
SGI has long been concerned about the 64K limitation on the number of
sections in an object file.
Although this need not normally be a problem,
there are purposes for which we would like to place distinct functions,
and sometimes data items,
in distinct sections.
When one takes into account associated sections,
e.g. relocation, debug information, etc.,
this leads to a limitation on the order of 16K units,
and threatens to be a problem for some large compilation units such as
machine-generated simulators.

<p>
C++ ABI efforts raise the same issue from another source.
Various C++ structures are emitted under circumstances
where the compiler cannot reliably identify a single compilation unit
in which to emit them.
Examples include common cases like class virtual tables,
out-of-line copies of inline functions,
and template instantiations.
The favored solution is COMDAT sections,
i.e. putting the potentially duplicated items in their own sections,
and allowing the linker to remove the duplicates.
Once again, though, this threatens to be a problem for very large
compilation units.

<p>
The following proposal attempts to remove this limitation.
Obviously, even if the problem is real,
it will actually arise in very few compilation units.
Therefore, the elements of the proposed solution are defined so as to
leave unchanged object files which do not encounter the problem.
We consider this compatibility objective as primary --
much more important than performance or
clean definitions for the problematic object files --
particularly as it should allow vendors to merge the solution into
existing tool chains at convenient times without disrupting existing
programs.

<p>
Proposed ABI wording is in normal font; commentary is in italics.
Section numbers are from the Intel IA-64 psABI.

<p>
<hr>

<p>
<h3> Proposed gABI Changes </h3>

<p>
<h4> General Approach </h4>
<i>

<p>
The range of section indices from 0xff00 (SHN_LORESERVE) to
0xffff (SHN_HIRESERVE) is reserved for special purposes,
and the gABI already forbids real sections with these indices.
Our approach is to deal with situations where section indices cannot
be compatibly expanded to a full 32 bits
by using one of these indices as an escape value indicating that the
actual index will be found elsewhere.

</i>

<p>
<h4> 4.1 Elf Header </h4>
<i>

<p>
The ELF header has two relevant 16-bit fields:
e_shnum contains the section count,
and e_shtrndx the index of a string section.
We modify their descriptions to include an overflow indicator,
and put the actual values in the reserved section header at index 0
if necessary, as follows:
</i>

<dl>
<p>
<dt> <code>ElfXX_Half e_shnum;</code>
<dd>
This member holds the number of entries in the section header table.
Thus the product of <code>e_shentsize</code> and <code>e_shnum</code>
gives the section header table's size in bytes.
If a file has no section header table,
<code>e_shnum</code> holds the value zero.
<p>
If the number of sections is greater than
<code>SHN_LORESERVE</code> (<code>0xff00</code>),
this member has the value <code>SHN_XINDEX</code> (<code>0xffff</code>),
and the actual number of section header table entries is in the member
<code>sh_size</code> of the section header at index 0.
</dd>


<p>
<dt> <code>ElfXX_Half e_shstrndx;</code>
<dd>
This member holds the section header table index of the entry
associated with the section name string table.
If the file has no section name string table,
this member holds the value <code>SHN_UNDEF</code>.
See ``Sections'' and ``String Table'' below for more information.
<p>
If the section name string table index is greater than
<code>SHN_LORESERVE</code> (<code>0xff00</code>),
this member has the value <code>SHN_XINDEX</code> (<code>0xffff</code>),
and the actual index of the section name string table is in the member
<code>sh_link</code> of the section header at index 0.
</dd>

</dl>

<p>
<h4> 4.2 Sections </h4>
<i>

<p>
We define a new special section index as an escape value for
large section indices, as referenced above:
</i>

<dl>
<p>
<dt> <code>SHN_XINDEX (0xffff)</code>
<dd>
This special section index means, conventionally,
that the actual section index is too large to fit in the field
where it appears,
and is to be found in another location
(specific to the structure where it appears).
</dd>

</dl>

<p>
<i>
We note here that the section header contains two fields commonly used
to hold section indices, <code>sh_link</code> and <code>sh_info</code>,
but they are already defined as ElfXX_Word, and require no change.
</i>

<p>
<i>
A new section type is defined:
</i>

<dl>
<p>
<dt> <code>SHT_SYMTAB_SHNDX (17)</code>
<dd>
A section of this type is paired with an SHT_SYMTAB section,
if any of the symbols in that section reference a section index
larger than 16 bits.
It contains a table of 32-bit section indices,
one for each symbol in the symbol table section,
in the same order.
<p>
The <code>sh_link</code> field of this section contains the index of the
associated <code>SHT_SYMTAB</code> section.
</dd>

</dl>

<p>
<i>
A new special section name is defined:
</i>

<dl>
<p>
<dt> <code>.symtab_shndx</code>
<dd>
This section holds a section header index table for an associated
<code>.symtab</code> section.
The section's attributes will include the <code>SHF_ALLOC</code> bit
if the associated <code>.symtab</code> section does;
otherwise, that bit will be off.
</dd>

</dl>

<p>
<i>
There is no available field to point from the <code>.symtab</code> section
to its associated <code>.symtab_shndx</code> section,
so we use the <code>sh_link</code> field in the latter to point back.
It is recommended (but not required) that implementations place each
<code>.symtab_shndx</code> section immediately after its associated
<code>.symtab</code> section (in the section header table)
to make it easy for the linker to find.
</i>

<p>
<h4> 4.x Symbol Table </h4>
<i>

<p>
The symbol table is the most problematic.
It has no convenient location for an expanded section index.
Therefore, we propose that the escape value imply redirection to a
separate, parallel table containing full-size section indices.

<p>
Modify the definition of <code>st_shndx</code> as follows:
</i>

<dl>
<p>
<dt> <code>st_shndx</code>
<dd>
Every symbol table entry is defined in relation to some section.
This member holds the relevant section header table index.
<p>
As the <code>sh_link</code> and <code>sh_info</code> interpretation
table and the related text describe,
section indexes in the range 0xff00 to 0xffff indicate special meanings.
In particular, <code>SHN_XINDEX (0xffff)</code> indicates that the
real index is too large to fit in this field,
and must be found in the associated SHT_SYMTAB_SHNDX table (above).
</dd>

</dl>

<p>
If any of the <code>st_shndx</code> fields in a symbol table section
contain the value <code>SHN_XINDEX (0xffff)</code>,
there must be an associated <code>SHT_SYMTAB_SHNDX</code> section,
with a <code>sh_link</code> field containing the index of this
<code>SHT_SYMTAB</code> section.
That section contains an array of 32-bit section indices,
matching the symbol table entries 1-1 in the same order.
Entries corresponding to <code>SHN_XINDEX (0xffff)</code> values of
<code>st_shndx</code> in the symbol table must contain the actual
section header index to be used.
Others should contain either the correct section header index
(i.e. duplicating the value in <code>st_shndx</code>), or zero.

<p>
<i>
The .dynsym section in a linked object is completely analogous to a
.symtab section in a relocatable object,
and could be handled in the same way with the addition of a dynamic tag
to locate it.
We have not specified handling here because we expect the linking process
to remove most of the section duplication process which causes the problem,
e.g. leaving only a small number of .text sections.

</i>


<p>
<h4> Compatibility </h4>

<p>
<i>
There should be no compatibility impact on existing environments,
since only very large section counts require object file changes.
Individual vendors can postpone implementation until convenient,
with no impact on typical programs.

<p>
Note, however, that any ELF consumer applications that are currently
storing section indices as 16-bit values must change.

</i>

<p>
<font color=blue><hr><p>[991014 All]</font>
Jim Dehnert will push these proposals to the base ABI committee.

<p>
<font color=blue><hr><p>[991118 All]</font>
A class vtable will be emitted with the key function
(the first virtual function that is not inline
at the point of class definition),
if any.
If there is no key function,
it will be emitted in every compilation where used
(i.e. referred to by name).
It will be placed in a comdat group in all cases.
</td> </tr>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B6></a> <td> B-6 </td>
<td> Virtual function table layout </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991028 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What is the layout of the Vtable?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
See the ABI data layout document,
<a href=abi-layout.html#vtable>abi-layout.html</a>.
</td> </tr>

</table>

<p>
<font color=blue>[990624]</font>
Issue split from A-1.

<p>
<font color=blue>[990630 HP - Christophe]</font>

<p>
The current full proposal has been incorporated in the
<a href=abi-layout.html#vtable>ABI data layout document</a>.



<p>
<font color=blue>[990701 All]</font>
The above arrived to late for everyone to read it carefully.
It was agreed that we would consider it outside the meetings,
discuss any issues noted by email,
and attempt to close on 22 July.
(Christophe is on vacation until that week,
and Daveed leaves on vacation the next week.)

<p>
<font color=blue>[990811 SGI -- Jim]</font>
I've put a reworked version of Christophe's writeup in the
<a href=abi-layout.html#vtable>data layout document</a>,
along with a number of questions it raises.

<p>
<font color=blue>[990812 All]</font>
Extensive discussion of this issue produced the observations that
<ul>
<li> The number of virtual base offsets changes for vtables
    embedded in derived vtables.
<li> Therefore, one cannot reference one by a compile-time-constant
    offset from another (within the set associated with a type).
<li> Therefore, one cannot omit vfunc pointers from a derived vtable
    just because they appear in one of the base class vtables.
</ul>
Christophe will look at the implications of these observations.
Others should too.

<p>
<font color=blue>[990820 IBM -- Brian]</font>

<p>
<h5> Re: vtable layout, sharing vtable offsets </h5>
<p>
I'm going to write the exam on this to see how well I
am understanding the issue.

<p>
If I understand it correctly,
the proposal under consideration is tied to the decision to replicate
virtual function entries in vtables.
It requires replicating in the vtable for base class B all virtual functions
that are overridden in B; more replication that this implies will
be wasted since a function is always called through a vtable
of an introducing or overriding class.

<p>
When a non-pure virtual function X::f() is compiled it is possible to
determine whether it requires a secondary entry point.
It will require one if that function may be virtually called
(i.e., is the final overrider)
in any class in which f() appears in more than one vtable;
this needs to be decidable knowing only X.
A rule that works is: X::f() overrides one or more f()'s
from base classes of X,
and either one or more of those base classes are
virtual or X fails to share its vptr with all instances of them.

<p>
[Though a virtual base may happen to share its vptr with X
in an object of complete type X,
that relationship may fail to hold in further derived classes,
so we need to generate the secondary entry point just in case.]
["Sharing a vptr" is the condition under which no adjustment is necessary;
if the bases involved are all nonvirtual then
subsequent class derivation won't change this.]

<p>
Each vtable that requires a nonzero adjustment will have a
"convert to X" offset mixed in with its virtual base offsets.
 It is necessary that a "convert to X" appears in the same position in
each vtable that references X::f()'s secondary entry;
it is desirable that the "convert to X" also be unique in each vtable.

<p>
Assume that X has nonvirtual nonprimary bases Nx (x=1,2,...),
and virtual bases Vx, all of which have a virtual f().
Then vtables for Nx in X,
or in anyclass derived from X that does not further override f(),
will reference X::f()'s secondary entry.
Vtables for Vx in X or any derived class where Vx
does not share a vptr with X,
will also reference X::f()'s secondary entry;
note this will occur in a construction vtable even if the
derived class does further override f().

<p>
The question, then,
is whether a position for the "convert to X" offset can be chosen,
knowing only X and its parentage,
that can be used consistently in all those vtables and that won't
collide with a "convert to Y" position chosen on account of some other
hierarchy where Y::g() overrides an Nx::g() or Vx::g().

<p>
If Y derives from X,
we will be able to select a "convert to Y" position that doesn't conflict,
so we can restrict our attention to cases where X and Y are unrelated.
Also, if the base involved is nonvirtual (Nx) then we are safe,
because no instance of Nx will be a subobject of both X and Y,
so no Nx vtable will require both "convert to X" and "convert to Y" offsets.

<p>
The remaining case is where X and Y are unrelated but both have
a virtual base Vx:

<code><pre>
struct V1 { virtual void f();  virtual void g(); };
struct Other1 { virtual void ignore1(); }
struct X : Other1, virtual V1 { virtual void f(); }

struct Y : Other1, virtual V1 { virtual void g(); }

struct ZZ: X, Y { }
</pre></code>

<p>
The vtable for N1 in ZZ does require both offsets.
The only way I see to accomplish this is to preallocate
an adjustment slot for each virtual function in V1.
 That is, X::f() uses the first slot position, and Y::g() the second,
based on the order that f() and g() are declared in V1.
This only needs to be done in hierarchies where V1 is virtual,
but the same offset has to be used for any Nx tables in X too.

<p>
Is this close?

<p>
<h5>Re: Concatenating vtables</h5>
<p>
I don't understand the comment that varying numbers of virtual
base offsets make it impossible to concatenate vtables and refer
to them via a single symbol.
The only code that refers by name to X's vtable and the vtables
of N1 in X etc. is X's constructor and destructor,
and maybe some derived classes that find they are able to reuse some pieces.
All that code is aware of X's declaration and can map out its tables.
What am I missing?

<p>
<font color=blue>[990826 All]</font>
There is still considerable confusion about what will work.
Key questions are
(1) whether member functions can share offsets to base classes,
or each need their own; and
(2) when we need a no-this-adjustment override entry.

<p>
<font color=blue>[990901 SGI -- Jim]</font>
Being confused myself by all the discussion,
I've constructed a <a href=cxx-vtable-ex.html>new page</a>
containing (initially)
an example of a class hierarchy supplied by Christophe,
and attempted to identify possible function calls,
the class data layout,
and the class vtable layout based on Christophe's original proposal.
Please provide corrections,
and if you're proposing alternative vtable constructions,
describing them for this example might help (me, at least).
Also feel free to provide additional examples illustrating other points.

<p>
<font color=blue>[990930 Cygnus -- Jason]</font>
Jason has updated the Vtable layout description in
<a href=abi-layout.html>abi-layout.html</a>
to reflect the approach from Cygnus and IBM.

<p>
<font color=blue><hr><p>[991014 all]</font>
<ol>
<p>
<li>
Do we promote base offsets out of base class vtables?
Answer: we promote them out of virtual bases,
but we do not promote them out of nonvirtual bases.
It's a time/space tradeoff.
The time saving is large for virtual bases,
but too small to bother with for nonvirtual bases.

<p>
<li>
Do we have rtti fields for classes that have virtual bases but no
virtual functions?
The C++ standard regards such classes as nonpolymorphic,
so performing rtti operations on them is undefined.
Decision: we will keep the rtti fields themselves in the vtable, in
the interest of having a uniform vtable format.  The slot of offset to
beginning of complete type will be filled in, and the slot for offset
to typeinfo object will contain 0.

<p>
<li>
When we discussed issue B-8, we agreed that we would have an
offset to typeinfo object rather than a pointer to typeinfo object.
This means that the typeinfo object is now part of the vtable.
It will go at the very beginning,
i.e. at a negative offset from where the vtpr points.
(Comment: We discussed B-6 before discussing B-8.
Does making this change interfere with having a uniform vtable offset,
since we won't have a typeinfo object at the beginning of a vtable
for a nonpolymorphic class with virtual bases?
Should we revisit decision (2) or (3), or am I just being paranoid?)
</ol>

<p>
ACTION ITEMS: Jason---update writeup to reflect these three changes.
Our decision on issue B-8 will require a one-sentence change.
All of us: study the revised version.
We are almost ready to close this issue,
and if we agree with the revised version we can close it at the
21 October meeting.

<p>
<font color=blue><hr><p>[991028 all]</font>
It was agreed to accept the version currently in the
ABI data layout document,
<a href=abi-layout.html#vtable>abi-layout.html</a>.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> B-7 </td>
<td> Objects and Vtables in shared memory </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990624 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Is it possible to allocate objects in shared memory?
For polymorphic objects, this implies that the Vtable must also be
in shared memory.
</td> </tr>
<tr> <td colspan=7>
<b> Resolution </b>:
No special representation is useful in support of shared memory.
</td> </tr>

</table>

<p>
<font color=blue>[990624 All]</font>
Note that putting GP in the Vtable prevents putting it in shared memory.
This interacts with B-4.

<p>
<font color=blue>[990624 HP -- Cary]</font>
For a C++ object to be placed into shared memory,
its vtable pointer must be valid in all processes
that are sharing that object.

<ol>
<p>
<li>
If the vtable can be placed in text, that would be fine,
but the vtable contains function pointers (or descriptors)
that require runtime relocation, so it must be in data.

<p>
<li>
We can place the vtables in shared memory,
but only if the function pointers/descriptors are valid in all processes.
The entry point addresses, which refer to shared text, should be shareable,
but the gp values may not be identical for all processes.
(RTTI pointers are also an issue,
and could be solved by putting the RTTI information in shared memory as well.)

<p>
<li>
We can place the vtables in private memory,
provided they are at the same address in all processes.
</ol>

<p>
One way or another,
we need a way of ensuring that a pointer from shared 
memory to private memory is valid in all processes,
which means that we will need a means to ensure that certain shared
library data segments can get mapped at the same address in all
processes that load those certain libraries.

<p>
My wild idea a few years ago was to put the vtables in shared memory
(by allocating and building them at load time, as Taligent did),
and store a shared library index in place of the gp value
in each function descriptor.
Each process would have its own table of gp values,
indexed by this shared library index,
but the index space would be managed system-wide.
The C++ runtime library would have been responsible for allocating
a new index for each unique C++ shared library loaded on the system,
then storing the process-local copy of the gp pointer in the 
appropriate slot of the table.

<p>
<font color=blue>[990628 SGI -- Jim]</font>
Note a further problem with vtables in shared memory (Cary's point 2).
If a virtual function comes from another DSO,
it may be pre-empted differently in different programs.
Hence, the function pointer itself is a problem even if the GP isn't.

<p>
<font color=blue>[990701 All]</font>
An extensive discussion boiled down to a few points:
<ul>
<p>
<li> The primary issue is objects in shared memory --
    vtables aren't interesting in themselves, but rather because
    putting the object in shared memory implies having the vtable at
    the same address in all sharing processes.

<p>
<li> Many of us have a few customers asking for this.
    It is not clear just how extensive a facility they need,
    or how automatic it needs to be.
    We should attempt to gauge the need.

<p>
<li> Noone thinks we should penalize the non-shared case for
    the rare instances of shared demand.

<p>
<li> It is questionable whether we can define an ABI mechanism
    which will work on all of our systems,
    but we'd like not to preclude OS-specific extensions to do
    this if we can't.

<p>
<li> One possible approach would be an API allowing a user to
    place an object in shared memory,
    and then "install" it by setting its vtable pointers,
    possibly to copies also placed in the same shared memory.

<p>
<li> A more automatic approach would be something which allocated
    certain objects/vtables to shared memory,
    gave up at link time if not all pointers were internal to the
    object being linked,
    attempted to place the relevant segments at the same runtime
    addresses to allow sharing,
    and gave up on sharing if this was not possible.
    Such an approach would perhaps still require some care on the part
    of the user to prevent problematic runtime situations.
</ul>

<p>
These ideas are very fuzzy.
Participants should think about the need and possibilities and attempt
to identify more concrete approaches.

<p>
<font color=blue>[990805 All]</font>
It was determined (largely based on consideration by Jason)
that the only practical approach to putting objects in shared memory
is to force the objects, Vtables, functions, etc. to the same addresses
in the various processes involved.
If this is done, data representation issues are irrelevant.
Therefore, this issue is closed as moot.

<p>
Note that the base psABI defines a flag, EF_IA_64_ABSOLUTE,
which forces an executable object to the addresses specified in ELF,
so at least one method of representing this is already available.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B8></a> <td> B-8 </td>
<td> dynamic_cast </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990628 </td>
<td> 991014 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What information to we put in the vtable to enable (a) dynamic_cast
from pointer-to-base to pointer-to-derived (including detection of
ambiguous base classes) and (b) dynamic_cast to void*?
</td> </tr>
<tr> <td colspan=7>
<b> Resolution </b>:
The vtable will contain an offset to the beginning of the complete object,
and a pointer to the typeinfo object.
</td> </tr>

</table>

<p>
<font color=blue>[990701 All]</font>
This should be part of the proposal Daveed will put together
by the 15th (action #13); the group will discuss it on the 22nd.

<p>
<font color=blue>[990812 Sun -- Michael]</font>
Sun has provided a description,
<a href=Sun-RTTI-990812.html>in a separate page</a>,
describing their implementation.
They are filing for a patent on the algorithms described.

<p>
<font color=blue>[991014 All]</font>
This is closely related to issues A-6 and B-6.
It is agreed that what we need is an offset to the beginning of
the complete object, and a pointer or offset to the typeinfo object.
We choose to have an offset to the typeinfo object instead of a pointer,
which effectively means that the typeinfo object is part of the vtable.
We will put it at the very beginning, at a negative offset from the vptr.

<p>
<font color=blue>[991027 SGI -- Matt]</font>
At the October 14 meeting we decided to include RTTI information as
part of the vtable block, and to include an offset to RTTI information
in the vtable rather than a pointer to RTTI information.  (We decided
on this change so that we would have fewer symbols to resolve at link
time.)

<p>
Jim came up with a serious objection at the October 21 meeting:
during construction we need different RTTI information at different
points.  A few of us talked about this at Kona, and my impression is
that Jim's objection is fatal.  We could imagine having base class
typeinfo objects in every vtable block, but (1) this would kill any
performance advantage we'd get by using an offset rather than a
pointer; and (2) we'd lose the ability to use simple pointer identity
as a way of telling whether two typeinfos represent the same type.

<p>
I propose that we abandon that decision, and go back to using pointers.
Does everyone agree?

<p>
<font color=blue>[991028 All]</font>
Agreed.



<p> <hr> <p>
<h3> C.  Object Construction/Destruction Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C1></a> <td> C-1 </td>
<td> Interaction with .init/.fini </td>
<td> lif ps </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991202 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Static objects with dynamic constructors must be constructed at
intialization time.
This is done via the executable object initialization functions that
are identified (in ELF) by the DT_INIT and DT_INIT_ARRAY dynamic tags.
How should the compiler identify the constructors to be called in this way?
One traditional mechanism is to put calls in a .init section.
Another, used by HP, is to put function addresses in a .init_array section.
<p>
The dual question arises for static object destructors.
Again, the extant mechanisms include putting calls in a .fini section,
or putting function addresses in a .fini_array section.
<p>
Finally, which mechanism (DT_INIT or DT_INIT_ARRAY, or the FINI versions)
should be used in linked objects?
The gABI, and the IA-64 psABI, will support both,
with DT_INIT being executed before the DT_INIT_ARRAY elements.
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Use .init_array and .fini_array sections.
</td> </tr>

</table>

<p>
<font color=blue>[991202 All]</font>
It was decided to use the array forms for all required initialization
or finalization entries,
i.e. to put initialization entries into .init_array sections with ELF
section type SHT_INIT_ARRAY,
and finalization entries into .fini_array sections with ELF
section type SHT_FINI_ARRAY.
The static linker will combine them,
and identify them to the dynamic linker using DT_INIT_ARRAY,
DT_INIT_ARRAYSZ, DT_FINI_ARRAY, and DT_FINI_ARRAYSZ dynamic tags.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C3></a> <td> C-3 </td>
<td> Order of ctors/dtors w.r.t. DSOs </td>
<td> ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> reopened </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Given the constructor/destructor calls for each executable object
comprising a program, what is the order of execution between objects?
For constructors, there is not much question:
unless we choose some explicit means of control,
file-scope objects will be initialized by the DT_INIT/DT_INITARRAY
functions in the order determined by the base ABI order rules,
and local objects will be initialized in the order their containing
scopes are entered.
<p>
For destructors, the Standard requires opposite-order destruction,
which implies a runtime structure to keep track of the order.
Furthermore, the potential for dynamic unloading of a DSO
(e.g. by dlclose)
requires a mechanism for early destruction of a subset.
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Accept SGI proposal for a simple API which registers destructors and
atexit calls.
</td> </tr>

</table>

<p>
<font color=blue><hr><p>[990804 SGI -- Jim]</font>
<h4> Proposal </h4>

<p>
My objectives are:
<ul>
<li> Simple library interface.
<li> Efficient handling during construction.
<li> Standard-conforming treatment during normal program exit.
<li> Reasonable treatment during early DSO unload (e.g. dlclose).
<li> Minimal dynamic and static linker impact.
</ul>

<p>
<h5> Runtime Data Structure </h5>

<p>
The runtime library shall maintain a list of termination functions
with the following information about each:

<ul>
<li> A function pointer (a pointer to a function descriptor on IA-64).
<li> A void* operand to be passed to the function.
<li> A void* handle for the <i>home DSO</i> of the entry (below).
</ul>

<p>
The representation of this structure is implementation defined.
All references are via the API described below.

<p>
<h5> Runtime API </h5>

<ol type=A>
<p>
<li> Object construction:
<p>
When a global or local static object is constructed,
which will require destruction on exit,
a termination function is <i>registered</i> as follows:
<center><code>
int __cxa_atexit ( void (*f)(void *), void *p, dso_handle d );
</code></center>
This registration, e.g. <code>__cxa_atexit(f,p,d)</code>,
is intended to cause the call <code>f(p)</code> when DSO d is unloaded,
before all such termination calls registered before this one.
It returns zero if registration is successful, nonzero on failure.
<font color=red>Should we use exceptions instead?</font>

<p>
The registration function is called separate from the constructor.

<p>
<li> User atexit calls:
<p>
When the user registers exit functions with <code>atexit</code>,
they should be registered with NULL parameter and DSO handle, i.e.
<center><code>
__cxa_atexit ( f, NULL, NULL );
</code></center>
It is expected that implementations supporting both C and C++ will
integrate this capability into the libc <code>atexit</code>
implementation, so that C-only DSOs will nevertheless interact with C++
programs in a C++-standard-conforming manner.
No user interface to __cxa_atexit is supported,
so the user is not able register an <code>atexit</code> function with a
parameter or a home DSO.
</font>

<p>
<li> Termination:
<p>
When linking any DSO containing a call to <code>__cxa_atexit</code>,
the linker should define a hidden symbol <code>__dso_handle</code>,
with a value which is an address in one of the object's segments.
(It doesn't matter what address,
as long as they are different in different DSOs.)
It should also include a call to the following function in the FINI
list (to be executed first):
<center><code>
void __cxa_finalize ( dso_handle d );
</code></center>
The parameter passed should be <code>__dso_handle</code>.

<p>
Note that the above can be accomplished either by explicitly providing
the symbol and call in the linker, or by implicitly including a
relocatable object in the link with the necessary definitions,
using a .fini_array section for the FINI call.
Also, note that these can be omitted for an object with no calls to
<code>__cxa_atexit</code>, but they can be safely included in all objects.

<p>
Finally, a main program should be linked with a FINI call to
<code>__cxa_finalize</code> with NULL parameter.

<p>
When <code>__cxa_finalize(d)</code> is called,
it should walk the termination function list,
calling each in turn if <code>d</code> matches
<code>__dso_handle</code> for the termination function entry.
If <code>d == NULL</code>, it should call all of them.
Multiple calls to <code>__cxa_finalize</code> should not result in
calling termination function entries multiple times;
the implementation may either remove entries or mark them finished.

<p>
<font color=red>
Issue: By passing a NULL-terminated vector of DSO handles to
<code>__cxa_finalize</code> instead of one,
we could deal with unloading multiple DSOs at once.
However, <code>dlclose</code> closes one at a time,
so I'm not sure the extra complexity is worthwhile.
</font>

</ol>

<p>
Since <code>__cxa_atexit</code> and <code>__cxa_finalize</code>
must both manipulate the same termination function list,
they must be defined in the implementation's C++ runtime library,
rather than in the individual linked objects.


<p>
<font color=blue><hr><p>[991202 All]</font>
The proposal above is accepted, with three changes (integrated above):
<ul>
<p>
<li> The "__cxx_" prefixes are changed to "__cxa_".
    This matches the prefix chosen for the exception handling API,
    and stands (loosely) for "C++ ABI".
<p>
<li> Clarify that integration into the C libc library is expected.
<p>
<li> Clarify that no user interface to 
    <code>__cxa_atexit</code> is supported.
</ul>

<p>
During discussion, it was noted that this proposal will not deal
effectively with DSOs which (a) have cross-DSO destructor interactions
and (b) are unloaded dynamically.
It is generally believed that such code would not reliably work on a
variety of platforms today,
and is not a robust methodology worthy of ABI support.
However, note that if it becomes an issue,
it would be possible to define a <code>__cxa_finalize</code> analog
which takes a list of DSOs instead of a single DSO,
and if the program or dynamic linker identifies a set of DSOs to be
unloaded together, run their finalization entries in a single pass
instead of one DSO at a time.


<p>
<font color=blue><hr><p>[991215 CodeSourcery -- Mark]</font>
Note that the type of "__dso_handle" above is not specified.
Since the simplest implementation is for the static linker to resolve
it into an arbitrary address in the DSO, define it as "void *".


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C5></a> <td> C-5 </td>
<td> Calling destructors </td>
<td> call </td>
<td> closed </td>
<td> Sun </td>
<td> 990603 </td>
<td> 991104 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What is the calling convention for destructors?
Do virtual destructors require special treatment?
Is delete() integrated with the destructor call or separate?
How is delete() handled when invoked on a base subobject?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Destructors are called with a reference to <i>this</i>.
Virtual destructors have two versions, and two entries in the vtable,
one that deletes the object after destruction, and one that doesn't.
There is a third version that does not delete the object,
and is not in-charge, i.e. does not destroy any base objects;
it is not called via the vtable.
</td> </tr>

</table>

<p>
<font color=blue>[990729 all]</font>
Some implementations combine destructors with deletion,
checking a flag in the destructor to determine whether to delete.
This produces somewhat less code,
especially if there are many delete() calls.
However, it adds overhead to any destructor which does not require
deletion, e.g. base and member objects, automatic objects.
There is some concern that a runtime test is sometimes required,
but noone has yet identified why.

<p>
<font color=blue>[990819 Cygnus -- Jason]</font>
The [above] questions the usefulness of calling op delete from the destructor.
But it's required by the language,
in case the derived class defines its own op delete.
This only applies to virtual dtors, of course.

<p>
One option would be to have two dtor slots, one which performs deletion
and one which doesn't.
The advantage of this sort of approach would be avoiding pulling in all
the memory management code if you never actually touch the heap.

<p>
Microsoft has a patent on this device,
but the old Sun ABI also talks about it,
which seems to qualify as prior art.

<p>
<font color=blue>[991014 all]</font>
One solution to the problem with destructors is to have
two destructor entry points, and two destructor slots in the vtable.
One entry point destroys the object and then calls operator delete,
the other destroys the object without calling operator delete.
We can use a similar solution for constructors
(but without any impact on the vtable layout):
one entry point for constructing a complete object,
another for constructing a subobject.

<p>
Note that one of the entry points may call the other, but that's not
an ABI issue and can be left to individual implementors.

<p>
There was general agreement that this is a promising idea.
We don't have a detailed proposal yet.
HP is working on a prototype implementation.
Christophe will submit a writeup.

<p>
<font color=blue><hr><p>[991028 all]</font>
There are two options in destructors:
<ul>
<li> Whether or not <code>delete()</code> is called.
<li> Whether or not the destructor is <i>in-charge</i>,
     i.e. calls the destructor for virtual bases.
</ul>
Since only the most-derived object calls <code>delete()</code>,
and only the most-derived object does destruction for virtual bases,
only three of the possible combinations arise:
<ul>
<li> No <code>delete()</code>, not in-charge.
<li> No <code>delete()</code>, in-charge.
<li> Call <code>delete()</code>, in-charge.
</ul>
The first will be called for a base object when a derived object is
being destroyed,
and one of the other two for the most-derived object.
Therefore, for any particular vtable,
no more than two will be required.
A vtable for a class with virtual destructors will contain two
destructor entries, delete and no-delete,
and they will both be the in-charge versions for the most-derived class
in the structure.
The no-delete, not in-charge destructors may be called from those,
but always directly,
so a global name is required but no vtable entry.

<p>
We distinguish the delete/no-delete cases by distinct entrypoints,
so only a <code>this</code> parameter is required,
and the standard calling conventions are used.
The only special treatment of virtual destructors is the pair of vtable
entries described above.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C6></a> <td> C-6 </td>
<td> Extra parameters to constructors </td>
<td> call </td>
<td> closed </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> 991104 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
When calling constructors for classes with virtual bases,
what information about the treatment of virtual base subobjects
in the full class, or about object allocation,
must be transmitted to the constructor in parameters?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
None.
Two versions, and two entrypoints,
of the constructor will be created:
one that calls the virtual base subobject constructor (in-charge),
and one that does not.
Object allocation will be done by the caller.
</td> </tr>

</table>

<p>
<font color=blue>[991028 all]</font>
We will produce two constructor entries,
one in-charge (constructing virtual bases) for a most-derived object,
and one not in-charge for a base subobject.
The object allocation will be the responsibility of the caller,
so there will be no variation or parameters for that purpose.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> C-7 </td>
<td> Passing value parameters by reference </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 990624 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It may be desirable in some cases where a type has a non-trivial
copy constructor to pass value parameters of that type by performing
the copy at the call site and passing a reference.
</td> </tr>
<tr> <td colspan=7>
<b> Resolution </b>:
Whenever a class type has a non-trivial copy constructor,
pass value parameters of that type by performing
the copy at the call site and passing a reference.
</td> </tr>

</table>

<p>
<font color=blue>[990701 All]</font>
Daveed and Matt will attempt to pin down the copy requirements with the
Core committee, i.e. when a non-trivial copy constructor may be elided.
The relevant Standard requirement is 12.8/15,
and there is an open defect report related to this question.
For cases where the ctor may not be elided,
we expect to perform the copy at the call site,
and pass a reference.

<p>
<font color=blue>[990729 All]</font>
Matt will produce a clear proposal for when the ABI will elide the
constructor (and therefore pass the class object like a normal C struct),
based on the Standard's exceptions.

<p>
<font color=blue>[990805 All]</font>
There are no cases where a non-trivial copy constructor can be simply
elided for all instances of a particular parameter.
Therefore, we shall use the consistent convention that,
if a value parameter's (class) type has a non-trivial copy constructor,
the caller will allocate space for it, perform the copy,
and pass a reference.

<p>
Note that the standard does allow the caller,
if the value being passed is a temporary,
to construct the temporary directly into the parameter memory
and elide the copy constructor call.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> C-8 </td>
<td> Returning classes with non-trival copy constructors </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 990625 </td>
<td> 990722 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How do we return classes with non-trivial copy constructors?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
The caller allocates space,
and passes a pointer as an implicit first parameter
(prior to the implicit <i>this</i> parameter).
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C9></a> <td> C-9 </td>
<td> Passing parameters with ctors/dtors </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 991028 </td>
<td> 991104 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where do allocation, construction, destruction, and deallocation occur
for value parameters?
</td> </tr>
<tr> <td colspan=7>
<b>Summary</b>:
See the description in the
<a href=cxx-closed.html#C9>closed issues list</a>.
</td> </tr>

</table>

<p>
<font color=blue>[991028 all]</font>
For value parameter types with a non-trivial copy constructor or destructor,
a call handles the parameter as follows:
<ol>
<p>
<li>
Space is allocated in the caller for the temporary.
If there is no non-trivial copy constructor,
it is in the normal parameter-passing space (registers/stack);
otherwise it is allocated on the stack or heap.

<p>
<li>
The caller constructs the parameter in the space allocated,
a simple copy to parameter space if there is no non-trivial copy constructor.

<p>
<li>
The function is called, passing the parameter value
(if no non-trivial copy constructor),
or its address (if there is a non-trivial copy constructor).

<p>
<li>
The callee calls any non-trivial destructor for the parameter before
returning.
(Note that, if there is no non-trivial copy constructor,
this implies that the parameter was copied out of registers on
entry so the destructor can be called with <code>this</code> in memory.)

<p>
<li>
If necessary (e.g. if the parameter was allocated on the heap),
the caller deallocates space after the return.

</ol>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C10></a> <td> C-10 </td>
<td> Synthesized copy assignments </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 991028 </td>
<td> 991028 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Should we specify special treatment for synthesized copy assignments,
to avoid multiple copies of virtual bases?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
No.
</td> </tr>

</table>

<p>
<font color=blue>[991028 all]</font>
For classes with virtual bases,
the Standard allows a synthesized copy assignment to copy the virtual
bases multiple times, but does not require it.
The simplest approach, recursively copying the base objects,
will cause multiple copies for virtual bases with multiple inheritance
paths.
This can be avoided by synthesizing a second copy assignment operator
which does not copy virtual bases, to be called when assigning a subobject.

<p>
The decision was made not to do so,
on grounds that the situation is rare,
and virtual bases are often empty besides,
so that the solution is not worth the resulting code bloat.

<p> <hr> <p>
<h3> D.  Exception Handling Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D4></a> <td> D-4 </td>
<td> Unwind routines nested? </td>
<td> lib ps </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991209 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA-64 runtime conventions call for the unwind personality routine
to behave like a routine nested in the routine raising an exception.
Is that the preferred definition?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
This is not required, nor included in the proposed common implementation.
However, a conforming implementation could add this option in the
personality routine and tables.
</td> </tr>

</table>

<p>
<font color=blue>[990902 All]</font>
Discussion reveals that Intel and HP have very different models of how
cleanup actions are handled.

<p>
Intel builds one or more routines which are called from the unwind runtime,
based on action descriptors in the unwind tables,
and acting on the stack contents or objects to be destroyed
without actually modifying the stack pointer until the final transfer
of control to the user handler.
This approach avoids actually restoring registers until the final
transfer to the handler.

<p>
HP transfers control back to a user landing pad whenever anything needs
to be done -- descriptors or handlers --
and reenters the unwind runtime if further processing is required.
They believe this approach to use much less space than the action
descriptors would,
and most importantly,
that it allows arbitrary fixup for code motion around the call that throws.

<p>
<font color=blue>[991209 All]</font>
An implementation can conform with the proposed C++ personality routine
interface and either support or not support nested handlers --
the only requirement is that the generated personality tables and
routine collaborate.
The
<a href=http://reality.sgi.com//dehnert_engr/cxx/exceptions.pdf>
proposed common EH interface from HP</a>
does not use nested functions as handlers,
but could easily be extended.

<p>
This issue is closed, with the immediate resolution of changing the
base unwind ABI to <b>not</b> require nested function handlers.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D5></a> <td> D-5 </td>
<td> Interaction with other languages (e.g. Java) </td>
<td> lib ps </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 991007 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA64 exceptions handling framework is largely language independent.
What is the behaviour of a C++ runtime receiving, for instance,
an exception thrown from Java?
Does it call terminate()?
Does it allow the exception to pass through C++ code with destructors
if there is no catch clause?
Does it allow the exception to be caught in a catch(...) provided this
catch(...) ends with a rethrow?
Does it allow even more?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
In general, foreign exceptions will cause normal destructor invocation
and other cleanup in C++ code, and will pass through C++ frames except
where explicit exception specifications do not allow them.
</td> </tr>

</table>

<p>
<font color=blue>[990908 SGI -- Jim]</font>
We propose that this be resolved by identifying the source language in
the exception descriptor and specifying that the personality routine be
able to perform cleanup actions during handling of foreign-language
exceptions, but not attempt to catch them.

<p>
<font color=blue>[991006 All]</font>
The concensus of the group,
from the discussion of the low-level exception API, is:
<ul>
<p>
<li>
A foreign-language exception,
passing through a C++ frame,
will cause normal destructor invocations exactly as a C++ exception would.
<p>
<li>
Since catch(...) is commonly used as a cleanup mechanism (with a rethrow)
rather than as a true catch,
it is appropriate to catch and rethrow even foreign-language exceptions.
<p>
<li>
Function exception specifications present a more complex issue.
A foreign exception will generally not match any of the specified
allowed exceptions
(though implementations might deal with special cases).
For consistency, it is expected that a foreign exception will be
caught by a throw specification and not passed through,
i.e. that unexpected() will be called.

</ul>

<p>
<font color=blue>[991007 All]</font>
In addition to the above,
Christophe will define an exception __foreign_exception to be used
by foreign-language code which wants to raise an exception that C++ can
catch.
<p>
Close this issue.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D6></a> <td> D-6 </td>
<td> Allow resumption in other languages? </td>
<td> lib ps </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 991007 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The exception handling framework requires the interaction of the
runtime of all the languages "on the stack" during exception processing.
Some of these languages may have very different exception handling semantics.
What are the constraints we impose on the C++ exception handling runtime
to preserve the relative language neutrality of the EH framework?
Example: do we allow a handler to cleanup and resume at the point
where the exception was thrown?
</td> </tr>
<b>Resolution</b>:
Moot -- resume-type exceptions are more appropriately handled by
registering trap handlers and processing them in place.
No interaction with stack traceback should be necessary.
</td> </tr>

</table>

<p>
<font color=blue>[990908 SGI -- Jim]</font>
The typical case of cleanup and resume is floating point trap handling,
which is normally handled entirely in the original FP trap handler.
Is there an example where stack walkback must occur to identify the
handler, but resumption at the point-of-exception is required?
I can't think of any, and I think the model of registering a trap
handler is preferable for such purposes.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D7></a> <td> D-7 </td>
<td> Interaction with signals or asynch events </td>
<td> lib ps </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 991209 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The Standard says that the behavior of anything other than
"pure C code" (POF) is implementation defined,
and warns (in a note) against using EH in a signal handler.
We should define what is supported,
possibly explicitly stating that signal handler code must be a POF.
We could allow any feature but exception handling to be used.
We could allow some EH routines to be called
(for instance, <code>uncaught_exception()</code>).
Or we could allow even an exception to be thrown,
if it does not exit the handler.
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
This ABI requires no support beyond the Standard requirements.
</td> </tr>

</table>

<p>
<font color=blue>[991006 All]</font>
This common ABI will not allow throwing exceptions from a signal handler.

<p>
<font color=blue>[991007 All]</font>
There remains concern about how to help customers
(examples were presented of big database applications)
for which raising exceptions from signal handlers for I/O failures
is a highly desirable design.
We will revisit this issue.

<p>
<font color=blue>[991209 All]</font>
Further discussion clarified the situation.

<p>
The fundamental problem is that signals thrown from a signal handler
(or otherwise asynchronously)
may appear at arbitrary points in the program,
where the unwind information is inadequate to reliably clean up,
for instance because global variable updates have been moved across the
point of exception.

<p>
A second problem is that signals are often processed on their own stack,
and making the transition to the main user stack might not happen
automatically.

<p>
As a result, it was generally agreed that dealing with exceptions
raised asynchronously would require simply passing through the
immediately enclosing stack frame (to avoid the first problem),
and a special raise invocation (as a basis for addressing both).

<p>
However, the only customer that has been adamant about supporting
asynchronous exceptions has also been adamant that such a partial
solution would not be adequate.
Their intended application involves raising the exception in a simple
routine that they expect to be inlined (for performance reasons)
directly into a try block,
which would be bypassed by the proposed solution.
Since making this work would involve significant performance penalties
elsewhere, the group's concensus is that there is inadequate benefit
from an attempted solution.


<p> <hr> <p>
<h3> E.  Template Instantiation Model Issues </h3>

<p> <hr> <p>
<h3> F.  Name Mangling Issues </h3>

<p> <hr> <p>
<h3> G.  Miscellaneous Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=G3></a> <td> G-3 </td>
<td> Inlined routine linkage </td>
<td> call </td>
<td> closed </td>
<td> Sun </td>
<td> 990603 </td>
<td> 991202 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Inline routines with external linkage require a method of handling
vague linkage (see B-5 for definition) for the out-of-line instance,
as well as for any static data they contain.
The latter includes string constants per [7.1.2]/4.
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Out-of-line instances are emitted where required,
using COMDAT (issue B-5).
Static data referenced will be placed in COMDAT sections as well.
The names of each are addressed as part of mangling (issue F-1).
Strings will be emitted in SHT_MERGE/SHT_STRING sections,
with the static linker responsible for removing duplicates.
</td> </tr>

</table>

<p>
<font color=blue>[990624 Cygnus -- Jason]</font>
How should we handle local static variables in inlines?
G++ currently avoids this issue by suppressing
inlining of functions with local statics.
If we don't want to do that,
we'll need to specify a mangling for the statics,
and handle multiple copies like we do above.

<p>
<font color=blue>[990721 Cygnus -- Jason]</font>
[We should emit inline routines]
in translation units where an out-of-line copy is needed.
I am opposed to emitting the inlines with the vtable,
for two reasons:
<ul>
<li>
One of our users defines a proxy class whose implementation is not
exported from the shared library where it is defined;
the API for the class consists of virtual functions,
accessible through the vtable, and inline functions.
They complained that since g++ currently emits inlines along with the vtable,
their code would only link if inlining was enabled.
<p>
<li>
Often, we will need no copies of an inline function.
</ul>

<p>
<font color=blue>[991118 All]</font>
We discussed linkage of static locals in inline functions.
The C++ standard requires that there be only a single object
in the entire program,
i.e. the static locals in different translation units must be merged.
Two cases: string literals and everything else.
"Everything else" is believed to be a rare and unimportant case.
We'll just give the static locals mangled names,
and put them in comdat groups.
String literals are believed to be common,
and mangled names in COMDAT is too heavyweight.
The base ABI provides an optional mechanism for
merging all copies of a given string literal.
We would like to make this mechanism mandatory,
so that string literals in inline functions get merged automatically.

<p>
<font color=blue>[991202 All]</font>
The use of the new SHT_MERGE/SHT_STRING attributes,
requiring the static linker to do the merging,
was decided to be a suitable solution.
It was noted that this will not provide merging across DSOs,
but this is not considered a problem.
An implementation may overcome this by naming the strings
and invoking dynamic linker name preemption,
at the cost of additional dynamic link time.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=G5></a> <td> G-5 </td>
<td> Varargs routine interface </td>
<td> call </td>
<td> open </td>
<td> HU-B </td>
<td> 990810 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The underlying C ABI defines conventions for calling varargs routines.
Does C++ need, or would it benefit from, any modifications or special cases?
How should we pass references or class objects?
Is any runtime library support required?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
No special cases required -- C++ will follow the C varargs ABI.
</td> </tr>

</table>

<p>
<font color=blue>[990810 HU-B Martin]</font>
I'd like to see an indirection in vararg lists,
so they can be passed through thunks.
This is necessary at least for the covariant returns,
but might have other applications as well.

<p>
<font color=blue>[990810 HU-B Martin]</font>
Since there already was the decision not to return a list of
pointers from a covariant method,
the only alternative to real thunks
is code duplication (as done in Sun Workshop 5).
<i>(Or alternate entrypoints...  Jim)</i>

<p>
With real thunks, you have to copy the argument list.
That is not possible for a varargs list,
so here is my proposal for varargs in C++:

<p>
In the place of the ellipsis, a pointer to the first argument is passed.
In case of a thunk for covariant returns,
this pointer can be copied to the destination function.
The variable arguments are put on the stack as they normally would.

<p>
With that, the issue is in which cases to use such a calling
convention:
<ol>
<li> only for vararg calls to virtual methods, or
<li> only for vararg calls to functions with C++ linkage, or
<li> for all vararg calls.
     That would probably require a change to the C ABI
</ol>
<p>
Option (1) could be further restricted to methods returning a pointer
or reference to class type. 

<p>
<font color=blue>[990812 All]</font>
In response to a question,
it was observed that passing one variant of a class hierarchy in a
varargs list and referencing another variant in the va_arg macro is undefined,
and we don't need to worry about a mechanism for doing the conversion.

<p>
<font color=blue>[991014 All]</font>
We would want to reject option (3),
even if it were still possible to change the base ABI.
The present scheme is compatible with K&R C methods,
the proposed change would not be.

<p>
Decision: Close with no action.
We're using multiple entry points for covariant return types, not thunks,
so there's no need for doing anything different for varargs functions
with covariant return types than for any other varargs functions.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=G6></a> <td> G-6 </td>
<td> bool parameters </td>
<td> call </td>
<td> closed </td>
<td> all </td>
<td> 991104 </td>
<td> 991202 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How should we pass bool parameters on IA-64?
Choices are to pass them like ABI ints,
or in predicate registers or register pairs.
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
No special treatment -- pass bool like char.
</td> </tr>

</table>

<p>
<font color=blue>[991202 All]</font>
It was decided not to treat bool parameters specially,
i.e. they will be passed like chars.


<p> <hr> <p>
<h3> H.  Library Interface Issues </h3>

<p>
<hr>

<p>
Please send corrections to <a href=mailto:dehnert@sgi.com>Jim Dehnert</a>.

</BODY>
</HTML>
