<HTML>

<HEAD>
<title>C++ ABI for IA-64: Exception Handling</title>

<link rel=stylesheet href=small-table.css type="text/css">
<link rel=stylesheet href=code.css type="text/css">

<hr>

<font size=6><i><b>
<p>
C++ ABI for IA-64: Exception Handling
</b></i></font>

<font size=-1>
<p>
<i>Revised 7 July 2000.
<a href=#revisions>Revision history</a> at end of document.
</i>

</center>

</HEAD>

<BODY>


<p> <hr> <p>
<h3> Contents </h3>

<ul>
<li> <a href=#intro> Introduction </a>
  <ul>
  <li> <a href=#defs> Definitions </a>
  </ul>
<li> <a href=#layout> Level I: Base ABI </a>
  <ul>
  <li> <a href=#base-framework>	1.1 Exception Handler Framework </a>
  <li> <a href=#base-data>	1.2 Data Structures </a>
  <li> <a href=#base-throw>	1.3 Throwing an Exception </a>
  <li> <a href=#base-om>	1.4 Exception Object Management </a>
  <li> <a href=#base-context>	1.5 Context Management </a>
  <li> <a href=#base-personality> 1.6 Personality Routine </a>
  </ul>
<li> <a href=#cxx-abi> Level II: C++ ABI </a>
  <ul>
  <li> <a href=#cxx-intro>	2.1 Introduction </a>
  <li> <a href=#cxx-data>	2.2 Data Structures </a>
  <li> <a href=#cxx-init>	2.3 Standard Runtime Initialization </a>
  <li> <a href=#cxx-throw>	2.4 Throwing an Exception</a>
  <li> <a href=#cxx-catch>	2.5 Catching an Exception</a>
  <li> <a href=#cxx-aux>	2.6 Auxiliary Runtime APIs</a>
  </ul>
<li> <a href=#cxx-abi> Level III: Implementation </a>
  <ul>
  <li> <a href=#imp-intro>	3.1 Introduction </a>
  <li> <a href=#imp-data>	3.2 Data Structures </a>
  </ul>
<li> <a href=#revisions> Appendix R: Revision History</a>
</ul>


<p> <hr> <p>
<a name=intro></a>
<h3> Introduction </h3>

In this document, we define the C++ exception handling ABI,
at three levels:
<ol type=I>
<li> the <a href=#base-abi>base ABI</a>,
    interfaces common to all languages and implementations;
<li> the <a href=#cxx-abi>C++ ABI</a>,
    interfaces necessary for interoperability of C++ implementations; and
<li> the specification of a particular runtime implementation.
</ol>

<p>
This specification is based on the general model described roughly in the
<a href=http://developer.intel.com/design/ia64/devinfo.htm>
64 Bit Runtime Architecture and Software Conventions for IA-64</a>,
Intel document SC - 2791, Rev. No. 2.4E.
However, the Level I (base ABI) specification here contradicts that
document in some particulars,
and is being proposed as a modification.
That document describes a framework which can be used by an arbitrary
implementation, with a complete definition of the stack unwind mechanism,
but no significant constraints on the language-specific processing.
In particular, it is not sufficient to guarantee that two object files
compiled by different C++ compilers could interoperate,
e.g. throwing an exception in one of them and catching it in the other.

<p>
In Section I below, we will elaborate missing details from this base
document, largely in the form of specifying the APIs to be used in
accessing the language-independent stack unwind facilities,
namely the unwind descriptor tables and the personality routines.
This specification should be implemented by any IA-64 psABI-compliant
system.

<p>
In Section II below, we will specify the API of the C++ exception
handling facilities, specifically for raising and catching exceptions.
These APIs should be implemented by any C++ system compliant with the
IA-64 C++ ABI.
<i>Note that the level II and level III specifications are not
completed at this time.</i>


<p> <hr> <p>
<a name=defs></a>
<h3> Definitions </h3>

<p>
The descriptions below make use of the following definitions:

<dl>
<p>
<dt><b><i>landing pad</i></b></dt>:
<dd> 
A section of user code intended to catch, or otherwise clean up after,
an exception.
It gains control from the exception runtime via the personality routine,
and after doing the appropriate processing either merges into the
normal user code or returns to the runtime by resuming
or raising a new exception.

</dl>


<p> <hr> <p>
<a name=base-abi></a>
<h3> Level I. Base ABI </h3>

<p>
This section defines the Unwind Library interface,
expected to be provided by any IA-64 psABI-compliant system.
This is the interface on which the C++ ABI exception-handling
facilities are built.
We assume as a basis the unwind descriptor tables described in the base
<a href=http://developer.intel.com/design/ia64/devinfo.htm>
Software Conventions</a> document.
Our focus here will on the APIs for accessing those structures.

<p>
It is intended that nothing in this section be specific to C++,
though some parts are clearly intended to support C++ features.

<p>
The unwinding library interface consists of at least the following
routines:
<code><pre>
  _Unwind_RaiseException,
  _Unwind_Resume,
  _Unwind_DeleteException,
  _Unwind_GetGR,
  _Unwind_SetGR,
  _Unwind_GetIP,
  _Unwind_SetIP,
  _Unwind_GetRegionStart,
  _Unwind_GetLanguageSpecificData,
  _Unwind_ForcedUnwind
</pre></code>

In addition, two datatypes are defined
(<code>_Unwind_Context</code> and <code>_Unwind_Exception</code>)
to interface a calling runtime (such as the C++ runtime)
and the above routines.
All routines and interfaces behave as if defined
<code>extern "C"</code>.
In particular, the names are not mangled.
All names defined as part of this interface have a
"<code>_Unwind_</code>" prefix.

<p>
Lastly, a language and vendor specific personality routine will be stored
by the compiler in the unwind descriptor for the stack frames requiring
exception processing.
The personality routine is called by the unwinder to handle
language-specific tasks such as identifying the frame handling a
particular exception.

<p>
<a name=base-framework></a>
<h4> 1.1  Exception Handler Framework </h4>

<p>
<h5> Reasons for Unwinding </h5>

<p>
There are two major reasons for unwinding the stack:
<ul>
<li> exceptions, as defined by languages that support them (such as C++)
<li> "forced" unwinding (such as caused by <code>longjmp</code>
or thread termination).
</ul>
The interface described here tries to keep both similar.
There is a major difference, however.

<ul>
<p>
<li>
In the case an exception is thrown,
the stack is unwound while the exception propagates,
but it is expected that the personality routine for each stack frame
knows whether it wants to catch the exception or pass it through.
This choice is thus delegated to the personality routine,
which is expected to act properly for any type of exception,
whether "native" or "foreign".
Some guidelines for "acting properly" are given below.

<p>
<li>
During "forced unwinding", on the other hand,
an external agent is driving the unwinding.
For instance, this can be the <code>longjmp</code> routine.
This external agent, not each personality routine,
knows when to stop unwinding.
The fact that a personality routine is not given a choice about
whether unwinding will proceed is indicated by the _UA_FORCE_UNWIND flag.

</ul>

<p>
To accomodate these differences, two different routines are proposed.
<code>_Unwind_RaiseException</code> performs exception-style unwinding,
under control of the personality routines.
<code>_Unwind_ForcedUnwind</code>, on the other hand,
performs unwinding,
but gives an external agent the opportunity to intercept
calls to the personality routine.
This is done using a proxy personality routine,
that intercepts calls to the personality routine,
letting the external agent override
the defaults of the stack frame's personality routine.

<p>
As a consequence, it is not necessary for each personality routine
to know about any of the possible external agents that may cause an unwind.
For instance,
the C++ personality routine need deal only with C++ exceptions
(and possibly disguising foreign exceptions),
but it does not need to know anything specific about unwinding done
on behalf of <code>longjmp</code> or pthreads cancellation.

<p>
<h5> The Unwind Process </h5>

<p>
The standard ABI exception handling / unwind process begins with
the raising of an exception,
in one of the forms mentioned above.
This call specifies an exception object and an exception class.

<p>
The runtime framework then starts a two-phase process:

<ul>
<p>
<li>
In the <i>search</i> phase,
the framework repeatedly calls the personality routine,
with the <code>_UA_SEARCH_PHASE</code> flag as described below,
first for the current PC and register state,
and then unwinding a frame to a new PC at each step,
until the personality routine reports either success
(a handler found in the queried frame)
or failure (no handler) in all frames.
It does not actually restore the unwound state,
and the personality routine must access the state through the API.
<p>
<li>
If the search phase reports failure,
e.g. because no handler was found,
it will call <code>terminate()</code> rather than commence phase 2.
<p>
If the search phase reports success,
the framework restarts in the <i>cleanup</i> phase.
Again, it repeatedly calls the personality routine,
with the <code>_UA_CLEANUP_PHASE</code> flag as described below,
first for the current PC and register state,
and then unwinding a frame to a new PC at each step,
until it gets to the frame with an identified handler.
At that point, it restores the register state,
and control is transferred to the user landing pad code.

</ul>

<p>
Each of these two phases uses both the unwind library and the
personality routines,
since the validity of a given handler and the mechanism for
transferring control to it are language-dependent,
but the method of locating and restoring previous stack frames
is language independent.

<p>
A two-phase exception-handling model is not strictly necessary to
implement C++ language semantics,
but it does provide some benefits.
For example, the first phase allows an exception-handling mechanism
to <i>dismiss</i> an exception before stack unwinding begins,
which allows <i>resumptive</i> exception handling
(correcting the exceptional condition and resuming execution at
the point where it was raised).
While C++ does not support resumptive exception handling,
other languages do, and the two-phase model allows C++ to coexist with
those languages on the stack.

<p>
Note that even with a two-phase model,
we may execute each of the two phases more than once for a single exception,
as if the exception was being thrown more than once.
For instance, since it is not possible to determine if
a given catch clause will rethrow or not without executing it,
the exception propagation effectively stops at each catch clause,
and if it needs to restart, restarts at phase 1.
This process is not needed for destructors (cleanup code),
so the phase 1 can safely process all destructor-only frames at once
and stop at the next enclosing catch clause.

<p>
For example, if the first two frames unwound contain only cleanup code,
and the third frame contains a C++ catch clause,
the personality routine in phase 1 does not indicate that it found a
handler for the first two frames.
It must do so for the third frame,
because it is unknown how the exception will propagate out of
this third frame,
e.g. by rethrowing the exception or throwing a new one in C++.

<p>
The API specified by the IA-64 psABI for implementing this framework is
described in the following sections.


<p>
<a name=base-data></a>
<h4> 1.2  Data Structures </h4>

<p>
<b> Reason Codes </b>
<p>
The unwind interface uses reason codes in several contexts to identify
the reasons for failures or other actions, defined as follows:
<code><pre>
    typedef enum {
	_URC_NO_REASON = 0,
	_URC_FOREIGN_EXCEPTION_CAUGHT = 1,
	_URC_FATAL_PHASE2_ERROR = 2,
	_URC_FATAL_PHASE1_ERROR = 3,
	_URC_NORMAL_STOP = 4,
	_URC_END_OF_STACK = 5,
	_URC_HANDLER_FOUND = 6,
	_URC_INSTALL_CONTEXT = 7
    } _Unwind_Reason_Code;
</pre></code>
The interpretations of these codes is described below.

<p>
<b> Exception Header </b>
<p>
The unwind interface uses a pointer to an exception header object
as its representation of an exception being thrown.
In general, the full representation of an exception object is
language- and implementation-specific,
but it will be prefixed by a header understood by the unwind interface,
defined as follows:
<code><pre>
    typedef void (*_Unwind_Exception_Cleanup_Fn)
		(_Unwind_Reason_Code reason,
		 struct _Unwind_Exception *exc);

    struct _Unwind_Exception {
	    uint64			 exception_class;
	    _Unwind_Exception_Cleanup_Fn exception_cleanup;
	    uint64			 private_1;
	    uint64			 private_2;
    };
</pre></code>

<p>
An <code>_Unwind_Exception</code> object must be double-word aligned.
The first two fields are set by user code prior to raising the exception,
and the latter two should never be touched except by the runtime.

<p>
The <code>exception_class</code> field is a language- and
implementation-specific identifier of the kind of exception.
It allows a personality routine to distinguish between native and
foreign exceptions, for example.

<p>
The <code>exception_cleanup</code> routine is called whenever an
exception object needs to be destroyed by a different runtime than
the runtime which created the exception object,
for instance if a Java exception is caught by a C++ <i>catch</i>
handler.
In such a case, a reason code (see above) indicates why the
exception object needs to be deleted:
<ul>
<p>
<li> <code>_URC_FOREIGN_EXCEPTION_CAUGHT</code> = 1:
    This indicates that a different runtime caught this exception.
    Nested foreign exceptions,
    or rethrowing a foreign exception,
    result in undefined behaviour.
<p>
<li> <code>_URC_FATAL_PHASE1_ERROR</code> = 3:
    The personality routine encountered an error during phase 1,
    other than the specific error codes defined.
<p>
<li> <code>_URC_FATAL_PHASE2_ERROR</code> = 2:
    The personality routine encountered an error during phase 2,
    for instance a stack corruption.
    <p>
    <img src=warning.gif alt="<b>NOTE</b>:">
    Normally, all errors should be reported during phase 1 by returning
    from <code>_Unwind_RaiseException</code>.
    However, landing pad code could cause stack corruption
    between phase 1 and phase 2.
    For a C++ exception, the runtime should call <code>terminate()</code>
    in that case.
</ul>

<p>
The private unwinder state
(<code>private_1</code> and <code>private_2</code>)
in an exception object should be neither read by nor written to
by personality routines or other parts of the language-specific runtime.
It is used by the specific implementation of the unwinder on the host
to store internal information,
for instance to remember the final handler frame between unwinding
phases.

<p>
In addition to the above information,
a typical runtime such as the C++ runtime will add language-specific
information used to process the exception.
This is expected to be a contiguous area of memory after the
<code>_Unwind_Exception</code> object,
but this is not required as long as the matching personality routines
know how to deal with it,
and the <code>exception_cleanup</code> routine de-allocates it properly.

<p>
<b> Unwind Context </b>
<p>
The <code>_Unwind_Context</code> type is an opaque type
used to refer to a system-specific data structure
used by the system unwinder.
This context is created and destroyed by the system,
and passed to the personality routine during unwinding.
<p>
<code><pre>
    struct _Unwind_Context
</pre></code>


<p>
<a name=base-throw></a>
<h4> 1.3  Throwing an Exception </h4>

<p>
<h5> _Unwind_RaiseException </h5>

<code><pre>
   _Unwind_Reason_Code _Unwind_RaiseException
	      ( struct _Unwind_Exception *exception_object );
</pre></code>

<p>
Raise an exception,
passing along the given exception object,
which should have its <code>exception_class</code> and
<code>exception_cleanup</code> fields set.
The exception object has been allocated by the language-specific runtime,
and has a language-specific format,
except that it must contain an <code>_Unwind_Exception</code> struct
(see <i>Exception Header</i> above).
<code>_Unwind_RaiseException</code> does not return,
unless an error condition is found
(such as no handler for the exception,
bad stack format, etc.).
In such a case, an <code>_Unwind_Reason_Code</code> value is returned.
Possibilities are:
<ul>
<p>
<li> <code>_URC_END_OF_STACK</code>:
    The unwinder encountered the end of the stack during phase 1,
    without finding a handler.
    The unwind runtime will not have modified the stack.
    The C++ runtime will normally call <code>uncaught_exception()</code>
    in this case.
<p>
<li> <code>_URC_FATAL_PHASE1_ERROR</code>:
    The unwinder encountered an unexpected error during phase 1,
    e.g. stack corruption.
    The unwind runtime will not have modified the stack.
    The C++ runtime will normally call <code>terminate()</code> in this case.
</ul>

<p>
If the unwinder encounters an unexpected error during phase 2,
the unwind runtime may have modified the stack,
e.g. popped frames from it,
or landing pad code may have caused stack corruption.
As a result, the unwind library probably could not find a return address,
and the caller of <code>_Unwind_RaiseException</code>
could make no assumptions about the state of its stack.
Rather than attempt to return, therefore,
the unwind library should use the <code>exception_cleanup</code>
entry in the exception,
and then call <code>abort()</code>.

<p>
<a name=forced></a>
<h5> _Unwind_ForcedUnwind </h5>

<code><pre>
    typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)
		(int version,
		 _Unwind_Action actions,
		 uint64 exceptionClass,
		 struct _Unwind_Exception *exceptionObject,
		 struct _Unwind_Context *context,
		 void *stop_parameter );

    _Unwind_Reason_Code _Unwind_ForcedUnwind
	      ( struct _Unwind_Exception *exception_object,
		_Unwind_Stop_Fn stop,
		void *stop_parameter );
</pre></code>

<p>
Raise an exception for forced unwinding,
passing along the given exception object,
which should have its <code>exception_class</code> and
<code>exception_cleanup</code> fields set.
The exception object has been allocated by the language-specific runtime,
and has a language-specific format,
except that it must contain an <code>_Unwind_Exception</code> struct
(see <i>Exception Header</i> above).

<p>
Forced unwinding is a single-phase process
(phase 2 of the normal exception-handling process).
The <code>stop</code> and <code>stop_parameter</code> parameters
control the termination of the unwind process,
instead of the usual personality routine query.
The <code>stop</code> function parameter is called for each unwind frame,
with the parameters described for the usual personality routine below,
plus an additional <code>stop_parameter</code>.

<p>
When the <code>stop</code> function identifies the destination frame,
it transfers control (according to its own, unspecified, conventions)
to the user code as appropriate without returning,
normally after calling <code>_Unwind_DeleteException</code>.
If not, it should return
an <code>_Unwind_Reason_Code</code> value as follows:
<ul>
<p>
<li> <code>_URC_NO_REASON</code>:
    This is not the destination frame.
    The unwind runtime will call
    the frame's personality routine with the
    <code>_UA_FORCE_UNWIND</code> and <code>_UA_CLEANUP_PHASE</code> flags
    set in <code>actions</code>,
    and then unwind to the next frame
    and call the <code>stop</code> function again.
<p>
<li> <code>_URC_END_OF_STACK</code>:
    In order to allow  <code>_Unwind_ForcedUnwind </code> to perform
    special processing when it reaches the end of the stack,
    the unwind runtime will call it after the last frame is rejected,
    with a NULL stack pointer in the context,
    and the <code>stop</code> function must catch this condition
    (i.e. by noticing the NULL stack pointer).
    It may return this reason code if it cannot handle end-of-stack.
<p>
<li> <code>_URC_FATAL_PHASE2_ERROR</code>:
    The <code>stop</code> function may return this code for other fatal
    conditions, e.g. stack corruption.
</ul>
If the <code>stop</code> function returns any reason code other than
<code>_URC_NO_REASON</code>,
the stack state is indeterminate from the point of view of the caller
of <code>_Unwind_ForcedUnwind</code>.
Rather than attempt to return, therefore,
the unwind library should use the <code>exception_cleanup</code>
entry in the exception,
and then call <code>abort()</code>.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i> Example:  <code>longjmp_unwind()</code>
<p>
The expected implementation of <code>longjmp_unwind()</code> is as follows.
The <code>setjmp()</code> routine will have saved the state to be
restored in its customary place, including the frame pointer.
The <code>longjmp_unwind()</code> routine will call
<code>_Unwind_ForcedUnwind </code> with a <code>stop</code> function
that compares the frame pointer in the context record with the saved
frame pointer.
If equal, it will restore the <code>setjmp()</code> state as customary,
and otherwise it will return <code>_URC_NO_REASON</code> or
<code>_URC_END_OF_STACK</code>.
</i>

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
<i>If a future requirement for two-phase forced unwinding were identified,
an alternate routine could be defined to request it,
and an <code>actions</code> parameter flag defined to support it.
</i>

<p>
<h5> _Unwind_Resume </h5>

<code><pre>
    void _Unwind_Resume (struct _Unwind_Exception *exception_object);
</pre></code>

<p>
Resume propagation of an existing exception
e.g. after executing cleanup code in a partially unwound stack.
A call to this routine is inserted at the end of a landing pad that
performed cleanup, but did not resume normal execution.
It causes unwinding to proceed further.

<p>
<img src=warning.gif alt="<b>NOTE 1</b>:">
<code>_Unwind_Resume</code> should not be used to implement rethrowing.
To the unwinding runtime,
the catch code that rethrows was a handler,
and the previous unwinding session was terminated before entering it.
Rethrowing is implemented by calling <code>_Unwind_RaiseException</code>
again with the same exception object.

<p>
<img src=warning.gif alt="<b>NOTE 2</b>:">
This is the only routine in the unwind library which is expected
to be called directly by generated code:
it will be called at the end of a landing pad in a "landing-pad" model.


<p>
<a name=base-om></a>
<h4> 1.4  Exception Object Management </h4>

<p>
<h5> _Unwind_DeleteException </h5>

<code><pre>
    void _Unwind_DeleteException
	      (struct _Unwind_Exception *exception_object);
</pre></code>

<p>
Deletes the given exception object.
If a given runtime resumes normal execution
after catching a foreign exception,
it will not know how to delete that exception.
Such an exception will be deleted by calling
<code>_Unwind_DeleteException</code>.
This is a convenience function that calls the function pointed
to by the <code>exception_cleanup</code> field of the exception header.


<p>
<a name=base-context></a>
<h4> 1.5  Context Management </h4>

These functions are used for communicating information about the unwind
context (i.e. the unwind descriptors and the user register state)
between the unwind library and the personality routine and landing pad.
They include routines to read or set the context record images of
registers in the stack frame corresponding to a given unwind context,
and to identify the location of the current unwind descriptors
and unwind frame.

<p>
<h5> _Unwind_GetGR </h5>

<code><pre>
    uint64 _Unwind_GetGR
	    (struct _Unwind_Context *context, int index);
</pre></code>

<p>
This function returns the 64-bit value of the given general register.
The register is identified by its index:
0 to 31 are for the fixed registers, and
32 to 127 are for the stacked registers.

<p>
During the two phases of unwinding,
only GR1 has a guaranteed value,
which is the Global Pointer (GP)
of the frame referenced by the unwind context.
If the register has its NAT bit set,
the behaviour is unspecified.

<p>
<h5> _Unwind_SetGR </h5>

<code><pre>
    void _Unwind_SetGR
	  (struct _Unwind_Context *context,
	   int index,
	   uint64 new_value);
</pre></code>

<p>
This function sets the 64-bit value of the given register,
identified by its index as for <code>_Unwind_GetGR</code>.
The NAT bit of the given register is reset.

<p>
The behaviour is guaranteed only if the function is called
during phase 2 of unwinding,
and applied to an unwind context representing a handler frame,
for which the personality routine will return <code>_URC_INSTALL_CONTEXT</code>.
In that case, only registers GR15, GR16, GR17, GR18 should be used.
These scratch registers are reserved for passing arguments between
the personality routine and the landing pads.

<p>
<h5> _Unwind_GetIP </h5>

<code><pre>
    uint64 _Unwind_GetIP
	    (struct _Unwind_Context *context);
</pre></code>

<p>
This function returns the 64-bit value of the instruction pointer (IP).

<p>
During unwinding, the value is guaranteed to be the address of the
bundle immediately following the call site
in the function identified by the unwind context.
This value may be outside of the procedure fragment for a
function call that is known to not return
(such as <code>_Unwind_Resume</code>).

<p>
<h5> _Unwind_SetIP </h5>

<code><pre>
    void _Unwind_SetIP
	    (struct _Unwind_Context *context,
	     uint64 new_value);
</pre></code>

<p>
This function sets the value of the instruction pointer (IP)
for the routine identified by the unwind context.

<p>
The behaviour is guaranteed only when this function is called for an
unwind context representing a handler frame,
for which the personality routine will return <code>_URC_INSTALL_CONTEXT</code>.
In this case, control will be transferred to the given address,
which should be the address of a landing pad.

<p>
<a name=lsda></a>
<h5> _Unwind_GetLanguageSpecificData </h5>

<code><pre>
    uint64 _Unwind_GetLanguageSpecificData
	    (struct _Unwind_Context *context);
</pre></code>

<p>
This routine returns the address of the language-specific data area for
the current stack frame.

<p>
<img src=warning.gif alt="<b>NOTE</b>:">
This routine is not stricly required:
it could be accessed through <code>_Unwind_GetIP</code> using
the documented format of the <code>UnwindInfoBlock</code>,
but since this work has been done for finding
the personality routine in the first place,
it makes sense to cache the result in the context.
We could also pass it as an argument to the personality routine.

<p>
<h5> _Unwind_GetRegionStart </h5>

<code><pre>
    uint64 _Unwind_GetRegionStart
	    (struct _Unwind_Context *context);
</pre></code>

<p>
This routine returns the address of the beginning of the procedure or
code fragment described by the current unwind descriptor block.

<p>
This information is required to access any data stored relative to the
beginning of the procedure fragment.
For instance, a call site table might be stored relative to the
beginning of the procedure fragment that contains the calls.
During unwinding, the function returns the start of the procedure
fragment containing the call site in the current stack frame.


<p>
<a name=base-personality></a>
<h4> 1.6  Personality Routine </h4>

<p>
<code><pre>
    _Unwind_Reason_Code (*__personality_routine)
	    (int version,
	     _Unwind_Action actions,
	     uint64 exceptionClass,
	     struct _Unwind_Exception *exceptionObject,
	     struct _Unwind_Context *context);
</pre></code>

<p>
The personality routine is the function in the C++ (or other language)
runtime library which serves as an interface between the system unwind
library and language-specific exception handling semantics.
It is specific to the code fragment described by an unwind info block,
and it is always referenced via the pointer in the unwind info block,
and hence it has no psABI-specified name.

<p>
<h5> Parameters </h5>

<p>
The personality routine parameters are as follows:
<dl>

<p>
<dt><code>version</code>
<dd>Version number of the unwinding runtime,
used to detect a mis-match between the unwinder conventions and the
personality routine, or to provide backward compatibility.
For the conventions described in this document,
<code>version</code> will be 1.

<p>
<dt><code>actions</code>
<dd>Indicates what processing the personality routine is expected to perform,
as a bit mask.
The possible actions are described below.

<p>
<dt><code>exceptionClass</code>
<dd>An 8-byte identifier specifying the type of the thrown exception.
By convention, the high 4 bytes indicate the vendor
(for instance HP\0\0),
and the low 4 bytes indicate the language.
For the C++ ABI described in this document,
the low four bytes are C++\0.
<p>
<img src=warning.gif alt="<b>NOTE</b>:">
This is not a null-terminated string.
Some implementations may use no null bytes.

<p>
<dt><code>exceptionObject</code>
<dd>The pointer to a memory location recording the necessary information
for processing the exception according to the semantics of a given language
(see the <i>Exception Header</i> section above).

<p>
<dt><code>context</code>
<dd>Unwinder state information for use by the personality routine.
This is an opaque handle used by the personality routine in particular
to access the frame's registers
(see the <i>Unwind Context</i> section above).

<p>
<dt>return value
<dd>The return value from the personality routine indicates
how further unwind should happen,
as well as possible error conditions.
See the following section.

</dl>

<p>
<h5> Personality Routine Actions </h5>

<p>
The <code>actions</code> argument to the personality routine is
a bitwise <code>OR</code> of one or more of the following constants:
<code><pre>
    typedef int _Unwind_Action;
    const _Unwind_Action _UA_SEARCH_PHASE = 1;
    const _Unwind_Action _UA_CLEANUP_PHASE = 2;
    const _Unwind_Action _UA_HANDLER_FRAME = 4;
    const _Unwind_Action _UA_FORCE_UNWIND = 8;
</pre></code>

<dl>

<p>
<dt><code> _UA_SEARCH_PHASE </code>
<dd> Indicates that the personality routine should
check if the current frame contains a handler,
and if so return <code>_URC_HANDLER_FOUND</code>,
or otherwise return <code>_UA_CONTINUE_UNWIND</code>.
<code>_UA_SEARCH_PHASE</code> cannot be set
at the same time as <code>_UA_CLEANUP_PHASE</code>.

<p>
<dt><code> _UA_CLEANUP_PHASE </code>
<dd> Indicates that the personality routine should
perform cleanup for the current frame.
The personality routine can perform this cleanup itself,
by calling nested procedures,
and return <code>_URC_CONTINUE_UNWIND</code>.
Alternatively, it can setup the registers (including the IP)
for transferring control to a "landing pad",
and return <code>_URC_INSTALL_CONTEXT</code>.

<p>
<dt><code> _UA_HANDLER_FRAME </code>
<dd> During phase 2,
indicates to the personality routine that the current frame is
the one which was flagged as the handler frame during phase 1.
The personality routine is not allowed to change its mind
between phase 1 and phase 2,
i.e. it must handle the exception in this frame in phase 2.

<p>
<dt><code> _UA_FORCE_UNWIND </code>
<dd> During phase 2,
indicates that no language is allowed to "catch" the exception.
This flag is set while unwinding the stack
for <code>longjmp</code> or during thread cancellation.
User-defined code in a catch clause may still be executed,
but the catch clause must resume unwinding with a call to
<code>_Unwind_Resume</code> when finished.

</dl>

<p>
<a name=landing></a>
<h5> Transferring Control to a Landing Pad </h5>

<p>
If the personality routine determines that it should
transfer control to a landing pad (in phase 2),
it may set up registers (including IP) with suitable values
for entering the landing pad
(e.g. with landing pad parameters),
by calling the context management routines above.
It then returns <code>_URC_INSTALL_CONTEXT</code>.

<p>
Prior to executing code in the landing pad,
the unwind library restores registers not altered by the personality routine,
using the context record,
to their state in that frame before the call that threw the exception,
as follows.
All registers specified as callee-saved by the base ABI are restored,
as well as scratch registers GR15, GR16, GR17 and GR18 (see below).
Except for those exceptions,
scratch (or caller-saved) registers are not preserved,
and their contents are undefined on transfer.
The accessibility of registers in the frame will be restored to that
at the point of call,
i.e. the same logical registers will be accessible,
but their mappings to physical registers may change.
Further,
the state of stacked registers beyond the current frame is unspecified,
i.e. they may be either in physical registers or on the register stack.

<p>
The landing pad can either resume normal execution
(as, for instance, at the end of a C++ catch),
or resume unwinding by calling <code>_Unwind_Resume</code>
and passing it the <code>exceptionObject</code> argument
received by the personality routine.
<code>_Unwind_Resume</code> will never return.

<p>
<code>_Unwind_Resume</code> should be called if and only if
the personality routine did not return <code>_Unwind_HANDLER_FOUND</code>
during phase 1.
As a result, the unwinder can allocate resources (for instance memory)
and keep track of them in the exception object reserved words.
It should then free these resources
before transferring control to the last (handler) landing pad.
It does not need to free the resources before entering non-handler
landing-pads, since <code>_Unwind_Resume</code> will ultimately be called.

<p>
The landing pad may receive arguments from the runtime,
typically passed in registers set using <code>_Unwind_SetGR</code>
by the personality routine.
For a landing pad that can call to <code>_Unwind_Resume</code>,
one argument must be the <code>exceptionObject</code> pointer,
which must be preserved to be passed to <code>_Unwind_Resume</code>.

<p>
The landing pad may receive other arguments,
for instance a <i>switch value</i>
indicating the type of the exception.
Four scratch registers are reserved for this use
(GR15, GR16, GR17 and GR18.)

<p>
<h5> Rules for Correct Inter-Language Operation </h5>

<p>
The following rules must be observed for correct operation
between languages and/or runtimes from different vendors:

<p>
An exception which has an unknown class must not be altered by the
personality routine.
The semantics of foreign exception processing depend on the
language of the stack frame being unwound.
This covers in particular how exceptions from a foreign language are
mapped to the native language in that frame.

<p>
If a runtime resumes normal execution,
and the caught exception was created by another runtime,
it should call <code>_Unwind_DeleteException</code>.
This is true even if it understands the exception object format
(such as would be the case between different C++ runtimes).

<p>
A runtime is not allowed to catch an
exception if the <code>_UA_FORCE_UNWIND</code> flag was passed to 
the personality routine.

<p>
<img src=warning.gif>
Example: Foreign Exceptions in C++.
In C++, foreign exceptions can be caught by a catch(...) statement.
They can also be caught as if they were of a
<code>__foreign_exception</code> class, defined in &lt;exception>.
The <code>__foreign_exception</code> may have subclasses,
such as <code>__java_exception</code> and <code>__ada_exception</code>,
if the runtime is capable of identifying some of the foreign languages.

<p>
The behavior is undefined in the following cases:

<ul>
<p>
<li>
A <code>__foreign_exception</code> catch argument is accessed in any way
(including taking its address).

<p>
<li>
A <code>__foreign_exception</code> is active at the same time as
another exception
(either there is a nested exception while catching the foreign exception,
or the foreign exception was itself nested).

<p>
<li>
<code>uncaught_exception</code>(), <code>set_terminate</code>(),
<code>set_unexpected</code>(), <code>terminate</code>(), or
<code>unexpected</code>() is called at a time a foreign exception exists
(for example, calling <code>set_terminate</code>()
during unwinding of a foreign exception).
</ul>

<p>
All these cases might involve accessing C++ specific content of the
thrown exception,
for instance to chain active exceptions.

<p>
Otherwise, a catch block catching a foreign exception is allowed:

<ul>

<p>
<li>
to resume normal execution,
thereby stopping propagation of the foreign
exception and deleting it, or

<p>
<li>
to rethrow the foreign exception.
In that case,
the original exception object must be unaltered by the C++ runtime.
</ul>

<p>
A catch-all block may be executed during forced unwinding.
For instance, a <code>longjmp</code> may execute code in a
<code>catch(...)</code> during stack unwinding.
However, if this happens,
unwinding will proceed at the end of the catch-all block,
whether or not there is an explicit rethrow.

<p>
Setting the low 4 bytes of exception class to C++\0 is reserved for use
by C++ runtimes compatible with the common C++ ABI.




<p> <hr> <p>
<a name=cxx-abi></a>
<h3> Level II: C++ ABI </h3>


<p>
<a name=cxx-intro></a>
<h4> 2.1  Introduction </h4>

<p>
The second level of specification is the minimum required to allow
interoperability in the sense described above.
This level requires agreement on:

<ul>
<p>
<li>
Standard runtime initialization,
e.g. pre-allocation of space for out-of-memory exceptions.

<p>
<li>
The layout of the exception object created by a throw and processed by
a catch clause.

<p>
<li>
When and how the exception object is allocated and destroyed.

<p>
<li>
The API of the personality routine,
i.e. the parameters passed to it,
the logical actions it performs,
and any results it returns
(either function results to indicate success, failure, or continue,
or changes in global or exception object state),
for both the phase 1 handler search and the phase 2 cleanup/unwind.

<p>
<li>
How control is ultimately transferred back to the user program at a
catch clause or other resumption point.
That is, will the last personality routine transfer control directly to
the user code resumption point,
or will it return information to the runtime allowing the latter to do so?

<p>
<li>
Multithreading behavior.

</ul>


<p>
<a name=cxx-data></a>
<h4> 2.1  Data Structures </h4>

<p>


<p>
<a name=cxx-aux></a>
<h4> 2.5  Auxiliary Runtime APIs </h4>

<font color=red>
<p>
The C++ ABI includes the APIs of a number of runtime routines to
facilitate code generation for recurring situations that need not
always produce inline code.

<dl>

<dt><code><pre>
extern "C" void __cxa_bad_cast ();
</pre></code></dt>
<dd>
Raise a bad_cast exception (lib.bad.cast, 18.5.2).
Does not return (normally),
and implementations may note this fact, e.g. with pragmas.
</dd>

<dt><code><pre>
extern "C" void __cxa_bad_typeid ();
</pre></code></dt>
<dd>
Raise a bad_typeid exception (lib.bad.typeid, 18.5.3).
Does not return (normally),
and implementations may note this fact, e.g. with pragmas.
</dd>


</dl>

</font>

<p> <hr> <p>
<a name=cxx-rt></a>
<h3> Level III. Implementation </h3>


<p>
<a name=imp-intro></a>
<h4> 3.1  Introduction </h4>

<p>
The third level is a specification sufficient to allow all compliant
C++ systems to share the relevant runtime implementation.
It includes, in addition to the Level II specification:

<ul>
<p>
<li>
Format of the C++ language-specific unwind tables.

<p>
<li>
APIs of the functions named __allocate_exception, __throw, and
__free_exception (and likely others) by HP, or their equivalents.

<p>
<li>
API of landing pad code,
and of any other entries back into the user code.

<p>
<li>
Definition of what HP calls the exception class value.

</ul>

<p>
The vocal attendees at the meeting wish to achieve the third level,
and we will attempt to do so.
Whether or not that is achieved, however,
a second-level specification must be part of the ABI.

<i>
&lt;To be specified.>



<p>
<a name=cxx-data></a>
<h4> 2.1  Data Structures </h4>

<p>



<p><a name=revisions></a> <hr> <p>
<h3> Appendix R:  Revisions </h3>

<p>
<font color=blue>[000707]</font>
Add auxiliary runtime APIs (2.5).

<p>
<font color=blue>[000502]</font>
Begin integration of Level 2/3 specifications.

<p>
<font color=blue>[000131]</font>
Integrate comments from 27 January meeting.
Put literal names in reserved name space.

<p>
<font color=blue>[000126]</font>
Integrate comments from 20 January meeting.

<p>
<font color=blue>[000118]</font>
Integrate comments from 13 January meeting.

<p>
<font color=blue>[000112]</font>
Integrate comments from 6 January meeting.
See in particular <a href=#forced><code>_Unwind_ForcedUnwind</code></a>.

<p>
<font color=blue>[991230]</font>
Integrate HP specification, Chapter 8.

<p>
<font color=blue>[990909]</font>
Original version.

<p>
<hr>

<p>
Please send corrections to <a href=mailto:dehnert@sgi.com>Jim Dehnert</a>.

</BODY>
</HTML>
