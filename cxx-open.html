<HTML>

<HEAD>
<title>C++ ABI Open Issues</title>

<link rel=stylesheet href=small-table.css type="text/css">
<link rel=stylesheet href=code.css type="text/css">

<hr>

<font size=6><i><b>
<p>
C++ ABI Open Issues
</b></i></font>

<font size=-1>
<p>
<i>Revised 29 November 1999</i>

</center>

</HEAD>

<BODY>

<p> <hr> <p>
<h3> Revisions </h3>

<p>
<font color=blue>[991129]</font>
Additions to <a href=#B1>B-1</a>, <a href=#F2>F-2</a>, <a href=#G3>G-3</a>.
Closed <a href=cxx-closed.html#B5>B-5</a>.

<p>
<font color=blue>[991104]</font>
New issue <a href=#G6>G-6</a>.
Additions to <a href=#C4>C-4</a>.
Closed <a href=cxx-closed.html#C5>C-5</a>,
<a href=cxx-closed.html#C6>C-6</a>,
<a href=cxx-closed.html#C9>C-9</a>.

<p>
<font color=blue>[991028]</font>
Opened <a href=#C9>C-9</a>, <a href=#C10>C-10</a>.
Closed <a href=cxx-closed.html#A6>A-6</a>,
<a href=cxx-closed.html#B6>B-6</a>,
<a href=cxx-closed.html#C10>C-10</a>.
Additions to <a href=#C5>C-5</a>, <a href=#C6>C-6</a>,
<a href=#F1>F-1</a>, <a href=#F2>F-2</a>, <a href=#F3>F-3</a>.

<p>
<font color=blue>[991026]</font>
Additions to <a href=#F1>F-1</a>.

<p>
<font color=blue>[991012]</font>
Closed <a href=cxx-closed.html#B8>B-8</a>,
<a href=cxx-closed.html#G5>G-5</a>.
Additions to <a href=#A6>A-6</a>, <a href=#B5>B-5</a>,
<a href=#C5>C-5</a>.

<p>
<font color=blue>[991012]</font>
Closed <a href=cxx-closed.html#D5>D-5</a>,
<a href=cxx-closed.html#D6>D-6</a>.
Additions to <a href=#B4>B-4</a>, <a href=#B5>B-5</a>,
<a href=#D7>D-7</a>.

<p>
<font color=blue>[991005]</font>
New issue <a href=#F4>F-4</a>.
Additions to <a href=#A6>A-6</a>, <a href=#B5>B-5</a>, <a href=#B6>B-6</a>,
<a href=#C4>C-4</a>, <a href=#D5>D-5</a>, <a href=#D7>D-7</a>.

<p>
<a href=#ancient>Ancient revision history</a>.


<p> <hr> <p>
<h3> Definitions </h3>

<p>
The issues below make use of the following definitions:

<dl>

<p>
<dt> <i>empty class</i> </dt>
<dd>
A class with no non-static data members,
no virtual functions, no virtual base classes,
and no non-empty non-virtual base classes.)

<p>
<dt> <i>nearly empty class</i> </dt>
<dd>
A class, the objects of which contain only a Vptr.

<p>
<dt> <i>vague linkage</i> </dt>
<dd>
The treatment of entities --
e.g. inline functions, templates, vtables --
with external linkage that can be
defined in multiple translation units,
while the ODR requires that the program
behave as if there were only a single definition.

</dl>


<p> <hr> <p>
<h3> Issue Status </h3>

In the following sections,
the <b><i>class</i></b> of an issue attempts to classify it on the
basis of what it likely affects.
The identifiers used are:

<table>
<tr> <td> call </td>
<td> Function call interface, i.e. call linkage </td>
</tr>

<tr> <td> data </td>
<td> Data layout </td>
</tr>

<tr> <td> lib </td>
<td> Runtime library support </td>
</tr>

<tr> <td> lif </td>
<td> Library interface, i.e. API </td>
</tr>

<tr> <td> g </td>
<td> Potential gABI impact </td>
</tr>

<tr> <td> ps </td>
<td> Potential psABI impact </td>
</tr>

<tr> <td> source </td>
<td> Source code conventions (i.e. API, not ABI) </td>
</tr>

<tr> <td> tools </td>
<td> May affect how program construction tools interact </td>
</tr>
</table>

<p> <hr> <p>
<h3> Object Layout Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A1></a> <td> A-1 </td>
<td> Vptr location </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where is the Vptr stored in an object (first or last are the usual answers).
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
First.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A2></a> <td> A-2 </td>
<td> Virtual base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where are the virtual base subobjects placed in the class layout?
How are data member accesses to them handled?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Virtual base subobjects are normally placed at the end (see issue A-9).
The Vtable will contain an offset to the beginning of the base object
for use by member accesses to them (see issue B-6).
</td> </tr>

</table>

<p>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-3 </td>
<td> Multiple inheritance </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990701 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the class layout in the presence of multiple base classes.
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
See the class layout description in closed issue A-9.
Briefly, empty bases will normally go at offset zero,
non-virtual base classes at the beginning,
and virtual base classes at the end.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-4 </td>
<td> Empty base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where are empty base classes allocated?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
At offset zero if possible.  See A-9.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-5 </td>
<td> Empty parameters </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990701 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
When passing a parameter with an empty class type by value,
what is the convention?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Except for cases of non-trivial copy constructors (see C-7),
and parameters in the variable part of varargs lists,
no parameter slot will be allocated to empty parameters.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A6></a> <td> A-6 </td>
<td> RTTI .o representation </td>
<td> data call ps </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991028 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the data structure to be used for RTTI, that is:
<ul>
<li> for user <code>type_info</code> calls;
<li> for dynamic_cast implementation; and
<li> for exception-handling.
</ul>
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Defined in the
<a href=abi-layout.html#rtti>ABI data layout document</a>.
</tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-7 </td>
<td> Vptr sharing with primary base class </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990729 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It is in general possible to share the virtual pointer with a
polymorphic base class (the <i>primary</i> base class).
Which base class do we use for this?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Share with the first non-virtual polymorphic base class,
or if none with the first nearly empty virtual base class.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-8 </td>
<td> (Virtual) base class alignment </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
A (virtual) base class may have a larger alignment constraint than a
derived class.
Do we agree to extend the alignment constraint to the derived class?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
The derived class will have at least the alignment of any base class.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-9 </td>
<td> Sorting fields as allowed by [class.mem]/12 </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The standard constrains ordering of class members in memory only if
they are not separated by an access clause.
Do we use an access clause as an opportunity to fill the gaps left by padding?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
See <a href=cxx-closed.html#A9>closed issue list</a> and the
<a href=abi-layout.html#class-types>ABI Data Layout Specification</a>.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-10 </td>
<td> Class parameters in registers </td>
<td> call </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990701 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The C ABI specifies that small structs are passed in registers.
Does this apply to small non-POD C++ objects passed by value?
What about the copy constructor and <code>this</code> pointer in that case?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Non-POD C++ objects are passed like C structs,
except for cases with non-trivial copy constructors identified in C-7.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A11></a> <td> A-11 </td>
<td> Pointers to member functions </td>
<td> data </td>
<td> closed </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> 990812 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How should pointers to member functions be represented?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
As a pair of values, a "pointer" and a this adjustment.
See the closed list for a more detailed description.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A12></a> <td> A-12 </td>
<td> Merging secondary vtables </td>
<td> data </td>
<td> closed </td>
<td> Sun </td>
<td> 990610 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Sun merges the secondary Vtables for a class (i.e. those for
non-primary base classes) with the primary Vtable by appending them.
This allows their reference via the primary Vtable entry symbol,
minimizing the number of external symbols required in linking,
in the GOT, etc.
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Concatenate the Vtables associated with a class in the same order
that the corresponding base subobjects are allocated in the object.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-13 </td>
<td> Parameter struct field promotion </td>
<td> call </td>
<td> closed </td>
<td> SGI </td>
<td> 990603 </td>
<td> 990701 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It is possible to pass small classes either as memory images,
as is specified by the base ABI for C structs,
or as a sequence of parameters, one for each member.
Which should be done, and if the latter,
what are the rules for identifying "small" classes?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
No special treatment will be specified by the ABI.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A14></a> <td> A-14 </td>
<td> Pointers to data members </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990729 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How should pointers to data members be represented?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Represented as one plus the offset from the base address.
</td> </tr>

</table>


<p> <hr> <p>
<h3> Virtual Function Handling Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B1></a> <td> B-1 </td>
<td> Adjustment of "this" pointer (e.g. thunks) </td>
<td> data call </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
There are several methods for adjusting the <i>this</i> pointer
for a member function call,
including thunks or offsets located in the vtable.
We need to agree on the mechanism used,
and on the location of offsets, if any are needed.
To maximize performance on IA64,
a slightly unusual approach such as using secondary entry points
to perform the adjustment may actually prove interesting. 
</td> </tr>

</table>

<p>
<font color=blue>[990623 HP -- Christophe]</font>

<p>
<h4>Open Issues Relevant To This Discussion</h4>

<ol>
<p>
<li>
Keeping all of a class in a single load module.
The vtable contains the target address and one copy of the target GP.
This implies that it is not in text, and that it is generated by dld.

<p>
<li>
Detailed layout of the virtual table.

<p>
<li>
How can we share class offsets?

</ol>


<p>
<h4> 1. Scope and "State of the Art"</h4>

<p>
The following proposal applies only to calls to virtual functions  
when a this pointer adjustment is required from a base class to a  
derived class.
Essentially, this means multiple inheritance, and the  
existence of two or more virtual table pointers (vptr)
in the complete object.
The multiple vptrs are required so that the layout  
of all bases is unchanged in the complete object.
There will be one additional vptr for each base class which already
required a vptr,  
but cannot be placed in the whole object so that it shares its vptr  
with the whole object.
Note: when the vptr is shared,
the base class  is said to be the "primary base class",
and there is only one such class.

<p>
For the primary base class, no pointer adjustment is needed.
For all  other bases, a pointer to the whole object is not a pointer
to the base class,
so whenever a pointer to the base class is needed,  
adjustment will occur.

<p>
In particular, when calling a virtual function,
one does not know in advance in which class the function was actually defined.
Depending on the actual class of the object pointed to,
pointer adjustment may be needed or not,
and the pointer adjustment value may vary from class to class.
The existing solution is to have the vtable point not to the function itself,
but to a "thunk" which does pointer adjustment when needed,
and then jumps to the actual function.  
Another possibility is to have an offset in the vtable,
which is used by the called function.
However, more often than not, this implies adding zero.

<p>
Virtual bases make things slightly more complicated.
In that case, the data layout is such that there is only
one instance of the virtual base in the whole object.
Therefore, the offset from a this  
pointer to a same virtual base may change along the inheritance tree.  
This is solved by placing an offset in the virtual table,
which is used to adjust the this pointer to the virtual base.


<p>
<h4> 2. Proposal and Rationale </h4>

<p>
My proposal is to replace thunks with offsets,
with two additional tricks:
<ul>
<li>
Give a virtual function two entry points,
so as to bypass the adjustment when it's known to be zero.
<li>
Moving the adjustment at call-site,
where it can be scheduled more easily,
using a "reasonable" value,
so that the adjustment is bypassed even more often.
</ul>

<p>
The thunks are believed to cost more on IA64 than they would on  
other platforms.
The reason is that they are small islands of code spread throughout the code,
where you cannot guarantee any cache locality.
Since they immediately follow an indirect branch,
chances are we will always encounter both a branch misprediction and a  
I-cache miss in a row.

<p>
On the other hand,
a virtual function call starts by reading the virtual function address.
Reading the offset immediately thereafter should almost never cause a
D-cache miss (cache locality should be good).
More often than not, no adjustment is needed,
or the adjustment will be done at call site correctly.
In the worst case scenario, we perform two adjustments,
one static at call site, and one dynamic in the callee,
but this case should be really infrequent.


<p>
<h4> 3. New Calling Convention </h4>

<p>
The new calling convention requires that the 'this' pointer on entry  
points to the class for which the virtual function is just defined.  
That is, for A::f(),
the pointer is an A* when the main entry of the function is reached.
If the actual pointer is not an A*,
then an adjusting entry point is used,
which immediately precedes the function.

<p>
In the following, we will assume the following examples:
<p>
<code><pre>
    struct A { virtual void f(); };
    struct B { virtual void g(); };
    struct C: A, B { }
    struct D : C { virtual void f(); virtual void g(); }
    struct E: Other, C { virtual void f(); virtual void g(); }
    struct F: D, E { virtual void f(); }

    void call_Cf(C *c) { c->f(); }
    void call_Cg(C *c) { c->g(); }
    void call_Df(D* d) { d->f(); }
    void call_Dg(D* d) { d->g(); }
    void call_Ef(E* e) { e->f(); }
    void call_Eg(E* e) { e->g(); }
    void call_Ff(F *ff) { ff->f(); }
    void call_Fg(F *ff) { ff->g(); }	// Invalid: ambiguous
</pre></code>

<dl>
<p>
<dt> a) Call site:
<dd>
The caller performs adjustment to match the class of the last  
overrider of the given function.

<ul>
<p>
<li> call_Cf will assume that the pointer needs to be cast to an A*,  
since C::f is actually A::f. Since A is the primary base class, no  
adjustment is done at call site.

<p>
<li> call_Cg is similar, but assumes that the actual type is a B*, and  
performs the adjustment, since B is not the primary base class.

<p>
<li> call_Df and call_Dg will assume that the pointer needs to be cast  
to a D*, which is where D::f is defined. No adjustment is performed  
at call site.
</ul>
</dd>


<p>
<dt> b) Callee
<dd>
<ul>
<p>
<li> A::f and B::g are defined in classes where there is a single vptr.  
They don't define a secondary entry point. Because of call-site  
conventions, they expect to always be called with the correct type.

<p>
<li> D::f is defined in a class where there is more than one vptr, so  
it needs a secondary entry point and an entry 'convert_to_D' in the  
vtable. That's because it can be potentially called with either an A*  
or a B*. There are two vtables, one for A in D, one for B in D. The  
D::f entry in A in D points to the non-adjusting entry point, since A  
shares its vptr.

<p>
<li> D::g requires a secondary entry point, that will read the same  
offset 'convert_to_D' from the vtable.

<p>
<li> E also will require a 'convert_to_E' entry in the vtable, but this  
time, the vtable for A in C will have to point to an adjusting entry  
point, since A no longer shares the vptr with E (assuming Other has  
a vptr). This vtable is also the vtable of C in E.
</ul>
</dd>


<p>
<dt> c) Offsets in the vtable
<dd>
Offsets have to be placed in the vtable at a position which does not  
conflict with any offset in the inheritance tree.

<p>
convert_to_D and convert_to_E are likely to be at the same offset in  
the vtable. This is not a problem, even if D and E are used in the  
same class, such as F, because this is the same offset in different  
vtables.

<ul>
<p>
<li> call_Fg is invalid, because it is ambiguous.

<p>
<li> A notation such as ((E*) ff)->g() can be used to disambiguate, but  
in that case, we don't use the same vtable (either the E in F or D  
in F vtable). The E in F vtable uses that offset as 'convert_to_E',  
whereas the D in F vtable uses that offset as 'convert_to_D'.

<p>
<li> Similarly, call_Cf called with an F object will actually be called  
with the E in F or D in F, which disambiguates which C is actually  
used. The actual C* passed will have been adjusted by the caller  
unambiguously, or the call will be invalid.

<p>
<li> For functions overriden in F, an entry 'convert_to_F' is created  
anyway. This entry will not overlap with either convert_to_E or  
convert_to_D.
</ul>

<p>
The fact that an offset is reserved does not mean that it is  
actually used. A vtable need to contain the offset only if it refers  
to a function that will use it. An offset of 0 is not needed, since  
the function pointer will point to the non-adjusting entry point in  
that case.
</dd>

</dl>


<p>
<h4> 4. Cases where adjustment is performed </h4>

<ul>
<p>
<li> For call_Cf: No adjustment is done at call site. No adjustment is  
done at callee site if the dynamic type is C,  or D, or D in F (that  
is, F casted to an E).

<p>
<li> For call_Cg: Adjustment to B* is done at call-site. No further  
adjustment is needed if the dynamic type is C, D, or D in F. On the  
other hand, a second adjustment may happen for an E or E in F,  
because C is not their primary base.
</ul>

<p>
In other words, adjustment is made only when necessary, and at a  
place where it is better scheduled than with thunks. The only bad  
case is double adjustment for call_Cg called with an E*. This case  
can probably be considered rare enough, compared to calls such as  
call_Cg called with a C*, where we now actually do the adjustment at  
the call-site.


<p>
<h4> 5. Comparing the code trails </h4>

<p>
Currently, the sequence for a virtual function call in a shared  
library will look as follows. I'm assuming +DD64, there would be some  
additional addp4 in +DD32. The trail below is the dynamic execution  
sequence. In bold and between #if/#endif, the affected code.

<p>
<code><pre>
        // Compute the address of the vptr in the object,
	// from the this pointer
        // Optional, since vptroffset is often 0.
	// This also adjusts to the class of the final overrider
        addi            Rthis=vptroffset_of_final_overrider,Rthis
        ;;
        // Load the vptr in a register
        ld8             Rvptr=[Rthis]
        ;;
        // Add the offset to get to the function descriptor pointer
	// in the vtable.  Never zero, this instruction is always generated
        addi            Rfndescr=fndescroffset,Rvptr
        ;;
        // (Assuming inlined stub) Load the function address and new GP
        ld8             Rfnaddr=[Rfndescr],8
        ;;
        // Load the new GP
        ld8             GP=[Rfndescr]
        mov             BRn=Rfnaddr
        ;;
        // Perform the actual branch to the target

        // ...
        // ... Branch misprediction almost always, followed by
        // ... I-Cache miss almost always if jumping to a thunk
        br.call B0=BRn

#if OLD_ADJUST
thunk_A::f_from_a_B:
        // If the 'adjustment_from_B_to_A is the 'adjustment_to_A' above,
        // then in the new case, the vtable directly points to A::f
        addi            Rthis,adjustment_from_B_to_A

        // In most cases, we can probably generate a PC-relative branch here
        // It is unclear whether we would correctly predict that branch
        // (since it is assumed that we arrive here immediately following
        // a misprediction at call site)
        br              A::f
#endif // OLD_ADJUST

// This occurs less often than OLD_ADJUST
// (it does not happen when call-site adjustment is correct)
#if NEW_ADJUST
adjusting_entry_A::f
        // Can't be executed in less than 3 cycles?
        addi            Rvptr=class_adjustment_offset,Rvptr
        ;;
        // This loads data which is close to the fn descriptor,
        // so it's likely to be in the D-cache
        ld8             Rvptr=[Rvptr]
        ;;
        add             Rthis=Rthis,Rvptr
#endif

A::f:
        alloc   ...
</pre></code>

<p>
<font color=blue>[990812 All]</font>
Discussion of B-6 raises questions of impact on the above approach.
Christophe will look at the issues.

<p>
<font color=blue>[990826 Cygnus -- Jason]</font>
[An alternative suggestion from Jason via email.]

<p>
Rather than per-function offsets, we have per-target type offsets.
These offsets (if any) are stored at a negative index from the vptr.
When a derived class D overrides a virtual function F from a base class B,
if no previously allocated offset slot can be reused,
we add one to the beginning of the vtable(s) of the closest base(s)
which are non-virtually derived from B.
In the case of non-virtual inheritance, that would be D's vtable;
in simple virtual inheritance, it would be B's.
The vtables are written out in one large block,
laid out like an object of the class,
so if B is a non-virtual base of D,
we can find the D vtable from the B vptr.

<p>
D::f then recieves a B*, loads the offset from the vtable,
and makes the adjustment to get a D*.
The plan is to also have a non-adjusting vtable entry in D's vtable,
so we don't have to do two adjustments to call D::f with a D*;
the implementation of this is up to the compiler.
I expect that for g++,
we will do the adjustment in a thunk which just falls into the main function.

<p>
The performance problems with classic thunks occur when the thunk is
not close enough to the function it jumps to for a pc-relative branch.
This cannot be avoided in certain cases of virtual inheritance,
where a derived class must whip up a thunk for a new adjustment
to a method it doesn't override.

<p>
In this case, we will only ever have one thunk per function,
so we don't even have to jump.
Except in the case of covariant returns, that is,
where we will have one per return adjustment.
But we know all necessary adjustments at the
point of definition of the function,
so they can all be within pc-relative branch range.

<p>
[Extensive discussion followed by email --
this suggestion is not completely correct,
but may be the basis of a workable solution.]

<p>
<font color=blue>[990831 Cygnus -- Ian]</font>
A couple of observations ...

<p>
<b>On the state of the art:</b>

<p>
The Microsoft approach is worth mentioning.
(I haven't seen it discussed --
though perhaps that is because of the patent situation.)

<p>
It allows zero-adjusting (i.e. non-thunking) calls for (almost)
every virtual function call in a non-virtual,
multiple inheritance hierarchy.

<p>
For those that are unfamiliar,
the idea is that all calls go via the base class vft and overriding
functions expect a pointer to the base class type.
(That is, if D::f overrides B::f, it expects the first
parameter to be of type B*, not D*.)
The callee does the necessary static adjustment to get to the
derived class 'this' pointer as needed.

<p>
It avoids requiring a thunk,
and it's often the case that the cost is zero in the callee because
the this-adjustment can be folded into other offset computations.

<p>
On the balance,
it could well win over all the other approaches being discussed here.
[Though, it may lose in some specific cases vs. Christophe's approach
where one would create additional extra entries in
the derived class vft.]

<p>
<b>On when to make extra virtual function table entries for functions:</b>

<p>
One of Cristophe's suggestions is sort-of separate
from the rest of the discussion:
making extra entries in the derived class' vft for some
overridden virtual functions.
It has the benefit of giving you a faster calls if you happen to be in
(or near) the derived class -- at the expense of space in the vft.

<p>
Of course, you can always make the call through the introducing base class,
so these extra entries are a pure space/time performance trade off
(w/ some unpredictable D-cache effects) and the cost/benefit analysis
will depend a little on what the rest of the strategy looks like.

<p>
The same idea is potentially applicable,
no matter what strategy you actually use for vft layout,
and different criteria for deciding what extra entries to make are possible.
For example,
creating an extra entry when overriding a function introduced in a
virtual base has the added benefit of avoiding a cast to a virtual
base at the call site.

<p>
<font color=blue>[990909 All]</font>
We are getting closer --
understanding of the alternatives is improving,
and Christophe may agree with the Jason/Brian proposal after more thought.
To make sure we really understand what we're agreeing to,
Jason and Christophe will write up more precise proposal(s).


<p><font color=blue><hr><p>[991111 jason]</font>
We have decided that for virtual functions not inherited from a virtual base, 
regular thunks will work fine,
since we can emit them immediately before the
function to avoid the indirect branch penalty;
we will use offsets in the
vtable for functions that come from a virtual base,
because it is impossible to predict what the offset between the
current class and its virtual base will
be in classes derived from the current class.

<p>
The calling convention is as follows:

<ul>
<li>vtable layout:
<p>
For each virtual function defined in a class,
we add an entry to the primary vtable if one is not already there.
In particular, a definition which overrides a function inherited from
a secondary base gets a new slot in the primary vtable.
We do this to avoid useless adjustments when calling a virtual
function through a pointer to the most derived class.

<p>
When a class is used as a virtual base,
we add a vcall offset slot to the beginning of its vtable for each of
the virtual functions it provides,
whether in its primary or secondary vtables.
Derived classes which override these functions will use the slots to
determine the adjustment necessary.

<p>
<li>Caller:
<p>
As in Christophe's proposal above,
the caller adjusts the 'this' argument to 
point to the class which last overrode the function being called.
The result provides both the 'this' argument and the vtable pointer
for finding the function we want.

<p>
<li>Callee:
<p>
Each virtual function 'f' defined in a class 'A' has one entry point
which takes an A*, and performs no adjustment.
The primary vtable for A points to this entry point.

<p>
For each secondary vtable from a non-virtual base class 'B' which
defines f,
an additional entry point is generated which performs the constant
adjustment from B* to A*.

<p>
For each secondary vtable from a virtual base class 'C' which defines f,
an additional entry point is generated which performs the adjustment
from C* to A* using the vcall offset for f stored in the secondary
vtable for C.

<p>
For each secondary vtable from a base 'D' which is a non-virtual base
of a virtual base 'E',
an additional entry point is generated which
first performs the constant adjustment from D* to E*,
then the adjustment from E* to A* using the vcall offset for f stored
in the secondary vtable for E.

<p>
<li>Implementation
<p>
Note that the ABI only specifies the multiple entry points;
how those entry points are provided is unspecified.
An existing compiler which uses thunks could be converted to use this
ABI by only adding support for the vcall offsets.
A more efficient implementation would be to emit all of the thunks
immediately before the non-adjusting entry point to the function.
Another might use predication rather than branches to reach the main function.
Another might emit a new copy of the function for each entry point;
this is a quality of implementation issue.
</ul>



<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B2></a> <td> B-2 </td>
<td> Covariant return types </td>
<td> call </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990722 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
There are several methods for adjusting the 'this' pointer of the
returned value for member functions with covariant return types.
We need to decide how this is done.
Return thunks might be especially costly on IA64,
so a solution based on returning multiple pointers may prove more interesting.
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Provide a separate Vtable entry for each return type.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B3></a> <td> B-3 </td>
<td> Allowed caching of vtable contents </td>
<td> call </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The contents of the vtable can sometimes be modified,
but the concensus is that it is nonetheless always allowed to "cache" elements,
i.e. to retain them in registers and reuse them,
whenever it is really useful.
However, this may sometimes break "beyond the standard" code,
such as code loading a shared library that replaces a virtual function.
Can we all agree when caching is allowed? 
</td> </tr>
<tr> <td colspan=7>
<b> Resolution </b>:
Caching is allowed within a member function.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B4></a> <td> B-4 </td>
<td> Function descriptors in vtable </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
For a runtime architecture where the caller is expected to load the GP
of the callee (if it is in, or may be in, a different DSO), e.g. HP/UX,
what should vtable entries contain?
One possibility is to put a function address/GP pair in the vtable.
Another is to include only the address of a thunk which loads the GP
before doing the actual call.
</td> </tr>
<tr> <td colspan=7>
<b> Resolution </b>:
The Vtable will contain a function address/GP pair.
</td> </tr>

</table>

<p>
<font color=blue>[991007 All]</font>
Note that, though this issue was closed,
it may prove necessary to reopen it if the underlying C ABI treatment
of function pointers changes.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B5></a> <td> B-5 </td>
<td> Where are vtables emitted? </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 991118 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
In C++, there are various things with external linkage that can be
defined in multiple translation units,
while the ODR requires that the program
behave as if there were only a single definition.
From the user's standpoint, this applies to inlines and templates.
From the implementation's perspective,
it also applies to things like vtables and RTTI info.
(We call this <i>vague linkage</i>.)
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Vtables will be emitted with the key function (first virtual function
that is not inline at the point of class definition), if any.
If no key function, emit everywhere used (i.e. referred to by name).
Place in a comdat group in all cases.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B6></a> <td> B-6 </td>
<td> Virtual function table layout </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991028 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What is the layout of the Vtable?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
See the ABI data layout document,
<a href=abi-layout.html#vtable>abi-layout.html</a>.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B7></a> <td> B-7 </td>
<td> Objects and Vtables in shared memory </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990624 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Is it possible to allocate objects in shared memory?
For polymorphic objects, this implies that the Vtable must also be
in shared memory.
</td> </tr>
<tr> <td colspan=7>
<b> Resolution </b>:
No special representation is useful in support of shared memory.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B8></a> <td> B-8 </td>
<td> dynamic_cast </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990628 </td>
<td> 991014 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What information to we put in the vtable to enable (a) dynamic_cast
from pointer-to-base to pointer-to-derived (including detection of
ambiguous base classes) and (b) dynamic_cast to void*?
</td> </tr>
<tr> <td colspan=7>
<b> Resolution </b>:
The vtable will contain an offset to the beginning of the complete object,
and a pointer to the typeinfo object.
</td> </tr>

</table>


<p> <hr> <p>
<h3> Object Construction/Destruction Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C1></a> <td> C-1 </td>
<td> Interaction with .init/.fini </td>
<td> lif ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Static objects with dynamic constructors must be constructed at
intialization time.
This is done via the executable object initialization functions that
are identified (in ELF) by the DT_INIT and DT_INITARRAY dynamic tags.
How should the compiler identify the constructors to be called in this way?
One traditional mechanism is to put calls in a .init section.
Another, used by HP, is to put function addresses in a .initarray section.
<p>
The dual question arises for static object destructors.
Again, the extant mechanisms include putting calls in a .fini section,
or putting function addresses in a .finiarray section.
<p>
Finally, which mechanism (DT_INIT or DT_INITARRAY, or the FINI versions)
should be used in linked objects?
The gABI, and the IA-64 psABI, will support both,
with DT_INIT being executed before the DT_INITARRAY elements.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C2></a> <td> C-2 </td>
<td> Order of ctors/dtors w.r.t. link </td>
<td> lif ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Given that the compiler has identified constructor/destructor calls for
static objects in each relocatable object, in what order should the
static linker combine them in the linked executable object?
(The initialization order determines the finalization order,
as its opposite.)
</td> </tr>

</table>

<p>
<font color=blue>[990610 All]</font>
Meeting concensus is that the desirable order is right to left on the
link command line, i.e. last listed relocatable object is initialized
first.

<p>
<font color=blue><hr><p>[990701 SGI]</font>
We propose that global constructors be handled as follows:
<ul>
<p>
<li>
The compiler shall emit global constructor calls as one or more entries
in an SHF_INIT_ARRAY section.
<p>
<li>
The linker shall combine them according to the rules of the base gABI,
namely as a concatenated array of entries, in link argument order,
pointed to by a DT_INIT_ARRAY tag.
(The linker may intersperse entries from command line flags or modules
from other languages, but that is beyond the C++ ABI scope.)
</ul>

<p>
This does not address the global destructor problem.
That solution needs to deal not only with the global objects seen by
the compiler, but also interspersed local static objects.
This treatment seems to be tied up in the question of how early
unloading of DSOs is handled, and the data structure used for that
purpose (issue C-3).

<p>
<font color=blue><hr><p>[990715 All]</font>
Cygnus scheme:
priorities are 16-bit unsigned integers, lower numbers are higher priority.
In each translation unit,
there's a single initialization function for each priority.
Anything that's prioritized has a higher priority than anything that
isn't explicitly assigned a priority.

<p>
IBM scheme:
priorities are 32-bit signed integers, higher numbers are higher priority.
Something that isn't explicitly assigned a priority effectively
gets a priority of 0.

<p>
Consensus:
nobody is sure that negative priorities are very important,
but also nobody can think of a reason not to allow them.
We accept the idea that priorities are 32-bit signed integers.
On a source level Cygnus will keep lower numbers as higher priority,
but that's a source issue, not an ABI issue.

<p>
Status: No real technical issues,
we have consensus on everything that matters.
We need to write up the finicky details.

<p>
<font color=blue><hr><p>[990722 all]</font>
It was decided to follow the IBM approach, including:
<ul>
<li> The source pragma will use a 32-bit signed priority.
	The default will map to 0,
	and larger numbers are lower priority.

<li> Priorities MIN_INT .. MIN_INT+1023 are reserved to the implementation.

<li> The object representation will use a 32-bit unsigned priority,
	obtained from the source priority by subtracting INT_MIN.

<li> Initialization priorities are only relevant within a DSO.
	Between DSOs, the normal ELF ordering based on object order applies.

</ul>

<p>
To be resolved are the precise source pragma definition (possibly IBM's),
and the ELF file representation.

<p>
<font color=blue><hr><p>[990729 all]</font>
SGI suggested an object representation involving (in relocatables)
a new section type, containing pairs &lt;priority, entry address>.
The linker would merge all such sections,
include any initialization entries specified by other means,
and leave one or more DT_INITARRAY entries for normal runtime
initialization, either building a routine to call the entries,
or referencing a standard runtime routine.

<p>
IBM noted that they combine their equivalent data structures in the
linker, but don't sort them, leaving that to a runtime routine.
This can be done without explicit linker support,
but involves runtime overhead.

<p>
Cygnus suggested that if we are going to require linker sorting,
we should make the facility more general.

<p>
Jim will write up a more precise proposal.

<p>
<font color=blue><hr><p>[990804 SGI -- Jim]</font>
<h4> Proposal </h4>

<p>
My objectives are:
<ul>
<li> Simple representation in relocatable objects.
<li> No new representation in executable objects.
<li> Simple static linker processing (general if possible).
<li> Minimal unnecessary runtime cost.
<li> Minimal library interface.
<li> Integration with other initialization (at source priority zero).
</ul>

<p>
<h5> Object File Representation </h5>

<p>
Define a new section type, e.g. <code><b>SHT_CXX_PRIORITY_INIT</b></code>.
Its elements are structs:
<code><pre>
	typedef struct {
	  ElfXX_Word	pi_pri;
	  ElfXX_Addr	pi_addr;
	} ElfXX_Cxx_Priority_Init;
</pre></code>
The semantics are that <code>pi_addr</code> is a function pointer,
with an <code>unsigned int</code> priority parameter,
which performs some initialization at priority <code>pi_pri</code>.
Each of these functions will be called with the GP of the
executable object containing the table.
The section header field <code>sh_entsize</code> is 8 for ELF-32,
or 16 for ELF-64.

<p>
<h5> Runtime Library Support </h5>

<p>
Each implementation shall provide a runtime library function with
prototype:
<code><center>
void __cxx_priority_init ( ElfXX_Cxx_Priority_Init *pi, int cnt );
</center></code>
It will be called with the address of a <code>cnt</code>-element
(sub-)vector of the priority initialization entries,
and will call each of them in order.
It will be called with the GP of the initialization entries.

<p>
<h5> Linker Processing </h5>

<p>
The linker must take the collection of SHT_CXX_PRIORITY_INIT section
entries from the relocatable object files being linked,
and other initialization tasks specified in other ways
(and treated as source priority 0 or object priority -MIN_INT),
and produce an executable object file which executes the initialization
tasks in priority order using only <code>DT_INIT</code>,
<code>DT_INIT_ARRAY</code>, and <code>__cxx_priority_init</code>.
Priority order is first according to the priority of the task,
and then according to the order of relocatable objects and options
in the link command.
The order of tasks specified by other methods,
relative to SHT_CXX_PRIORITY_INIT tasks of priority zero,
is implementation defined.
There are several possible implementations.  Two extremes are:

<ul>
<p>
<li>
The linker sorts the SHT_CXX_PRIORITY_INIT sections together.
If it inserts entries for initialization tasks specified in other ways,
it may make a single DT_INIT_ARRAY entry pointing to __cxx_priority_init.
If not, it must break it into subranges,
interspersing DT_INIT_ARRAY entries for the other tasks with entries
for the SHT_CXX_PRIORITY_INIT entries.
(This implementation will minimize runtime overhead.)

<p>
<li>
The linker simply appends the SHT_CXX_PRIORITY_INIT sections.
It inserts DT_INIT_ARRAY entries before and after the entries for other
initialization tasks which sort this vector and then execute the
negative-priority calls on the first call,
and the positive-priority ones on the second call.
(I believe this is much like today's IBM implementation.)
However, to be conforming, the routine which performs these tasks
must be linked with the resulting executable object,
or shippable with it as an associated DSO.

</ul>

<p>
Note that if one is linking ELF-32 objects into a 64-bit program,
the entries must be expanded as part of this process.

<p>
<h5> Sorting Sections </h5>

<p>
Jason suggested that if we base this feature on sorting sections,
we should provide a general mechanism.
Following is a proposal for that purpose.

<p>
Define a new section header flag, <code>SHF_SORT</code>.
If present, the linker is required to sort the elements of the
concatenated sections of the same type,
where the elements are determined by <code>sh_entsize</code>.
The sort is controlled by fields in <code>sh_info</code>:

<dl>
<p>
<dt> <code>#define SH_INFO_KEYSIZE(info) (info & 0xff)</code>
<br><dd>	The size of the sort key (bytes).
<p>
<dt> <code>#define SH_INFO_KEYSTART(info) ((info>>8) & 0xff)</code>
<br><dd>	The start byte of the sort key within element, from 0.
<p>
<dt> <code>#define SH_INFO_SORTKIND(info) ((info>>16) & 0xf)</code>
<br><dd>	The kind of sort data:
		0 for unsigned integer, 1 for signed integer.

</dl>

<p>
The sort must be stable.
The sort key must be naturally aligned.

<p>
Other conceivable options would be to allow sorting strings
(like SHF_MERGE, this would be indicated by setting SHF_STRING
and putting the character size in <code>sh_entsize</code>),
or floating point data.
Also, note that if we don't anticipate using such a general mechanism,
it becomes possible to avoid padding words in the ELF-64 format by
separating the priority and address vectors.

<p>
<font color=blue><hr><p>[990810 HU-B -- Martin]</font>
Global destructor ordering must not only interleave with static locals,
but also with atexit.
This gives two problems:
atexit is only guaranteed to support 32 functions;
and dynamic unloading of DSOs break when functions are atexit registered.

<p>
<font color=blue><hr><p>[990810 SGI -- Matt]</font>
Yes, the interleaving is required by the C++ standard.
It's a nuisance, and I don't think there's any good reason for it,
but the requirement is quite explicit.

<p>
The relevant part of the C++ standard is section 3.6.3, paragraph 3:

<p>
<dl><dd>
<cite>
"If a function is registered with atexit (see <cstdlib>, 18.3) then
following the call to exit, any objects with static storage duration
initialized prior to the registration of that function shall not be
destroyed until the registered function is called from the termination
process and has completed. For an object with static storage duration
constructed after a function is registered with atexit, then following
the call to exit, the registered function is not called until the
execution of the object's destructor has completed. If atexit is called
during the construction of an object, the complete object to which it
belongs shall be destroyed before the registered function is called."
</cite>
</dd></dl>

<p>
What this implies to me is that atexit, and the part of the runtime
library that handles destructors for static objects, must know about
each other.

<p>
<font color=blue><hr><p>[990812 All]</font>
Some people would prefer a sorting scheme based on the section name
instead of the data, and also less linker impact.
Jim will look into alternatives.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C3></a> <td> C-3 </td>
<td> Order of ctors/dtors w.r.t. DSOs </td>
<td> ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Given the constructor/destructor calls for each executable object
comprising a program, what is the order of execution between objects?
For constructors, there is not much question:
unless we choose some explicit means of control,
file-scope objects will be initialized by the DT_INIT/DT_INITARRAY
functions in the order determined by the base ABI order rules,
and local objects will be initialized in the order their containing
scopes are entered.
<p>
For destructors, the Standard requires opposite-order destruction,
which implies a runtime structure to keep track of the order.
Furthermore, the potential for dynamic unloading of a DSO
(e.g. by dlclose)
requires a mechanism for early destruction of a subset.
</td> </tr>

</table>

<p>
<font color=blue><hr><p>[990804 SGI -- Jim]</font>
<h4> Proposal </h4>

<p>
My objectives are:
<ul>
<li> Simple library interface.
<li> Efficient handling during construction.
<li> Standard-conforming treatment during normal program exit.
<li> Reasonable treatment during early DSO unload (e.g. dlclose).
<li> Minimal dynamic and static linker impact.
</ul>

<p>
<h5> Runtime Data Structure </h5>

<p>
The runtime library shall maintain a list of termination functions
with the following information about each:

<ul>
<li> A function pointer (a pointer to a function descriptor on IA-64).
<li> A void* operand to be passed to the function.
<li> A void* handle for the <i>home DSO</i> of the entry (below).
</ul>

<p>
The representation of this structure is implementation defined.
All references are via the API described below.

<p>
<h5> Runtime API </h5>

<ol type=A>
<p>
<li> Object construction:
<p>
When a global or local static object is constructed,
which will require destruction on exit,
a termination function is <i>registered</i> as follows:
<center><code>
int __cxx_atexit ( void (*f)(void *), void *p, dso_handle d );
</code></center>
This registration, e.g. <code>__cxx_atexit(f,p,d)</code>,
is intended to cause the call <code>f(p)</code> when DSO d is unloaded,
before all such termination calls registered before this one.
It returns zero if registration is successful, nonzero on failure.
<font color=red>Should we use exceptions instead?</font>

<p>
The registration function is called separate from the constructor.

<p>
<li> User atexit calls:
<p>
When the user registers exit functions with <code>atexit</code>,
they should be registered with NULL parameter and DSO handle, i.e.
<center><code>
__cxx_atexit ( f, NULL, NULL );
</code></center>
<font color=red>
Should we also allow user registration with a parameter?
With a home DSO?
</font>

<p>
<li> Termination:
<p>
When linking any DSO containing a call to <code>__cxx_atexit</code>,
the linker should define a hidden symbol <code>__dso_handle</code>,
with a value which is an address in one of the object's segments.
(It doesn't matter what address,
as long as they are different in different DSOs.)
It should also include a call to the following function in the FINI
list (to be executed first):
<center><code>
void __cxx_finalize ( dso_handle d );
</code></center>
The parameter passed should be <code>__dso_handle</code>.

<p>
Note that the above can be accomplished either by explicitly providing
the symbol and call in the linker, or by implicitly including a
relocatable object in the link with the necessary definitions,
using a .fini_array section for the FINI call.
Also, note that these can be omitted for an object with no calls to
<code>__cxx_atexit</code>, but they can be safely included in all objects.

<p>
Finally, a main program should be linked with a FINI call to
<code>__cxx_finalize</code> with NULL parameter.

<p>
When <code>__cxx_finalize(d)</code> is called,
it should walk the termination function list,
calling each in turn if <code>d</code> matches
<code>__dso_handle</code> for the termination function entry.
If <code>d == NULL</code>, it should call all of them.
Multiple calls to <code>__cxx_finalize</code> should not result in
calling termination function entries multiple times;
the implementation may either remove entries or mark them finished.

<p>
<font color=red>
Issue: By passing a NULL-terminated vector of DSO handles to
<code>__cxx_finalize</code> instead of one,
we could deal with unloading multiple DSOs at once.
However, <code>dlclose</code> closes one at a time,
so I'm not sure the extra complexity is worthwhile.
</font>

</ol>

<p>
Since <code>__cxx_atexit</code> and <code>__cxx_finalize</code>
must both manipulate the same termination function list,
they must be defined in the implementation's C++ runtime library,
rather than in the individual linked objects.




<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C4></a> <td> C-4 </td>
<td> Construction vtables </td>
<td> call </td>
<td> open </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
When calling a virtual function from the constructor/destructor of a
base subobject,
the version specific to the base type is required,
unlike the typical case when calling such a vfunc for the full object
from some other context.
Since the pointer for that vfunc in the the subobject's sub-vtable
of the full object's vtable is the full object version,
some other means is required for accessing the correct vfunc.
</td> </tr>

</table>

<p>
<font color=blue>[990630 HP -- Christophe]</font>
A rough idea from Christophe's original vtable layout proposal
has been incorporated in the
<a href=abi-layout.html#vtable-ctor>ABI data layout document</a>.

<p>
<font color=blue>[991104 All]</font>
Daveed will write this up precisely.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C5></a> <td> C-5 </td>
<td> Calling destructors </td>
<td> call </td>
<td> closed </td>
<td> Sun </td>
<td> 990603 </td>
<td> 991104 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What is the calling convention for destructors?
Do virtual destructors require special treatment?
Is delete() integrated with the destructor call or separate?
How is delete() handled when invoked on a base subobject?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
Destructors are called with a reference to <i>this</i>.
Virtual destructors have two versions, and two entries in the vtable,
one that deletes the object after destruction, and one that doesn't.
There is a third version that does not delete the object,
and is not in-charge, i.e. does not destroy any base objects;
it is not called via the vtable.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C6></a> <td> C-6 </td>
<td> Extra parameters to constructors </td>
<td> call </td>
<td> closed </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> 991104 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
When calling constructors for classes with virtual bases,
what information about the treatment of virtual base subobjects
in the full class, or about object allocation,
must be transmitted to the constructor in parameters?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
None.
Two versions, and two entrypoints,
of the constructor will be created:
one that calls the virtual base subobject constructor (in-charge),
and one that does not.
Object allocation will be done by the caller.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C7></a> <td> C-7 </td>
<td> Passing value parameters by reference </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 990624 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It may be desirable in some cases where a type has a non-trivial
copy constructor to pass value parameters of that type by performing
the copy at the call site and passing a reference.
</td> </tr>
<tr> <td colspan=7>
<b> Resolution </b>:
Whenever a class type has a non-trivial copy constructor,
pass value parameters of that type by performing
the copy at the call site and passing a reference.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C8></a> <td> C-8 </td>
<td> Returning classes with non-trival copy constructors </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 990625 </td>
<td> 990722 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How do we return classes with non-trivial copy constructors?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
The caller allocates space,
and passes a pointer as an implicit first parameter
(prior to the implicit <i>this</i> parameter).
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C9></a> <td> C-9 </td>
<td> Passing parameters with ctors/dtors </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 991028 </td>
<td> 991104 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where do allocation, construction, destruction, and deallocation occur
for value parameters?
</td> </tr>
<tr> <td colspan=7>
<b>Summary</b>:
See the description in the
<a href=cxx-closed.html#C9>closed issues list</a>.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C10></a> <td> C-10 </td>
<td> Synthesized copy assignments </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 991028 </td>
<td> 991028 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Should we specify special treatment for synthesized copy assignments,
to avoid multiple copies of virtual bases?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
No.
</td> </tr>

</table>


<p> <hr> <p> <a name=D0></a>
<h3> Exception Handling Issues </h3>

<p>
For reference, we have design information as follows:

<ul>
<p>
<li>
<font color=blue>[990818 Intel -- Priti]</font>
<a href=Intel-exception-990818.ppt> (PowerPoint document) </a>

<p>
<li>
<font color=blue>[990818 HP -- Christophe]</font>
<a href=HP-exception-990818.pdf> (PDF document) </a>

</ul>

<p>
<font color=blue>[990902 All]</font>
We observed that there are three levels at which we can discuss EH
compatibility.

<p>
The first, minimal level is effectively that of the definition in the
IA-64 Software Conventions document.
It describes a framework which can be used by an arbitrary implementation,
with a complete definition of the stack unwind mechanism,
but no significant constraints on the language-specific processing.
In particular, it is not sufficient to guarantee that two object files
compiled by different C++ compilers could interoperate,
e.g. throwing an exception in one of them and catching it in the other.

<p>
The second level is the minimum that must be specified to allow
interoperability in the sense described above.
This level requires agreement on:

<ul>
<p>
<li>
Standard runtime initialization,
e.g. pre-allocation of space for out-of-memory exceptions.

<p>
<li>
The layout of the exception object created by a throw and processed by
a catch clause.

<p>
<li>
When and how the exception object is allocated and destroyed.

<p>
<li>
The API of the personality routine,
i.e. the parameters passed to it,
the logical actions it performs,
and any results it returns
(either function results to indicate success, failure, or continue,
or changes in global or exception object state),
for both the phase 1 handler search and the phase 2 cleanup/unwind.

<p>
<li>
How control is ultimately transferred back to the user program at a
catch clause or other resumption point.
That is, will the last personality routine transfer control directly to
the user code resumption point,
or will it return information to the runtime allowing the latter to do so?

<p>
<li>
Standard runtime initialization,
e.g. pre-allocation of space for out-of-memory exceptions.

<p>
<li>
Multithreading behavior.

</ul>

<p>
The third level is a specification sufficient to allow all compliant
systems to share the relevant runtime implementation.
It includes, in addition to the above:

<ul>
<p>
<li>
Format of the C++ language-specific unwind tables.

<p>
<li>
APIs of the functions named __allocate_exception, __throw, and
__free_exception (and likely others) by HP, or their equivalents.

<p>
<li>
API of landing pad code,
and of any other entries back into the user code.

<p>
<li>
Definition of what HP calls the exception class value.

</ul>

<p>
The vocal attendees at the meeting wish to achieve the third level,
and we will attempt to do so.
Whether or not that is achieved, however,
a second-level specification must be part of the ABI.

<p>
<li>
<font color=blue>[990909 All/Jim]</font>
With much further discussion,
we are starting to get better understanding of one another,
but there are still obviously (in my mind)
mismatched underlying assumptions.
To resolve this, Christophe agreed to attempt to get us the
HP APIs for the exception handling routines.
I have also started a
<a href=abi-eh.html>document</a> on a more complete EH specification,
though it hasn't gone beyond specifying more of the underlying base ABI part.
I will go farther once I get back from my trip.

<p>
<li>
<font color=blue>[990922 HP -- Christophe]</font>

<P>Here is a quick description of the personality routine interface
and semantics. This description is a slight extension of the existing
personality routine implemented by HP for IA64. The extension is to
allow multiple runtimes from possibly different vendors or for
possibly different languages to cooperate in processsing an
exception.</P>

<P>This document assumes that the chapter 11 of the Intel/HP &quot;IA-64 =
Software Conventions and Runtime Architecture&quot; document is known to =
the reader.</P>

<P><B><I><FONT SIZE=3D5>INTERFACE:</FONT></I></B></P>

<P>The complete exception processing framework consists of at least the =
following routines: <TT>_RaiseException</TT>, <TT>_ResumeUnwind</TT>, =
<TT>_DeleteException</TT>, <TT>_Unwind_getGR</TT>, =
<TT>_Unwind_setGR</TT>, <TT>_Unwind_getIP</TT>, <TT>_Unwind_setIP</TT>, =
<TT>_Unwind_getLanguageSpecificData</TT>, =
<TT>_Unwind_getRegionStart</TT>. In addition, a language and vendor =
specific personality routine will be stored by the compiler in the =
unwind descriptor for the stack frames requiring exception =
processing.</P>

<P><B><FONT SIZE=3D4>UNWIND RUNTIME ROUTINES:</FONT></B></P>

<P>The unwind runtime routines have the following interface and =
semantics (all routines are <TT>extern &quot;C&quot;</TT>):</P>

<P><TT>uint64 _RaiseException</TT><TT>(uint64 exception_class, void =
*exception_object);</TT></P><BLOCKQUOTE>

<P>Raise an exception, passing along the given exception class and =
exception object. The exception object has been allocated by the =
language-specific runtime, and has a language-specific format. =
<TT>_RaiseException</TT> does not return, unless an error condition is =
found (such as no handler accepting to handle the exception, bad stack =
format, etc).</P>The first 4 words (32 bytes) of the exception object =
are allocated for use exclusively by the unwinder, and should not be =
written by the personality routine or other parts of the =
language-specific runtime. The first word is used to store the exception =
class. The second word points to the personality routine of the frame =
that threw the exception intially. The two next words are reserved for =
use by the unwinder. [Note: Typical use is to keep the state of the =
unwinder while executing user code, such as our current frame_handle =
pointer.]</BLOCKQUOTE>

<P><TT>void _ResumeUnwind (void =
*exception_object);</TT></P><BLOCKQUOTE>Resume propagation of an =
existing exception. [Note: _ResumeUnwind should not be used to implement =
rethrowing. To the unwinding runtime, the catch code that rethrows was a =
handler, and the previous unwinding session was terminated before =
entering it.] [Note:&nbsp;Compared to HP runtime, the exception class =
and frame handle arguments have been removed. They also need no longer =
be passed to the landing pads. Instead, the unwinder will store the =
information in one of its 2 reserved words.]</BLOCKQUOTE>

<P><TT>void _DeleteException(void =
*exception_object);</TT></P><BLOCKQUOTE>If a given runtime resumes =
normal execution after catching a foreign exception, it will not know =
how to delete that exception. This exception will be deleted by calling =
<TT>_DeleteException</TT>, which in turn will delegate the task to the =
original personality routine (see <TT>EH_DELETE_EXCEPTION_OBJECT</TT> =
below).</BLOCKQUOTE>

<P><TT>uint64 _Unwind_getGR(void *context, int index);<BR>uint64 =
_Unwind_getIP(void *context);<BR>void _Unwind_setGR(void *context, int =
index, uint64 new_value);<BR>void _Unwind_setIP(void *context, uint64 =
new_value);</TT></P><BLOCKQUOTE>Get or set registers from the given =
unwinder context. The 'context' argument is the same argument passed to =
the personality routine (see below).[Note: Minor changes compared to the =
existing unwinding interface, mostly to hide the register =
classes]</BLOCKQUOTE>

<P><TT>uint64 _Unwind_getLanguageSpecificData(void =
*context)</TT></P><BLOCKQUOTE>Get the address of the language-specific =
data area for the current stack frame. The '<TT>context</TT>' argument =
is the same argument passed to the personality routine.[Note: This is =
not stricly required: it could be accessed through getIP using the =
documented format of the UnwindInfoBlock, but since this work has been =
done for finding the personality routine in the first place, it makes =
sense to cache the result in the context, as we currently =
do]</BLOCKQUOTE>

<P><TT>uint64 _Unwind_getRegionStart(void =
*context)</TT></P><BLOCKQUOTE>Get the address of the beginning of the =
current procedure or region of code. [Note: This is required for us =
because we store data relative to the beginning of the code. So let's =
make it mandatory ;-]</BLOCKQUOTE>

<P><B><FONT SIZE=3D4>PERSONALITY ROUTINE:</FONT></B></P>

<P>The personality routine is defined with the following =
interface:</P><BLOCKQUOTE><TT>int =
PersonalityRoutine<BR>&nbsp;&nbsp;&nbsp;&nbsp;(int =
version,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int =
phase,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;UInt64 =
exceptionClass,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void * =
exceptionObject,<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;void =
*context);</TT></BLOCKQUOTE>

<P>[Note: the frame_handle argument has been removed: it was used only =
once in the runtime, and the cost of reading it back from the exception =
object is really minimal, compared to the cost of having to spill it in =
all landing pads... The context argument type has been made opaque]</P>

<P></P>

<P>The arguments have the following role and meanings:</P><UL><LI>

<P><B>version</B>: Version number that the compiler and personality =
routine agree on, identifying for instance language-specific table =
format. This version number is read from the unwind information block =
(unwind tables)</P></LI></UL><UL><LI>

<P><B>phase</B>: Indicates what processing the personality routine is =
supposed to perform. The possible actions are described below under =
'<B>UNWINDING PHASES</B>'</P></LI></UL><UL><LI>

<P><B>exceptionClass</B>: An 8-bytes identifier specifying the type of =
the thrown exception. By convention, the high 4 bytes indicate the =
vendor (for instance HP\0\0), and the low 4 bytes indicate the language =
(for instance C++\0.) [Note: For C++, it is expected that agreement will =
be reached on a common 'exceptionObject', but different vendors may =
still chose to have different personality routines with different table =
formats.]</P></LI></UL><UL><LI>

<P><B>exceptionObject</B>: The pointer to a memory location recording =
the necessary information for processing the exception according to the =
semantics of a given language. [Note: For C++, it is assumed that the =
format of this exception object can be agreed upon, even if we disagree =
on the LSDA and/or landing pad registers or similar =
details.]</P></LI></UL><UL><LI>

<P><B>context</B>: Unwinder state information for use by the personality =
routine. This is used by the personality routine in particular to access =
the frame's registers. [Note: I don't see how anything could work =
without a minimal common unwinder interface - which is why it has been =
defined above]</P></LI></UL><UL><LI>

<P><B>return value</B>: The return value from the personality routine =
indicates how further undinwind should happen, as well as possible error =
conditions. See &quot;<B>UNWINDING&nbsp;PHASES</B>&quot; below for =
details.</P></LI></UL>

<P><B><FONT SIZE=3D4>UNWINDING&nbsp;PHASES</FONT></B></P>

<P>Unwinding is a 2-phases process.</P><UL><LI>

<P>PASS 1 unwinds through the stack, looking for a &quot;handler&quot;, =
that is a code that has the potential to stop the exception propagation. =
For C++, this would be a 'catch' clause. The first pass can do a =
&quot;quick&quot; unwind, meaning it does not need to maintain full =
registers state.</P></LI></UL><UL><LI>

<P>PASS 2 starts once a handler has been found. For each stack frame =
that requires some cleanup, it performs that cleanup. For C++, this =
would be destructors in addition to catch clauses. If compensation code =
for some optimization is required, this is also the pass this code will =
be executed. During that pass, the stack is actually unwound, and full =
register state is restored prior to executing any cleanup, compensation =
or handler code.</P></LI></UL>

<P>[Note: Cleanup code is code doing some user-defined cleanup such as =
destructors. Compensation code is code inserted by the compiler to =
compensate for an optimization that moved code past the throwing call. =
Handler code is user-defined code that possibly can resume normal =
execution]</P>

<P>The unwinding phase argument to the personality routine is a bitwise =
or of the following constants:</P><UL><LI><TT>EH_SEARCH_PHASE</TT> =3D =
1: Indicates that the personality routine should check if the current =
frame contains a handler, and if so return <TT>EH_HANDLER_FOUND</TT>, or =
otherwise return <TT>EH_CONTINUE_UNWIND</TT>. <TT>EH_SEARCH_PHASE</TT> =
cannot be set at the same time as =
<TT>EH_CLEANUP_PHASE</TT>.</LI></UL><UL><LI><TT>EH_CLEANUP_PHASE</TT> =3D =
2: Indicates that the personality routine should perform cleanup for the =
current frame. The personality routine can perform this cleanup itself, =
by calling nested procedures, and return <TT>EH_CONTINUE_UNWIND</TT> [ =
Note: This is required to support the Intel nested procedures model]. =
Alternatively, it can setup the registers (including the IP) for =
transferring control to a &quot;landing pad&quot;, and return =
<TT>EH_INSTALL_HANDLER</TT> (See &quot;<B>TRANSFERRING CONTROL TO A =
LANDING PAD</B>&quot; below).</LI></UL><UL><LI><TT>EH_HANDLER_FRAME</TT> =
=3D 4: During pass 2, indicates to the personality routine that the =
current frame is the one which was flagged as the handler frame during =
pass 1.</LI></UL><UL><LI><TT>EH_DELETE_EXCEPTION_OBJECT</TT> =3D 8: =
During pass 2, indicates that the runtime that actually caught the =
exception does not know how to delete it, and called =
<TT>_DeleteException</TT>. '<TT>context</TT>' should not be used in that =
case.</LI></UL><UL><LI><TT>EH_FATAL_PASS2_ERROR</TT> =3D 16:&nbsp;During =
pass 2, indicates that a fatal unwinding error occured. In that case, =
the personality routine should not return. This is sent to the original =
personality routine associated to the initial exception object. [Note: =
This is required if we want to ensure that <TT>_ResumeUnwind</TT> never =
returns, and if we also want to be able to call <TT>terminate() </TT>in =
the case a stack inconsistency is found during pass 2. An error detected =
during pass 1 is reported by returning from =
<TT>_RaiseException</TT>.]</LI></UL><UL><LI>

<P><TT>EH_FORCE_UNWIND</TT> =3D 32:&nbsp;During pass 2, indicates that =
no language is allowed to &quot;catch&quot; the exception. This flag is =
set while unwinding the stack for setjmp or during thread cancellation. =
User-defined code in a catch clause may still be executed, but the catch =
clause has to resume unwinding at its end.</P></LI></UL>

<P><FONT SIZE=3D4><B>TRANSFERRING CONTROL TO A LANDING =
PAD:</B></FONT></P>

<P>In the case the personality routine wants to transfer control to a =
landing pad, it setups registers (including IP) to suitable values for =
entering the landing pad. Prior to executing code in the landing pad, =
registers not altered by the personality routine will be restored to the =
exact state they were in that frame before the call that threw the =
exception.</P>

<P>The landing pad can either resume execution to normal (as, for =
instance, at end of a C++ <TT>catch</TT>), or resume unwinding by =
calling the <TT>_ResumeUnwind</TT> function and passing it the =
'<TT>exceptionObject</TT>' argument received by the personality routine. =
<TT>_ResumeUnwind</TT> will never return.</P>

<P><TT>_ResumeUnwind</TT> should be called if and only if the =
personality routine did not return <TT>EH_HANDLER_FOUND</TT> during =
phase 1. In other words, the unwinder can allocate some resources (for =
instance memory) and keep track of them in the exception object reserved =
words. It should then free these resources before transferring control =
to the last (handler) landing pad. It does not need to free the =
resources before entering non-handler landing-pads, since =
<TT>_ResumeUnwind</TT> will ultimately be called.</P>

<P>The landing pad will receive various arguments from the runtime, =
typically passed in registers set using <TT>_Unwind_setGR</TT> by the =
personality routine. For a landing pad that can lead to =
<TT>_ResumeUnwind</TT>, one argument must be the =
<TT>exceptionObject</TT> pointer, which must be preserved to be passed =
to <TT>_ResumeUnwind</TT>. [Note: Thanks to the 4 reserved words in the =
exception object, 2 landing-pad arguments have been eliminated.] The =
landing pad may receive other arguments, for instance a 'switch value' =
indicating the type of the exception being caught.</P>

<P><B><FONT SIZE=3D4>RULES FOR CORRECT INTER-LANGUAGE =
OPERATION:</FONT></B></P>

<P>The following rules must be observed for correct operation between =
languages and/or runtimes from different vendors:</P><UL><LI>

<P>An exception which has an unknown class must not be altered by the =
personality routine. The semantics of foreign exception processing =
depend on the language of the stack frame being unwound. This covers in =
particular how exceptions from a foreign language are mapped to the =
native language in that frame.</P></LI></UL><UL><LI>

<P>If a runtime resumes normal execution, and the caught exception was =
created by another runtime, it should call <TT>_DeleteException</TT>. =
This is true even if it understands the exception object format (such as =
would be the case between different C++ runtimes). [Note:&nbsp;This is =
because the other runtime might have to update some global variables =
that point to the exception being deleted.]</P></LI></UL><UL><LI>

<P>A runtime is not allowed to catch an exception if the =
EH_FORCE_UNWIND&nbsp;flag was passed to the personality =
routine.</P></LI></UL>

<P><B><FONT SIZE=3D4>CATCHING FOREIGN EXCEPTIONS IN C++</FONT></B></P>

<P>Foreign exception can be caught in a <TT>catch(...)</TT>. They can =
also be caught as if they were of a <TT>__foreign_exception</TT> class, =
defined in <TT>&lt;exception&gt;</TT>. [Note:&nbsp;The =
<TT>__foreign_exception</TT> may have subclasses, such as =
<TT>__java_exception</TT> and <TT>__ada_exception</TT>, if the runtime =
is capable of identifying some of the foreign languages.]</P>

<P>The behavior is undefined in the following cases:</P><UL><LI>

<P>A <TT>__foreign_exception</TT> catch argument is accessed in any way =
(including taking its address).</P></LI></UL><UL><LI>

<P>A <TT>__foreign_exception</TT> is active at the same time as another =
exception (either there is a nested exception while catching the foreign =
exception, or the foreign exception was itself =
nested)</P></LI></UL><UL><LI>

<P><TT>uncaught_exception()</TT>, <TT>set_terminate()</TT>, =
<TT>set_unexpected()</TT>, <TT>terminate()</TT> or <TT>unexpected()</TT> =
is called at a time a foreign exception exists (for instance, calling =
<TT>set_terminate</TT>() during unwinding of a foreign =
exception)</P></LI></UL>

<P>[Note: All these cases might involve accessing the C++ specific =
content of the thrown exception, for instance to chain active =
exceptions]</P>

<P>Otherwise, a catch block catching a foreign exception is =
allowed:</P><UL><LI>

<P>To resume normal execution, thereby stopping propagation of the =
foreign exception and deleting it,</P></LI><LI>

<P> Or to rethrow the foreign exception. In that case, the original =
exception object should have been unaltered in any way by the =
C++&nbsp;runtime.</P></LI></UL>

<P>A catch-all block may be executed during forced unwinding. For =
instance, a setjmp may execute code in a catch(...) during stack =
unwinding. However, if this happens, unwinding will proceed at the end =
of the catch-all block, whether or not there is an explicit =
rethrow.</P>Setting the low 4 bytes of exception class to C++\0 is =
reserved for use by C++&nbsp;runtimes compatible with the common =
C++&nbsp;ABI.

<p>
<li>
<font color=blue>[990923 All]</font>
Extensive discussion at the meeting was generally positive about the HP
proposal.
Several changes came up, ranging from editorial to substantive.
Christophe will modify the specification.

<ul>
<p>
<li>
Use <i>doubleword</i> instead of <i>word</i> for 8-byte items.

<p>
<li>
By the time the personality routine is called,
the runtime either knows where the language-specific data area is,
or can get it trivially.
Therefore, pass it to the personality routine,
instead of providing _Unwind_getLanguageSpecificData.

<p>
<li>
Most references to <code>setjmp</code> in the document should be to
<code>longjmp</code>.

<p>
<li>
The description of EH_DELETE_EXCEPTION_OBJECT was unclear.

<p>
<li>
Clarify the distinction between passes 1 and 2, and the final steps
(which are generally referred to as pass 2).

<p>
<li>
The group agreed that the performance benefit of allowing a simplified
setjmp which supports only a full-unwinding longjmp
is outweighed by the interoperability benefit of having a single setjmp
which will support either a C-style direct or a C++ full-unwind longjmp.

<p>
<li>
We will follow the lead of IBM (?) and specify a distinct longjmp call
which is defined to do a full-unwind longjmp.

<p>
<li>
Pthreads cancellation will be supported by specifying:
  <ul>
  <li> New exceptions (cancel and exit).
  <li> catch(...) always rethrows.
  <li> catch(...) catches anything, including foreign languages.
  </ul>

</ul>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D1></a> <td> D-1 </td>
<td> Language-specific data area format </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA-64 runtime conventions describe language-independent descriptors
for restoring registers when unwinding the stack.
The do not specify how C++ performs language-specific unwinding for
exception handling, i.e. locating a handler and destroying automatic
objects.
Note that this can be handled by agreeing on common descriptors,
or by agreeing on per-frame personality routines with common APIs.
</td> </tr>

</table>

<p>
<font color=blue>[990715 Cygnus -- Jason]</font>
The languge-specific part of the EH stack in g++ contains these
elements:

<p>
<code><pre>
void *value; // pointer to the thrown object, or the thrown value
             // itself if a pointer
void *type;  // pointer to the type_info node for the thrown object
void (*cleanup)(void *, int) // pointer to the dtor for the object
bool caught; // has this exception been caught since its last throw?
long handlers; // how many catch handlers are active for this exception
</code></pre>

<p>
Both 'caught' and 'handlers' are needed to handle rethrowing and
catching within a catch block.

<p>
Language interaction is handled by recording the language of both the
exception region and the thrown exception.  Each thrown exception also
includes a pointer to a language-specific matching function which is
called to compare the types of the exception and handler.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D2></a> <td> D-2 </td>
<td> Unwind personality routines </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA-64 runtime conventions provide for a personality routine
pointer for language-specific actions when unwinding the stack.
They do not specify its interface.
There are typically two required actions for C++:
locating a handler (non-destructively)
and destroying automatic objects while unwinding.
This issue involves specification of the API (see also D-3).
</td> </tr>

</table>

<p>
<font color=blue>[990826 Intel/HP]</font>
The Software Conventions document is claimed to specify the interface,
with the parameters indicating which action is required.
(I can't find it, but this would be an acceptable solution -- Jim.)

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D3></a> <td> D-3 </td>
<td> Unwind process clarification </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA-64 runtime conventions provide for a personality routine
pointer for language-specific actions when unwinding the stack.
However, they are quite muddy about the precise sequence of calls.
This issue involves specification of unwind process (see also D-2).
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D4></a> <td> D-4 </td>
<td> Unwind routines nested? </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA-64 runtime conventions call for the unwind personality routine
to behave like a routine nested in the routine raising an exception.
Is that the preferred definition?
</td> </tr>

</table>

<p>
<font color=blue>[990902 All]</font>
Discussion reveals that Intel and HP have very different models of how
cleanup actions are handled.

<p>
Intel builds one or more routines which are called from the unwind runtime,
based on action descriptors in the unwind tables,
and acting on the stack contents or objects to be destroyed
without actually modifying the stack pointer until the final transfer
of control to the user handler.
This approach avoids actually restoring registers until the final
transfer to the handler.

<p>
HP transfers control back to a user landing pad whenever anything needs
to be done -- descriptors or handlers --
and reenters the unwind runtime if further processing is required.
They believe this approach to use much less space than the action
descriptors would,
and most importantly,
that it allows arbitrary fixup for code motion around the call that throws.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D5></a> <td> D-5 </td>
<td> Interaction with other languages (e.g. Java) </td>
<td> lib ps </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 991007 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA64 exceptions handling framework is largely language independent.
What is the behaviour of a C++ runtime receiving, for instance,
an exception thrown from Java?
Does it call terminate()?
Does it allow the exception to pass through C++ code with destructors
if there is no catch clause?
Does it allow the exception to be caught in a catch(...) provided this
catch(...) ends with a rethrow?
Does it allow even more?
</td> </tr>
<b>Resolution</b>:
In general, foreign exceptions will cause normal destructor invocation
and other cleanup in C++ code, and will pass through C++ frames except
where explicit exception specifications do not allow them.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D6></a> <td> D-6 </td>
<td> Allow resumption in other languages? </td>
<td> lib ps </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 991007 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The exception handling framework requires the interaction of the
runtime of all the languages "on the stack" during exception processing.
Some of these languages may have very different exception handling semantics.
What are the constraints we impose on the C++ exception handling runtime
to preserve the relative language neutrality of the EH framework?
Example: do we allow a handler to cleanup and resume at the point
where the exception was thrown?
</td> </tr>
<b>Resolution</b>:
Moot -- resume-type exceptions are more appropriately handled by
registering trap handlers and processing them in place.
No interaction with stack traceback should be necessary.
</td> </tr>

</table>

<p>
<font color=blue>[990908 SGI -- Jim]</font>
The typical case of cleanup and resume is floating point trap handling,
which is normally handled entirely in the original FP trap handler.
Is there an example where stack walkback must occur to identify the
handler, but resumption at the point-of-exception is required?
I can't think of any, and I think the model of registering a trap
handler is preferable for such purposes.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D7></a> <td> D-7 </td>
<td> Interaction with signals or asynch events </td>
<td> lib ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The Standard says that the behavior of anything other than
"pure C code" (POF) is implementation defined,
and warns (in a note) against using EH in a signal handler.
We should define what is supported,
possibly explicitly stating that signal handler code must be a POF.
We could allow any feature but exception handling to be used.
We could allow some EH routines to be called
(for instance, <code>uncaught_exception()</code>).
Or we could allow even an exception to be thrown,
if it does not exit the handler.
</td> </tr>

</table>

<p>
<font color=blue>[991006 All]</font>
This common ABI will not allow throwing exceptions from a signal handler.

<p>
<font color=blue>[991007 All]</font>
There remains concern about how to help customers
(examples were presented of big database applications)
for which raising exceptions from signal handlers for I/O failures
is a highly desirable design.
We will revisit this issue.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D8></a> <td> D-8 </td>
<td> Interaction with threads packages </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What happens when an exception is not caught in the thread where raised?
What does uncaught_exception() return if another thread is currently
processing an exception?
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D9></a> <td> D-9 </td>
<td> longjmp interaction </td>
<td> lib ps </td>
<td> open </td>
<td> IBM </td>
<td> 990908 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Does longjmp run destructors?
</td> </tr>

</table>

<p>
<font color=blue>[990908 IBM -- Mendell]</font>
Does longjmp run destructors?
I believe that the C ABI makes this optional.
I would like to propose that it does run destructors.

<p>
<font color=blue>[990908 SGI -- Wilkinson]</font>
The C++ standard, 18.7 paragraph 4,
says a call to longjmp has undefined behavior if any automatic objects
would have been destroyed by a
throw/catch with the same source and destination.
I don't see that this is something we need to fix.

<p>
<font color=blue>[990908 IBM -- Thomson]</font>
Yes it does, but ANSI is not my customer.
Meeting the bare minimum of function that ANSI requires
doesn't necessarily mean that users can build robust applications.
How can they know to avoid longjmp in their C code,
because some third party library they are using has C++ buried in it?

<p>
<font color=blue>[990908 SGI -- Dehnert]</font>
Implementation is a significant issue.
The normal longjmp implementation is very simple --
setjmp stores the register/stack state,
and longjmp copies it back and branches.
There is normally no traceback involved,
so what you suggest is a dramatic change,
and probably would make C people very unhappy.
Furthermore, C++ users have the option of using C++ exceptions,
which have the effect you seek.

<p>
<font color=blue>[990908 SGI -- Boehm]</font>
The problem is that on the C side:

<ol>
<p>
<li>A number of thread packages use setjmp/longjmp to perform context switches.
    In this case,
    the target sp is not on the same stack as the original sp,
    and there should not be any destructor invocations,
    since the original thread will be resumed,
    and the original sp will eventually be restored.
    (This isn't the optimal way to do thread switching,
    but it's the only one that's semi-portable,
    and hence it's moderately common.)

<p>
<li>Some variants of longjmp are often used to jump out of signal handlers,
    which may not be invoked on the original user stack
    (cf. sigaltstack on most Unix systems).
    Thus unwinding may have to cross stack boundaries.

<p>
<li>Setjmp is often used to capture the register state,
    e.g. for garbage collectors.
    (The collector I'm responsible for optionally does this.
    Last I looked, Guile did it unconditionally.)
    A straightforward stack-unwinding implementation of setjmp/longjmp
    would break this.
</ol>

<p>
I don't know whether it's possible to avoid breaking these clients
while providing the stack-unwinding semantics.

<p>
<font color=blue>[990908 IBM -- Mendell/Thomson]</font>
[VisualAge C++] on OS/2 and Windows does do the unwinding.
This is probably because unwinding support is in the OS.
Also OS/390 and I believe AS/400 too.
Our AIX implementation does not do the unwinding.

<p>
<font color=blue>[990909 DEC -- Brender]</font>
In addition to the systems already mentioned by
others, these systems also do exception-handling compatible unwinding
for C's setjmp/longjmp:

<ul>
<li> VMS/VAX and VMS/Alpha:
    Tru64 Unix/Alpha [not originally, but at least as of V4]
<li>
    Microsoft Visual C on W95&WNT/IA32:
       [to support SEH (structured exception handling) extensions]
	(probably also on IA64 for compatibility reasons)
<li>
    Microsoft Visual C on WNT/Alpha (RIP):
       [to support SEH]
</ul>

<p>
If you believe in safe and compatible multi-language systems,
there really is no choice but to do EH compatible unwinding for
setjmp/longjmp -- at least by default.

<p>
I suppose it would be OK for an implementation to offer an alternate
setjmp/longjmp that could be linked in for those who either know that
it is safe in particular cases or are happy to trade safety for speed...

<p>
<font color=blue>[990909 All]</font>
A brief discussion agreed that concensus is not absolutely necessary.
An implementation could replace setjmp/longjmp with a version that
either unwinds or justs restores and jumps,
without breaking any code except that which assumed one or the other.
(Ed.:  In fact, if setjmp stores enough information to either restore
or to catch an exception, one could just swap longjmp,
although that would not be optimal for the unwind and catch case,
since setjmp doesn't need to save much information in that case
as most of what is needed is in the unwind descriptors.)

<p>
<font color=blue>[990923 All]</font>
We agreed that:
<ul>
<p>
<li>
We will use a single setjmp which retains enough information for a
traditional C direct longjmp.

<p>
<li>
We will define a new longjmp call which always does full unwinding.

<p>
<li>
Implementations may implement longjmp as either the direct or the
full-unwind form, as a default, or using a user option.

<p>
<li>
catch(...) will catch all exceptions, including foreign-language ones.
It will always rethrow.
</ul>

<p>
See the HP low-level exception writeup at the beginning of the
exception issues section.


<p> <hr> <p>
<h3> Template Instantiation Model Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>


<tr> </tr>
<tr> <th> E </th>
<th colspan=6> Template Instantiation Model </th>
</tr>

<tr> <a name=E1></a> <td> E-1 </td>
<td> When does instantiation occur? </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
There are two principal models for instantiation.
The <i>early instantiation</i> (or Borland) model performs all
instantiation at compile time,
potentially resulting in extra copies which are removed at link time.
The <i>pre-link instantiation</i> model identifies the required
instantiations prior to linking and instantiates them via a special
compile step.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=E2></a> <td> E-2 </td>
<td> Separate compilation model </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[SGI]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=E3></a> <td> E-3 </td>
<td> Template repository </td>
<td> tools </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Independent of the template instantiation model,
we need to make sure that whatever template persistent storage is used
by one vendor does not interact negatively with other vendors' mechanisms.
Issues:
  (1) Avoiding conflict on the name of any repository.
  (2) If .o files are used,
	describe how this information is to be preserved, ignored, etc.
  (3) Evaluate if tools such as make, ld, ar, or others, can
	break because .o files get written at unexpected times.
</td> </tr>

</table>

<p> <hr> <p>
<h3> Name Mangling Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F1></a> <td> F-1 </td>
<td> Mangling convention </td>
<td> call </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What rules shall be used for mangling names,
i.e. for encoding the information other than the source-level object
name necessary to resolve overloading?
</td> </tr>

</table>

<p>
<font color=blue>[991019/28 various]</font>
The following is assembled from several mail messages on the subject.

<p>
<h5> Objectives of the mangling scheme include:</h5>
<p>
<ul>
<p>
<li>
Compression:  It is critical that name length be minimized (issue F-2).

<p>
<li>
Character set:  Names should use a character set that does not cause
problems in linkers (easy for Elf) or in assemblers (more problematic).
This probably implies use of ~64 characters.

<p>
<li>
Legibility:  It is desirable that the base name (i.e. the function or
class name) be present and easy to identify (for readability).
Other components of the name probably need to be difficult in order to
attain compression (issue F-2).

<p>
<li>
Cfront:  It is desirable that the names <b>not</b> be confusable with
cfront manglings, to avoid apparent but incomplete compatibility with
cfront-compiled objects.

</ul>

<p>
<h5> Entities with linkable names to be resolved include:</h5>
<p>
<ul>
<li> Global and member operator names
<li> Global and member function names
<li> Alternate versions of constructors/destructors.
<li> Namespace scope variables
<li> Static local variables
<li> Static data members
<li> Virtual function table names (primary and initialization)
<li> RTTI structures (std::type_info derivations)
<li> Template instances of the above
<li> Namespace effects on the above (including anonymous namespaces)
<li> Possibly exception handling structures
<li> Possibly string constants
</ul>

<p>
For entities with C name linkage,
the entity's linkable name is identical to its base name (as usual).

<p>
Note that linkable names include not only names with
C++ global scope semantics,
but also "local" names which for some reason end up
requiring linker resolution
(e.g. static local variables declared in inline functions).
Note also that inlining requirements apply equally to functions
declared inline and those chosen to be inlined by the compiler.

<p>
<h5> Name decomposition for function-like entities:</h5>
<p>
For function-like entities with C++ name linkage,
the following components MUST be part of the of the name:
<ul>
<li> encoding of the base name (presumably, the base name itself)
<li> encoding of the declarative scope (classes and namespaces),
    when applicable
<li> encoding of each parameter type (with known positions)
<li> encoding of each template argument
    and the parameter with which it is associated, when applicable
</ul>

<p>
[ For the last item, consider: <code>
<pre>    template<typename T1, typename T2> void f(T1, T2);
    template<typename T1, typename T2> void f(T2, T1);
</pre></code>
The encoding of each of these templates instantiated for <char, char>
should be distinct. ]

<p>
In addition, it may be desirable to encode the following components:
<ul>
<li> the function's return type
<li> the function's exception specifications
</ul>
(Combined with the parameter types,
this encodes the type of the function.
Note that even though exception specifications are not
considered part of the function type in the C++ standard;
they actually are.)

<p>
<h5> Name decomposition for data entities:</h5>
<p>
Namespace scope variables and static data members have
linkable names that must include at least:
<ul>
<li> encoding of the base name (presumably, the base name itself)
<li> encoding of the declarative scope (classes and namespaces),
    when applicable
</ul>

In addition, it may be desirable to encode:
<ul>
<li> the variable's type (possibly including exception specifications)
</ul>
<p>
Note that although there are benefits to encoding array size,
and therefore being able to catch mismatches,
the ability to declare <code>a[]</code> makes this problematic.

<p>
<h5> Fundamental types and type operators:</h5>

<p>
fundamental types:
<ul>
<li> void
<li> [signed|unsigned] {
<li> char, short, int, long} (long long?, int<n>_t)
<li> bool
<li> float, double, (long double?)
<li> wchar_t
<li> ellipsis (not strictly a type)
<li> complex
</ul>

<p>
type modifiers/constructors:
<ul>
<li> const, volatile (restrict?)
<li> array (with size?) of type
<li> pointer to type
<li> reference to type
<li> function expecting type*, returning type
<li> pointer to member function of type, expecting type*, returning type
<li> pointer to member of type T, having type U (i.e. "U T::*")
</ul>

<p>
The types in parentheses are available in C99,
but not in standard C++.


<p>
<font color=blue><hr><p>[991021 all]</font>
It was observed in the meeting that it might be better to deal with
non-essential type information
(e.g. exception specifications, array sizes)
as a separate construct to allow error detection,
rather than as a required part of the mangled name.
This allows it to be elided or removed if unneeded.

<p>
<font color=blue>[991028 all]</font>
Objectives of a specification were discussed,
and have been added to the writeup above.



<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F2></a> <td> F-2 </td>
<td> Mangled name size </td>
<td> call g </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Typical name mangling schemes to date typically begin to produce very
long names.  SGI routinely encounters multi-kilobyte names,
and increasing usage of namespaces and templates will make them worse.
This has a negative impact on object file size, and on linker speed.
<p>
SGI has considered solutions to this problem including modified string
tables and/or symbol tables to eliminate redundancy.
Cygnus, HP, and Sun have also considered or implemented approaches
which at least mitigate it.
</td> </tr>

</table>

<p>
<font color=blue>[991028 all]</font>
Cygnus and Sun use a mangling scheme which has proven extremely
effective at compression, but not overly complex.
Each time the mangler incorporates a type into a name,
it remembers it and assigns it a number,
and subsequent occurrences of the type in the name are replaced by
the (escaped) number.
Jason believes this might be adequate compression,
without going to large character sets or more complex schemes.

<p>
<font color=blue>[991115 SCO -- Jonathon]</font>
In a discussion with Matt Austern I suggested using a
collision-resistant hash function on the manglings to generate the
names actually used in object files.
(The algorithm is: first mangle, then hash.)
This could really reduce .o size a ton;
think expression templates, etc.
I bet this would have a much bigger impact that any
obvious compression algorithm; you could just decree that all symbols
be no longer than 256 bits long, say.
Lots of tools (assemblers, debuggers) will use less space/time
dealing with the shorter names.
You would keep around a table mapping hashes back to the original
mangled names for debugging.

<p>
An interesting twist on this would be to use a secure hash with a key.
For ordinary compilation, use some well-known key.
But, by setting some flag/environment-variable you could tell the
compiler to use a key of your choice.
You can now distribute a .o that is hard to link to --
unless you know the key.

<p>
&lt;After a request for clarification...>

<p>
A collision-resistant hash function is a notion from cryptography.
(That's the world I spend a lot of my time in when I'm not doing
compiler stuff.)

<p>
Suppose you have an n-bit hash, so you have 2^n hash values.
A collision-resistant hash is one where the probability of two randomly
chosen strings hashing to the same value is (very close to) 1/(2^n).
A stronger notion of this is that finding strings that collide is
computationally infeasible.

<p>
Certainly, hashing introduces a probabilistic nature to things:
it becomes possible that two different functions could hash to the same
hash-mangled name.
However, by choosing a good hash function (and provably good ones exist)
and enough bits,
you can make it considerably less likely that in the next hundred years
two distinct functions will hash to the same name,
than that cosmic rays will cause unpredicatable linker errors.

<p>
... this (the assumption that mangling is reversible,
as the basis for such things as the c++filt tool)
is the biggest objection I can think of.  

<p>
We originally came up with this idea for our C++-to-C translator.
We ship this to people with embedded systems whose linkers only support
16-characters;
by using a collision-resistant hash they can use C++.
Nobody has ever run into a collision.
We solved the c++-filt problem
by keeping a database mapping hashes back to mangled names.
(The probabilistic guarantee says that this database can actually be
global; in our lifetime will never see two things with the same hash.)
So, it's still possible to make a c++-filt that works,
but it is admittedly more difficult.

<p>
The biggest advantage to this scheme is that you can put an upper
bound on symbol lengths,
even if the presence of truly huge template usage.
(I've seen programs where mangled names approached a megabyte in length.)
I would only suggest hashing long names;
names under 100 characters, or even a thousand characters, say,
could be left unhashed.



<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F3></a> <td> F-3 </td>
<td> Consistency checks
</td>
<td> call g </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define a mechanism to support consistency checks, e.g. in the linker,
in cases where the Standard forbids inconsistency but does not require
detection.
</td> </tr>

</table>

<p>
<font color=blue>[991028 all]</font>
In a number of cases,
the Standard requires consistent definitions in different places,
even in different files,
but does not require the implementation to detect and report
inconsistency.
With a small amount of extra information,
the linker could often detect and report such inconsistencies.
Also, there are cases where the linker can already detect a problem,
but could provide a better diagnostic with more information.

<p>
Several examples are:

<ul>
<p>
<li>
A template instantiation may conflict with a full specialization
(in different translation units).

<p>
<li>
Functions may be declared with different exceptions specifications.

<p>
<li>
Functions may be declared with different return types.

<p>
<li>
Template formal parameter names would help improve instantiation error
messages.

</ul>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F4></a> <td> F-4 </td>
<td> Empty throw specs
</td>
<td> call g </td>
<td> open </td>
<td> HP </td>
<td> 990930 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It is useful to be able to identify functions with empty throw specifications,
to allow calling of unexpected() from the runtime during unwinding.
Can this specification be merged into the function's name mangling?
</td> </tr>

</table>

<p> <hr> <p>
<h3> Miscellaneous Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=G1></a> <td> G-1 </td>
<td> Basic command line options </td>
<td> tools </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Can we agree on basic command line options (compiler and linker)
for fundamental functionality,
possibly allowing portable makefiles?
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=G2></a> <td> G-2 </td>
<td> Detection of ODR violations </td>
<td> call </td>
<td> open </td>
<td> Sun </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[Sun]
(See also F-3.)
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=G3></a> <td> G-3 </td>
<td> Inlined routine linkage </td>
<td> call </td>
<td> open </td>
<td> Sun </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Inline routines with external linkage require a method of handling
vague linkage (see B-5 for definition) for the out-of-line instance,
as well as for any static data they contain.
The latter includes string constants per [7.1.2]/4.
</td> </tr>

</table>

<p>
<font color=blue>[990624 Cygnus -- Jason]</font>
How should we handle local static variables in inlines?
G++ currently avoids this issue by suppressing
inlining of functions with local statics.
If we don't want to do that,
we'll need to specify a mangling for the statics,
and handle multiple copies like we do above.

<p>
<font color=blue>[990721 Cygnus -- Jason]</font>
[We should emit inline routines]
in translation units where an out-of-line copy is needed.
I am opposed to emitting the inlines with the vtable,
for two reasons:
<ul>
<li>
One of our users defines a proxy class whose implementation is not
exported from the shared library where it is defined;
the API for the class consists of virtual functions,
accessible through the vtable, and inline functions.
They complained that since g++ currently emits inlines along with the vtable,
their code would only link if inlining was enabled.
<p>
<li>
Often, we will need no copies of an inline function.
</ul>

<p>
<font color=blue>[991118 All]</font>
We discussed linkage of static locals in inline functions.
The C++ standard requires that there be only a single object
in the entire program,
i.e. the static locals in different translation units must be merged.
Two cases: string literals and everything else.
"Everything else" is believed to be a rare and unimportant case.
We'll just give the static locals mangled names,
and put them in comdat groups.
String literals are believed to be common,
and mangled names in COMDAT is too heavyweight.
The base ABI provides an optional mechanism for
merging all copies of a given string literal.
We would like to make this mechanism mandatory,
so that string literals in inline functions get merged automatically.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=G4></a> <td> G-4 </td>
<td> Dynamic init of local static objects and multithreading </td>
<td> call </td>
<td> open </td>
<td> SCO </td>
<td> 990607 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The Standard requires that local static objects with dynamic
constructors be initialized exactly once, the first time the containing
scope is entered.
Multi-threading renders the simple check of a flag before
initialization inadequate to prevent multiple initialization.
Should the ABI require locking for this purpose,
and if so, what are the necessary interfaces?
In addition to the locking of the initialization,
special exception handling treatment is required to deal with an
exception during construction.
</td> </tr>

</table>

<p>
<font color=blue><hr><p>[990607 SCO -- Jonathan]</font>
The standard is mute on multiple threads of control in general, so 
there is no requirement in the language to support what I'm talking
about. But as a practical matter compilers have to do it (Watcom gave
a paper on their approach during the standardization process, if I
remember).  This example using UI/SVR4 threads will usually show
whether a compiler does it or not: 

<pre><code>
thr5.C:
// static local initialization and threads

#include <stdlib.h>
#define EXIT(a) exit(a)
#define THR_EXIT() thr_exit(0)

#include <thread.h>

int init_count = 0;
int start_count = 0;

int init()
{
  
        ::thr_yield();
        return ++init_count;
}

void* start(void* s)
{
  
        start_count++;
        static int i = init();
        if (i != 1) EXIT(5);
        THR_EXIT();
        return 0;
}
                
int main()
{
  
        thread_t t1, t2;
        if (::thr_create(0, 0, start, 0, 0L, &t1) != 0) EXIT(1);
        if (::thr_create(0, 0, start, 0, 0L, &t2) != 0) EXIT(2);
        if (::thr_join(t1, 0, 0) != 0) EXIT(3);
        if (::thr_join(t2, 0, 0) != 0) EXIT(4);
        if (start_count != 2)
                EXIT(6);
        if (init_count != 1)
                EXIT(7);
        THR_EXIT();
}
</code></pre>

<p>
When compiled with CC -Kthread thr5.C on UnixWare 7, for instance,
it passes by returning 0.  When compiled with CC -mt thr5.C on
Solaris/x86 C++ 4.2 (sorry don't have the latest version!), it
fails by returning 5.


<p>
<font color=blue><hr><p>[990607 Sun -- Mike Ball]</font>
As far as I can tell, the language says that the automatic blocking 
issue isn't a valid approach.  It says what has to happen, and
it isn't that.

<p>
If you look at the entire statement you find that it reads:
<quote>
"Otherwise such an object is initialized the first time control passes
through its declaration; such an object is considered initialized upon
the completion of its initialization.
If the initialization exits by throwing an exception,
the initialization is not complete,
so it will be tried again the next time control enters the declaration.
If control re-enters the declaration (recursively)
while the object is being initialized,
the behavior is undefined."
</quote>

<p>
The word "recursively" is normative,
so eliminates that sentence from consideration.

<p>
One can, of course, make any extension to the language,
but in this case I think the extension invalidates some otherwise valid code.

<p>
The sentence I'm referring to is that the object is considered
initialized upon the completion of its initialization.
This is explicit, and the reason for it is covered in the following sentence,
which discusses an initialization that terminates with an exception.
A person catching such an exception has the right to try again
without danger that the static variable will be initialized in the meantime.

<p>
I don't see anything at all to justify semantics that say,
"after initialization is started, Any other threads of control are
blocked until that thread completes the initialization,
unless, of course, it executes by an exception,
in which case the other thread can do the initialization before the
exception handler gets a chance to try again, except...."
 Take an attempt to define the semantics as far as you like.

<p>
The problem is that there is no way for the compiler writer to know
what the programmer really wanted to do.
I can (and will at some other date, if necessary)
come up with scenarios justifying a variety of mutual exclusion policies,
including none.

<p>
The solution is to let the programmer write the mutual exclusion, the
same as we do for every other potential race condition.
It's a real mess, and, I claim, an unwise one to put in as an extension.

<p>
<font color=blue><hr><p>[990608 HP -- Christophe]</font>
The semantics currently implemented in the HP aC++ compiler is as follows:
<ul>
<li> No two thread can enter a static initialization at the same time
<li> Threads are blocked until immediately after the static  
    initialization either succeeds or fails with an exception.
</ul>

<p>
There are details of our implementation that I disagree with, but in  
general, the semantics seem clear and sane, not as convoluted as you  
seemed to imply. In particular, it correctly covers the case where  
the static initialization fails with an exception. Any thread at that  
point can attempt the initialization.

<p>
<font color=blue><hr><p>[990608 SCO -- Jonathan]</font>
Here's what the SCO UnixWare 7 C++ compiler does for IA-32,
from a (slightly sanitized) design document.
 It meets Jim's goal of having no overhead for non-threaded programs
and minimal overhead for threaded programs unless
actual contention occurs (infrequent),
and meets Mike's goal of handling exceptions in the initialization correctly
(although it doesn't guarantee that the thread getting the exception is
the one that gets next crack at initializing the static).
 It's also worth noting that dynamic initialization of local variables
(static or otherwise) is very common in C++,
since that's what most object constructions involve,
so I don't think this case is as rare as Jim does.


<p>
[...] This is in local static variables with dynamic initialization,
where the compiler generates out a static one-time flag to guard the
initialization.
Two threads could read the flag as zero before either of them set it,
resulting in multiple initializations.

<p>
[...] Accordingly, when compilation is done with -Kthread on,
a code sequence will be generated to lock this initialization.  
[...] the basic idea is to have one guard saying whether the
initialization is done (so that multiple initializations do not occur)
and have another guard saying whether initialization is in progress
(so that a second thread doesn't access what it thinks is
an initialized value before the first thread has finished the
initialization).  [...]

<p>
When compiled with -Kthread, the generated code for a dynamic
initialization of a local static variable will look like the
following. guard is a local static boolean, initialized to zero,
generated by the [middle pass of the compiler]. 
Two bits of it are used: the low-order 'done bit'
and the next-low-order 'busy bit'.

<pre><code>
.again:
        movl    $guard,%eax
        testl   $1,(%eax)       // test the done bit
        jnz     .done           // if set, variable is initialized,
done
        lock; btsl  $1,(%eax)   // test and set the busy bit
        jc      .busy
        < init code >           // not busy, do the initialization
        movl    $guard,%eax
        movl    $3,(%eax)       // set the done bit
        jmp     .done
.busy:
        pushl   %eax            // call RTS routine to wait, passing address
        call1   __static_init_wait      // of guard to monitor
        testl   %eax,%eax       // 1 means exception occurred in init code,
        popl    %ecx
        jnz     .again                  // start the whole thing over
.done                                   // 0 means wait finished
</code></pre>

<p>
The above code will work for position-independent code as well.

The complication due to exceptions is:
what happens if the initialization code throws an exception?
The [compiler] EH tables will have set up a special region and flag in
their region table to detect this situation,
along with a pointer to the guard variable.
Because the initialization never completed,
when the RTS sees that it is cleaning up from such a region,
it will reset the guard variable back to both zeroes.
This will free up a busy-waiting thread, if any,
or will reset everything for the next thread that calls the function.

<p>
The idea of the __static_init_wait() RTS routine is to monitor the
value of guard bits passed in, by looping on this decision table:
<pre><code>
    done    busy
    0       0       return 1 in %eax        (EH wipe-out)
    1       1       return 0 in %eax        (no longer busy)
    0       1       continue to wait        (still busy)
    1       0       internal error, shouldn't happen
</code></pre>

<p>
As for how the wait is done [... not relevant for ABI,
although currently we're using thr_yield(),
which may or may not be right for this context].

<p>
<font color=blue><hr><p>[990608 SGI -- Hans]</font>
I'd like to make some claims about function scope static constructor
calls in multithreaded environments.
I personally can't recall ever having used such a construct,
which somewhat substantiates my claims,
but also implies some lack of certainty.
I'd be interested in hearing any arguments to the contrary.

<p>
I believe that these arguments imply that this problem is not important
enough to warrant added ABI complexity or overhead for sequential code.

<p>
Consider the following skeletal example:

<p><code>
f(int x) { static foo a(...); ... }
</code>

<ol>
<p>
<li>
If the constructor argument doesn't depend on the function parameter,
and the code behaves reasonably, it should be possible to rewrite this as

<p><code>
static foo a(...);
<br>
f(int x) { ... }
</code>

<p>
<li>
If I read the standard correctly (and that's a big disclaimer),
the compiler is entitled to perform the above transformation under
conditions that are usually true,
but hard for the compiler to deduce.
Thus code that relies on the initialization occurring during the
execution of f is usually broken.

<p>
<li>
Thus the foo constructor cannot rely on its caller holding any locks.
It must explicitly acquire any locks it needs.

<p>
<li>
It is far preferable to write the transformed form with a file scope
static variable to start with.
The initial form risks deadlock,
since f may be called with locks held which the constructor
can't assume are held.
If it needs one of those locks it will need to reacquire it.
With default mutex semantics that results in deadlock with itself.
(If locks may be reentered,
it may fail in a more subtle manner since the foo constructor may
acquire a monitor lock whose monitor invariant doesn't hold.)

<p>
<li>
File scope static constructor calls aren't a problem and require no locking,
since they are executed in a single thread before main is called or
before dlopen returns.
(Forking a thread in a static constructor should probably be disallowed.
Threads may not have been fully initialized, among other issues.)

<p>
<li>
Static function scope constructor calls which depend on function
arguments are likely to involve a race condition anyway,
if multiple instances of the function can be invoked concurrently.
Any of the calls might determine the constructor parameters.
Thus these aren't very interesting either.
And if they are really needed, they can be replaced with a file scope
static constructor call plus an assignment.

</ol>

<p>
<font color=blue><hr><p>[990607 SCO -- Jonathan]</font>
Hans' argument breaks such local statics into two groups:
those that don't depend upon the function's parameters,
and those that do.
For the latter group, he says:

<pre><i>
> 6) Static function scope constructor calls which depend on function
> arguments are likely to involve a race condition anyway, if multiple
> instances of the function can be invoked concurrently.  Any of the
> calls might determine the constructor parameters.  Thus these aren't
> very interesting either.  And if they are really needed, they can be
> replaced with a file scope static constructor call plus an assignment.
</i></pre>

<p>
I don't agree with these claims.
There are sometimes situations where a group of objects is being processed,
and you want to arbitrarily pick one of them
to serve as an identifier or key for all of them.
 Consider perhaps a golf course scheduler,
which is taking in players and assigning them to foursomes.  
You want to name each foursome by one of the names of the players
(it doesn't matter which one),
such as the "Jones group" or the "Smith group".  
A natural way to program this might be:

<pre><tt>
      void build_foursome(string golfer) {
	  static string group_name(golfer);
	  // process golfer into group group_name ...
      }
</tt></pre>

<p>
Now if the golfers being scheduled are coming from four different databases,
it might be that a thread is running to extract from each database.
Thus build_foursome() might be called concurrently.
That's fine, and there is no need for application-level locks in
either the caller or this function; we don't care which golfer
the group is named after.
We just want the 'static' to work correctly;
what we don't want is a double initialization,
with two different group names being generated for golfers in the same group,
which is possible if the guard code isn't thread-safe.

<p>
Now one can say that this kind of design isn't wise,
or that locks will probably be needed later in this function
to do the rest of the processing, 
or that this can be coded in several other ways.
And that may all be so.
But I think this usage is *reasonable* in this context,
and that as implementors we should get it right.
[Editorial:  Especially with the advent of Java,
threaded application programming is becoming more the norm; 
and language implementations that dodge the challenge and say that
thread support is solely the job of libraries,
may not be looked upon kindly by users.]


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=G5></a> <td> G-5 </td>
<td> Varargs routine interface </td>
<td> call </td>
<td> closed </td>
<td> HU-B </td>
<td> 990810 </td>
<td> 991014 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The underlying C ABI defines conventions for calling varargs routines.
Does C++ need, or would it benefit from, any modifications or special cases?
How should we pass references or class objects?
Is any runtime library support required?
</td> </tr>
<tr> <td colspan=7>
<b>Resolution</b>:
No special cases required -- C++ will follow the C varargs ABI.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=G6></a> <td> G-6 </td>
<td> bool parameters </td>
<td> call </td>
<td> open </td>
<td> all </td>
<td> 991104 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How should we pass bool parameters on IA-64?
Choices are to pass them like ABI ints,
or in predicate registers or register pairs.
</td> </tr>

</table>


<p> <hr> <p>
<h3> Library Interface Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=H1></a> <td> H-1 </td>
<td> Runtime library DSO name </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990616 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Determine the name of the common C++ runtime library DSO,
e.g. <code>libC.so</code>.
If there are to be vendor-specific support libraries which must coexist
in programs from mixed sources, identify naming convention for them.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=H2></a> <td> H-2 </td>
<td> Runtime library API </td>
<td> lif </td>
<td> open </td>
<td> SGI </td>
<td> 990616 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the required entrypoints in the common C++ runtime library DSO,
and their prototypes.
</td> </tr>

</table>

<p> <hr> <p>
<h3><a name=ancient> Ancient Revision History </a> </h3>

<p>
<font color=blue>[990929]</font>
Additions to <a href=#D0>D-*</a>, <a href=#D9>D-9</a>.

<p>
<font color=blue>[990914]</font>
Additions to <a href=#B1>B-1</a>, <a href=#D0>D-*</a>, <a href=#D9>D-9</a>.

<p>
<font color=blue>[990908]</font>
New issue <a href=#D9>D-9</a>.
Additions to <a href=#B1>B-1</a>, <a href=#D0>D-*</a>,
<a href=#D2>D-2</a>, <a href=#D4>D-4</a>,
<a href=#D5>D-5</a>, <a href=#D6>D-6</a>.

<p>
<font color=blue>[990901]</font>
Additions to <a href=#A6>A-6</a>, <a href=#B6>B-6</a>.

<p>
<font color=blue>[990825]</font>
Additions to <a href=#A6>A-6</a>, <a href=#B6>B-6</a>,
<a href=#C5>C-5</a>, <a href=#D0>D-*</a>.

<p>
<font color=blue>[990813]</font>
Closed <a href=cxx-closed.html#A11>A-11</a>.
Additions to <a href=#A6>A-6</a>,
<a href=#B1>B-1</a>, <a href=#B6>B-6</a>, <a href=#B8>B-8</a>,
<a href=#C2>C-2</a>,
<a href=#G5>G-5</a>.

<p>
<font color=blue>[990810]</font>
New issue <a href=#G5>G-5</a>.
Additions to <a href=#B6>B-6</a>, <a href=#C2>C-2</a>, <a href=#C3>C-3</a>.

<p>
<font color=blue>[990805]</font>
Closed A-12, A-14, B-3, B-4, B-7, C-7.
Additions to <a href=#A6>A-6</a>, <a href=#A11>A-11</a>,
<a href=#B1>B-1</a>, <a href=#B6>B-6</a>, <a href=#F1>F-1</a>.

<p>
<font color=blue>[990729]</font>
Closed A-7.
Additions to A-11, A-12, C-2.
Summary added for A-12.
New issue A-14.

<p>
<font color=blue>[990727]</font>
Closed B-2, C-8.
Additions to A-9 (closed), C-2.
Summaries added for C-4, C-6, D-1 to D-4.

<p>
<font color=blue>[990720]</font>
Additions to B-2, B-5, C-2, D-1.

<p>
<font color=blue>[990701]</font>
Closed A-3, A-5, A-10, A-13.
Additions to A-6, B-6, B-7, B-8, C-2, C-7.

<p>
<font color=blue>[990625]</font>
Closed A-1, A-2, A-4, A-8, A-9.
Additions to A-3, A-5, A-7, B-4, B-5, B-7, G-3, G-4.
New issues B-6, B-7, B-8, C-7, C-8.

<p>
<font color=blue>[990616]</font>
Added HP summaries.
Added sketchy notes from 990610 discussions (A and B issues).
A-10 was intended by HP as something different than I described,
so it was renamed, and a new issue A-13 opened as an SGI issue.
HP did not submit A-12, so relabeled as Sun's (is that right?).
Added library interface issues, H-1 and H-2.


<p>
<hr>

<p>
Please send corrections to <a href=mailto:dehnert@sgi.com>Jim Dehnert</a>.


</BODY>
</HTML>
