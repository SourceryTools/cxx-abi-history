<HTML>

<HEAD>
<title>C++ ABI Open Issues</title>

<link rel=stylesheet href=small-table.css type="text/css">
<link rel=stylesheet href=code.css type="text/css">

<hr>

<font size=6><i><b>
<p>
C++ ABI Open Issues
</b></i></font>

<font size=-1>
<p>
<i>Revised 30 March 2000</i>

</center>

</HEAD>

<BODY>

<p> <hr> <p>
<h3> Revisions </h3>

<p>
<font color=blue>[000330]</font>
Additions to <a href=#F4>F-4</a>, <a href=#F6>F-6</a>.
Closed <a href=#A24>A-24</a>, <a href=#F1>F-1</a>.

<p>
<font color=blue>[000323]</font>
New issues <a href=#F8>F-8</a>, <a href=#F9>F-9</a>.
Additions to <a href=#C4>C-4</a>, <a href=#F1>F-1</a>.

<p>
<font color=blue>[000321]</font>
Additions to <a href=#F1>F-1</a>, <a href=#F6>F-6</a>.

<p>
<font color=blue>[000313]</font>
New issues <a href=#C13>C-13</a>, <a href=#C14>C-14</a>.
Closed <a href=#C11>C-11</a>, <a href=#C12>C-12</a>.
Additions to <a href=#A24>A-24</a>, <a href=#C4>C-4</a>, <a href=#F1>F-1</a>.

<p>
<font color=blue>[000308]</font>
Closed <a href=#A26>A-26</a>, <a href=#A27>A-27</a>,
<a href=#B9>B-9</a>.
Add Limits section to ABI layout document.

<p>
<font color=blue>[000302]</font>
Additions to closed <a href=cxx-closed.html#A20>A-20</a>,
<a href=cxx-closed.html#A21>A-21</a>.
Additions to <a href=#C11>C-11</a>,

<p>
<font color=blue>[000228]</font>
New issues <a href=#A26>A-26</a>, <a href=#A27>A-27</a>,
<a href=#F7>F-7</a>.

<p>
<a href=#ancient>Ancient revision history</a>.


<p> <hr> <p>
<h3> Definitions </h3>

<p>
The issues below make use of the following definitions:

<dl>

<p>
<dt> <i>dynamic class</i> </dt>
<dd>
A class that requires a virtual pointer,
due to either virtual functions or virtual bases.

<p>
<dt> <i>empty class</i> </dt>
<dd>
A class with no non-static data members other than zero-width bitfields,
no virtual functions, no virtual base classes,
and no non-empty non-virtual base classes.

<p>
<dt> <i>nearly empty class</i> </dt>
<dd>
A class that:
<ul>
<li> has no non-static data members other than zero-width bitfields,
<li> has no base classes that are not either empty or nearly empty,
<li> has at most one nearly empty base class, and
<li> has at least one virtual function, possibly inherited from a base class.
</ul>
Such a class contains only a Vptr.

<p>
<dt> <i>vague linkage</i> </dt>
<dd>
The treatment of entities --
e.g. inline functions, templates, vtables --
with external linkage that can be
defined in multiple translation units,
while the ODR requires that the program
behave as if there were only a single definition.

</dl>


<p> <hr> <p>
<h3> Issue Status </h3>

In the following sections,
the <b><i>class</i></b> of an issue attempts to classify it on the
basis of what it likely affects.
The identifiers used are:

<table>
<tr> <td> call </td>
<td> Function call interface, i.e. call linkage </td>
</tr>

<tr> <td> data </td>
<td> Data layout </td>
</tr>

<tr> <td> lib </td>
<td> Runtime library support </td>
</tr>

<tr> <td> lif </td>
<td> Library interface, i.e. API </td>
</tr>

<tr> <td> g </td>
<td> Potential gABI impact </td>
</tr>

<tr> <td> ps </td>
<td> Potential psABI impact </td>
</tr>

<tr> <td> source </td>
<td> Source code conventions (i.e. API, not ABI) </td>
</tr>

<tr> <td> tools </td>
<td> May affect how program construction tools interact </td>
</tr>
</table>

<p> <hr> <p>
<h3> Object Layout Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A1></a> <td> A-1 </td>
<td> Vptr location </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where is the Vptr stored in an object (first or last are the usual answers).
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A1> Resolution </a></b>:
First.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A2></a> <td> A-2 </td>
<td> Virtual base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where are the virtual base subobjects placed in the class layout?
How are data member accesses to them handled?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A2> Resolution </a></b>:
Virtual base subobjects are normally placed at the end (see issue A-9).
The Vtable will contain an offset to the beginning of the base object
for use by member accesses to them (see issue B-6).
</td> </tr>

</table>

<p>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-3 </td>
<td> Multiple inheritance </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990701 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the class layout in the presence of multiple base classes.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A3> Resolution </a></b>:
See the class layout description in closed issue A-9.
Briefly, empty bases will normally go at offset zero,
non-virtual base classes at the beginning,
and virtual base classes at the end.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-4 </td>
<td> Empty base classes </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where are empty base classes allocated?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A4> Resolution </a></b>:
At offset zero if possible.  See A-9.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-5 </td>
<td> Empty parameters </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990701 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
When passing a parameter with an empty class type by value,
what is the convention?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A5> Resolution </a></b>:
Except for cases of non-trivial copy constructors (see C-7),
and parameters in the variable part of varargs lists,
no parameter slot will be allocated to empty parameters.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A6></a> <td> A-6 </td>
<td> RTTI .o representation </td>
<td> data call ps </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991028 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the data structure to be used for RTTI, that is:
<ul>
<li> for user <code>type_info</code> calls;
<li> for dynamic_cast implementation; and
<li> for exception-handling.
</ul>
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A6> Resolution </a></b>:
Defined in the
<a href=abi-layout.html#rtti>ABI data layout document</a>.
</tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-7 </td>
<td> Vptr sharing with primary base class </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990729 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It is in general possible to share the virtual pointer with a
dynamic base class (the <i>primary</i> base class).
Which base class do we use for this?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A7> Resolution </a></b>:
Share with the first non-virtual dynamic base class,
or if none with the first nearly empty virtual base class.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-8 </td>
<td> (Virtual) base class alignment </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
A (virtual) base class may have a larger alignment constraint than a
derived class.
Do we agree to extend the alignment constraint to the derived class?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A8> Resolution </a></b>:
The derived class will have at least the alignment of any base class.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-9 </td>
<td> Sorting fields as allowed by [class.mem]/12 </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990624 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The standard constrains ordering of class members in memory only if
they are not separated by an access clause.
Do we use an access clause as an opportunity to fill the gaps left by padding?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A9> Resolution </a></b>:
See <a href=abi-layout.html#class-types>ABI Data Layout Specification</a>.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-10 </td>
<td> Class parameters in registers </td>
<td> call </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990701 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The C ABI specifies that small structs are passed in registers.
Does this apply to small non-POD C++ objects passed by value?
What about the copy constructor and <code>this</code> pointer in that case?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A10> Resolution </a></b>:
Non-POD C++ objects are passed like C structs,
except for cases with non-trivial copy constructors identified in C-7.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A11></a> <td> A-11 </td>
<td> Pointers to member functions </td>
<td> data </td>
<td> closed </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> 990812 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How should pointers to member functions be represented?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A11> Resolution</a></b>:
As a pair of values, a "pointer" and a this adjustment.
See the closed list for a more detailed description.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=A12></a> <td> A-12 </td>
<td> Merging secondary vtables </td>
<td> data </td>
<td> closed </td>
<td> Sun </td>
<td> 990610 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Sun merges the secondary Vtables for a class (i.e. those for
non-primary base classes) with the primary Vtable by appending them.
This allows their reference via the primary Vtable entry symbol,
minimizing the number of external symbols required in linking,
in the GOT, etc.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A12> Resolution</a></b>:
Concatenate the Vtables associated with a class in the same order
that the corresponding base subobjects are allocated in the object.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <td> A-13 </td>
<td> Parameter struct field promotion </td>
<td> call </td>
<td> closed </td>
<td> SGI </td>
<td> 990603 </td>
<td> 990701 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It is possible to pass small classes either as memory images,
as is specified by the base ABI for C structs,
or as a sequence of parameters, one for each member.
Which should be done, and if the latter,
what are the rules for identifying "small" classes?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A13> Resolution</a></b>:
No special treatment will be specified by the ABI.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A14></a> <td> A-14 </td>
<td> Pointers to data members </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990729 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How should pointers to data members be represented?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A14> Resolution</a></b>:
Represented as one plus the offset from the base address.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A15></a> <td> A-15 </td>
<td> Empty bit-fields </td>
<td> data </td>
<td> closed </td>
<td> CodeSourcery </td>
<td> 991214 </td>
<td> 000106 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How are zero-length bit-fields handled?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A15> Resolution</a></b>:
Zero-length bit-fields do not prevent a class from being considered
empty or nearly empty.
</td> </tr>

</table>



<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A16></a> <td> A-16 </td>
<td> Nearly empty virtual bases </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 991228 </td>
<td> 000106 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
May a class with non-empty, non-primary, virtual base classes
be treated as nearly empty (and thus eligible to be a primary base)
if its only non-vptr data is in its virtual base classes?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A16> Resolution</a></b>:
Virtual base classes do not prevent a class from being considered
nearly empty.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A17></a> <td> A-17 </td>
<td> Primary indirect virtual base allocation </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 991228 </td>
<td> 000113 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
When a nearly empty virtual base class A is allocated as the primary
base class of class B, and then B is allocated as a base class of C,
should A (i.e. its vptr) be separately allocated in C,
or should its first occurrence in a previously allocated base B be used
as its allocation in C?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A17> Resolution</a></b>:
Do not reallocate a nearly empty virtual base class that is the primary
base class of any other base class, direct or indirect.
Use the first primary base class instance in the inheritance hierarchy
as its allocation, in the usual depth-first, left-to-right order.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A18></a> <td> A-18 </td>
<td> Virtual base alignment </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 991228 </td>
<td> 000113 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Should virtual bases have a different effect on class alignment than
other components?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A18> Resolution</a></b>:
Yes.  When allocating the non-virtual part of a base class,
use its <i>non-virtual</i> allignment,
i.e. ignoring its virtual bases' contributions.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A19></a> <td> A-19 </td>
<td> Primary indirect virtual base choice </td>
<td> data </td>
<td> closed </td>
<td> All </td>
<td> 000106 </td>
<td> 000120 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
In allocating class C,
when the first nearly empty virtual base class A is allocated as the
primary base class of a later nearly empty virtual base class B,
should A or B become the primary base class of C?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A19> Resolution</a></b>:
Do not use a virtual base as primary if it is already a primary base of
some other direct or indirect base,
unless such are the only candidates.
In either case, use the first candidate in depth-first, left-to-right
order in the inheritance graph.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A20></a> <td> A-20 </td>
<td> Operator new array cookies </td>
<td> data </td>
<td> closed </td>
<td> All </td>
<td> 000113 </td>
<td> 000120 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
When operator new is used to create a new dynamic-length array,
a cookie must be stored to remember the allocated length
so that it can be deallocated correctly.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A20> Resolution</a></b>:
In principle, place cookie immediately before array, aligned naturally.
Use no cookie for element types with no destructors.
See the <a href=abi-layout.html#array-new>ABI Layout</a> document.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A21></a> <td> A-21 </td>
<td> Placement new array cookies </td>
<td> data </td>
<td> closed </td>
<td> All </td>
<td> 000113 </td>
<td> 000217 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Same issue as A-20, except that for placement new,
the user supplies already-allocated space.
Therefore, there is a conflict between wanting to make delete()
work on arrays created in this way,
and wanting to avoid surprising users who haven't allocated enough
space for the cookie.
Also, are cookies allocated if there is no destructor?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A21> Resolution</a></b>:
Use no cookie for element types with no destructors,
nor for <code>::operator new(size_t, void*)</code>.
Otherwise, use a cookie as in issue A-20.
See the <a href=abi-layout.html#array-new>ABI Layout</a> document.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A22></a> <td> A-22 </td>
<td> RTTI for reference types </td>
<td> data </td>
<td> closed </td>
<td> CodeSourcery </td>
<td> 000119 </td>
<td> 000203 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
__reference_type_info does not appear to be necessary.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A22> Resolution</a></b>:
Remove it.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A23></a> <td> A-23 </td>
<td> RTTI class descriptors </td>
<td> data </td>
<td> closed </td>
<td> CodeSourcery </td>
<td> 000124 </td>
<td> 000302 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Resolve several questions about the RTTI representation of class types.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A23> Resolution</a></b>:
See the <a href=abi-layout.html>ABI layout</a> document.
</td> </tr>

</table>



<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A24></a> <td> A-24 </td>
<td> RTTI for incomplete types </td>
<td> data </td>
<td> closed </td>
<td> CodeSourcery </td>
<td> 000126 </td>
<td> 000330 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How does RTTI represent incomplete types?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A24> Resolution</a></b>:
Use class_type_info distinct from the complete type copy,
add a flag to pointer_type_info if it points to incomplete type RTTI,
and do mangled name comparison if an incomplete pointer is involved.
See the <a href=abi-layout.html#rtti>writeup</a> in the ABI data layout
specification.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A25></a> <td> A-25 </td>
<td> Excess-width bitfields </td>
<td> data </td>
<td> closed </td>
<td> IBM </td>
<td> 000204 </td>
<td> 000217 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
C++ allows bitfields with a larger size specified than that required by
the declared type, e.g. <code>int f: 64</code>.
How should they be allocated?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A25> Resolution</a></b>:
Allocate the field with alignment determined as though it were the
largest integer type that fits in the specified size,
and use the first bits available in the field
(lowest order for little endian IA-64)
for the actual data.
</td> </tr>

</table> 


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A26></a> <td> A-26 </td>
<td> NULL pointers to member functions </td>
<td> data </td>
<td> closed </td>
<td> CodeSourcery </td>
<td> 000221 </td>
<td> 000302 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How are NULL pointers to member functions represented?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A26> Resolution</a></b>:
A NULL pointer is represented by a 0 value of <code>ptr</code>,
and the value of <code>adj</code> is irrelevant.
</td> </tr>

</table> 


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=A27></a> <td> A-27 </td>
<td> NULL pointers to data members </td>
<td> data </td>
<td> closed </td>
<td> CodeSourcery </td>
<td> 000222 </td>
<td> 000302 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How are NULL pointers to member data represented?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#A27> Resolution</a></b>:
A NULL pointer is represented by the value -1.
</td> </tr>

</table> 



<p> <hr> <p>
<h3> Virtual Function Handling Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B1></a> <td> B-1 </td>
<td> Adjustment of "this" pointer (e.g. thunks) </td>
<td> data call </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991202 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
There are several methods for adjusting the <i>this</i> pointer
for a member function call,
including thunks or offsets located in the vtable.
We need to agree on the mechanism used,
and on the location of offsets, if any are needed.
To maximize performance on IA64,
a slightly unusual approach such as using secondary entry points
to perform the adjustment may actually prove interesting. 
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#B1> Resolution</a></b>:
See the <a href=abi-layout.html#vcall>writeup</a> in the ABI data layout
specification.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B2></a> <td> B-2 </td>
<td> Covariant return types </td>
<td> call </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 990722 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
There are several methods for adjusting the 'this' pointer of the
returned value for member functions with covariant return types.
We need to decide how this is done.
Return thunks might be especially costly on IA64,
so a solution based on returning multiple pointers may prove more interesting.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#B2> Resolution</a></b>:
Provide a separate Vtable entry for each return type.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B3></a> <td> B-3 </td>
<td> Allowed caching of vtable contents </td>
<td> call </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The contents of the vtable can sometimes be modified,
but the concensus is that it is nonetheless always allowed to "cache" elements,
i.e. to retain them in registers and reuse them,
whenever it is really useful.
However, this may sometimes break "beyond the standard" code,
such as code loading a shared library that replaces a virtual function.
Can we all agree when caching is allowed? 
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#B3> Resolution</a></b>:
Caching is allowed within a member function.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B4></a> <td> B-4 </td>
<td> Function descriptors in vtable </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
For a runtime architecture where the caller is expected to load the GP
of the callee (if it is in, or may be in, a different DSO), e.g. HP/UX,
what should vtable entries contain?
One possibility is to put a function address/GP pair in the vtable.
Another is to include only the address of a thunk which loads the GP
before doing the actual call.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#B4> Resolution</a></b>:
The Vtable will contain a function address/GP pair.
</td> </tr>

</table>

<p>
<font color=blue>[991007 All]</font>
Note that, though this issue was closed,
it may prove necessary to reopen it if the underlying C ABI treatment
of function pointers changes.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B5></a> <td> B-5 </td>
<td> Where are vtables emitted? </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 991118 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
In C++, there are various things with external linkage that can be
defined in multiple translation units,
while the ODR requires that the program
behave as if there were only a single definition.
From the user's standpoint, this applies to inlines and templates.
From the implementation's perspective,
it also applies to things like vtables and RTTI info.
(We call this <i>vague linkage</i>.)
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#B5> Resolution</a></b>:
Vtables will be emitted with the key function (first virtual function
that is not inline at the point of class definition), if any.
If no key function, emit everywhere used (i.e. referred to by name).
Place in a comdat group in all cases.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B6></a> <td> B-6 </td>
<td> Virtual function table layout </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991028 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What is the layout of the Vtable?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#B6> Resolution</a></b>:
See the ABI data layout document,
<a href=abi-layout.html#vtable>abi-layout.html</a>.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B7></a> <td> B-7 </td>
<td> Objects and Vtables in shared memory </td>
<td> data </td>
<td> closed </td>
<td> HP </td>
<td> 990624 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Is it possible to allocate objects in shared memory?
For dynamic objects, this implies that the Vtable must also be
in shared memory.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#B7> Resolution</a></b>:
No special representation is useful in support of shared memory.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B8></a> <td> B-8 </td>
<td> dynamic_cast </td>
<td> data </td>
<td> closed </td>
<td> SGI </td>
<td> 990628 </td>
<td> 991014 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What information to we put in the vtable to enable (a) dynamic_cast
from pointer-to-base to pointer-to-derived (including detection of
ambiguous base classes) and (b) dynamic_cast to void*?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#B8> Resolution</a></b>:
The vtable will contain an offset to the beginning of the complete object,
and a pointer to the typeinfo object.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=B9></a> <td> B-9 </td>
<td> Primary base vtable embedding </td>
<td> data </td>
<td> closed </td>
<td> Cygnus </td>
<td> 000217 </td>
<td> 000302 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Resolve the embedding of the vtable for the primary base class
in the derived class vtable.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#B9> Resolution</a></b>:
Any class with virtual bases shall contain vbase pointers
for all of its virtual bases.
</td> </tr>

</table>



<p> <hr> <p>
<h3> Object Construction/Destruction Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C1></a> <td> C-1 </td>
<td> Interaction with .init/.fini </td>
<td> lif ps </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991202 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Static objects with dynamic constructors must be constructed at
intialization time.
This is done via the executable object initialization functions that
are identified (in ELF) by the DT_INIT and DT_INIT_ARRAY dynamic tags.
How should the compiler identify the constructors to be called in this way?
One traditional mechanism is to put calls in a .init section.
Another, used by HP, is to put function addresses in a .init_array section.
<p>
The dual question arises for static object destructors.
Again, the extant mechanisms include putting calls in a .fini section,
or putting function addresses in a .fini_array section.
<p>
Finally, which mechanism (DT_INIT or DT_INIT_ARRAY, or the FINI versions)
should be used in linked objects?
The gABI, and the IA-64 psABI, will support both,
with DT_INIT being executed before the DT_INIT_ARRAY elements.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#C1> Resolution</a></b>:
Use .init_array and .fini_array sections.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C2></a> <td> C-2 </td>
<td> Order of ctors/dtors w.r.t. link </td>
<td> lif ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Given that the compiler has identified constructor/destructor calls for
static objects in each relocatable object, in what order should the
static linker combine them in the linked executable object?
(The initialization order determines the finalization order,
as its opposite.)
</td> </tr>

</table>

<p>
<font color=blue>[990610 All]</font>
Meeting concensus is that the desirable order is right to left on the
link command line, i.e. last listed relocatable object is initialized
first.

<p>
<font color=blue><hr><p>[990701 SGI]</font>
We propose that global constructors be handled as follows:
<ul>
<p>
<li>
The compiler shall emit global constructor calls as one or more entries
in an SHF_INIT_ARRAY section.
<p>
<li>
The linker shall combine them according to the rules of the base gABI,
namely as a concatenated array of entries, in link argument order,
pointed to by a DT_INIT_ARRAY tag.
(The linker may intersperse entries from command line flags or modules
from other languages, but that is beyond the C++ ABI scope.)
</ul>

<p>
This does not address the global destructor problem.
That solution needs to deal not only with the global objects seen by
the compiler, but also interspersed local static objects.
This treatment seems to be tied up in the question of how early
unloading of DSOs is handled, and the data structure used for that
purpose (issue C-3).

<p>
<font color=blue><hr><p>[990715 All]</font>
Cygnus scheme:
priorities are 16-bit unsigned integers, lower numbers are higher priority.
In each translation unit,
there's a single initialization function for each priority.
Anything that's prioritized has a higher priority than anything that
isn't explicitly assigned a priority.

<p>
IBM scheme:
priorities are 32-bit signed integers, higher numbers are higher priority.
Something that isn't explicitly assigned a priority effectively
gets a priority of 0.

<p>
Consensus:
nobody is sure that negative priorities are very important,
but also nobody can think of a reason not to allow them.
We accept the idea that priorities are 32-bit signed integers.
On a source level Cygnus will keep lower numbers as higher priority,
but that's a source issue, not an ABI issue.

<p>
Status: No real technical issues,
we have consensus on everything that matters.
We need to write up the finicky details.

<p>
<font color=blue><hr><p>[990722 all]</font>
It was decided to follow the IBM approach, including:
<ul>
<li> The source pragma will use a 32-bit signed priority.
	The default will map to 0,
	and larger numbers are lower priority.

<li> Priorities MIN_INT .. MIN_INT+1023 are reserved to the implementation.

<li> The object representation will use a 32-bit unsigned priority,
	obtained from the source priority by subtracting INT_MIN.

<li> Initialization priorities are only relevant within a DSO.
	Between DSOs, the normal ELF ordering based on object order applies.

</ul>

<p>
To be resolved are the precise source pragma definition (possibly IBM's),
and the ELF file representation.

<p>
<font color=blue><hr><p>[990729 all]</font>
SGI suggested an object representation involving (in relocatables)
a new section type, containing pairs &lt;priority, entry address>.
The linker would merge all such sections,
include any initialization entries specified by other means,
and leave one or more DT_INITARRAY entries for normal runtime
initialization, either building a routine to call the entries,
or referencing a standard runtime routine.

<p>
IBM noted that they combine their equivalent data structures in the
linker, but don't sort them, leaving that to a runtime routine.
This can be done without explicit linker support,
but involves runtime overhead.

<p>
Cygnus suggested that if we are going to require linker sorting,
we should make the facility more general.

<p>
Jim will write up a more precise proposal.

<p>
<a name=c2-proposal></a>
<font color=blue><hr><p>[990804 SGI -- Jim]</font>
<h4> Proposal </h4>

<p>
My objectives are:
<ul>
<li> Simple representation in relocatable objects.
<li> No new representation in executable objects.
<li> Simple static linker processing (general if possible).
<li> Minimal unnecessary runtime cost.
<li> Minimal library interface.
<li> Integration with other initialization (at source priority zero).
</ul>

<p>
<h5> Object File Representation </h5>

<p>
Define a new section type, e.g. <code><b>SHT_CXX_PRIORITY_INIT</b></code>.
Its elements are structs:
<code><pre>
	typedef struct {
	  ElfXX_Word	pi_pri;
	  ElfXX_Addr	pi_addr;
	} ElfXX_Cxx_Priority_Init;
</pre></code>
The semantics are that <code>pi_addr</code> is a function pointer,
with an <code>unsigned int</code> priority parameter,
which performs some initialization at priority <code>pi_pri</code>.
Each of these functions will be called with the GP of the
executable object containing the table.
The section header field <code>sh_entsize</code> is 8 for ELF-32,
or 16 for ELF-64.

<p>
<h5> Runtime Library Support </h5>

<p>
Each implementation shall provide a runtime library function with
prototype:
<code><center>
void __cxx_priority_init ( ElfXX_Cxx_Priority_Init *pi, int cnt );
</center></code>
It will be called with the address of a <code>cnt</code>-element
(sub-)vector of the priority initialization entries,
and will call each of them in order.
It will be called with the GP of the initialization entries.

<p>
<h5> Linker Processing </h5>

<p>
The linker must take the collection of SHT_CXX_PRIORITY_INIT section
entries from the relocatable object files being linked,
and other initialization tasks specified in other ways
(and treated as source priority 0 or object priority -MIN_INT),
and produce an executable object file which executes the initialization
tasks in priority order using only <code>DT_INIT</code>,
<code>DT_INIT_ARRAY</code>, and <code>__cxx_priority_init</code>.
Priority order is first according to the priority of the task,
and then according to the order of relocatable objects and options
in the link command.
The order of tasks specified by other methods,
relative to SHT_CXX_PRIORITY_INIT tasks of priority zero,
is implementation defined.
There are several possible implementations.  Two extremes are:

<ul>
<p>
<li>
The linker sorts the SHT_CXX_PRIORITY_INIT sections together.
If it inserts entries for initialization tasks specified in other ways,
it may make a single DT_INIT_ARRAY entry pointing to __cxx_priority_init.
If not, it must break it into subranges,
interspersing DT_INIT_ARRAY entries for the other tasks with entries
for the SHT_CXX_PRIORITY_INIT entries.
(This implementation will minimize runtime overhead.)

<p>
<li>
The linker simply appends the SHT_CXX_PRIORITY_INIT sections.
It inserts DT_INIT_ARRAY entries before and after the entries for other
initialization tasks which sort this vector and then execute the
negative-priority calls on the first call,
and the positive-priority ones on the second call.
(I believe this is much like today's IBM implementation.)
However, to be conforming, the routine which performs these tasks
must be linked with the resulting executable object,
or shippable with it as an associated DSO.

</ul>

<p>
Note that if one is linking ELF-32 objects into a 64-bit program,
the entries must be expanded as part of this process.

<p>
<h5> Sorting Sections </h5>

<p>
Jason suggested that if we base this feature on sorting sections,
we should provide a general mechanism.
Following is a proposal for that purpose.

<p>
Define a new section header flag, <code>SHF_SORT</code>.
If present, the linker is required to sort the elements of the
concatenated sections of the same type,
where the elements are determined by <code>sh_entsize</code>.
The sort is controlled by fields in <code>sh_info</code>:

<dl>
<p>
<dt> <code>#define SH_INFO_KEYSIZE(info) (info & 0xff)</code>
<br><dd>	The size of the sort key (bytes).
<p>
<dt> <code>#define SH_INFO_KEYSTART(info) ((info>>8) & 0xff)</code>
<br><dd>	The start byte of the sort key within element, from 0.
<p>
<dt> <code>#define SH_INFO_SORTKIND(info) ((info>>16) & 0xf)</code>
<br><dd>	The kind of sort data:
		0 for unsigned integer, 1 for signed integer.

</dl>

<p>
The sort must be stable.
The sort key must be naturally aligned.

<p>
Other conceivable options would be to allow sorting strings
(like SHF_MERGE, this would be indicated by setting SHF_STRING
and putting the character size in <code>sh_entsize</code>),
or floating point data.
Also, note that if we don't anticipate using such a general mechanism,
it becomes possible to avoid padding words in the ELF-64 format by
separating the priority and address vectors.

<p>
<font color=blue><hr><p>[990810 HU-B -- Martin]</font>
Global destructor ordering must not only interleave with static locals,
but also with atexit.
This gives two problems:
atexit is only guaranteed to support 32 functions;
and dynamic unloading of DSOs break when functions are atexit registered.

<p>
<font color=blue><hr><p>[990810 SGI -- Matt]</font>
Yes, the interleaving is required by the C++ standard.
It's a nuisance, and I don't think there's any good reason for it,
but the requirement is quite explicit.

<p>
The relevant part of the C++ standard is section 3.6.3, paragraph 3:

<p>
<dl><dd>
<cite>
"If a function is registered with atexit (see <cstdlib>, 18.3) then
following the call to exit, any objects with static storage duration
initialized prior to the registration of that function shall not be
destroyed until the registered function is called from the termination
process and has completed. For an object with static storage duration
constructed after a function is registered with atexit, then following
the call to exit, the registered function is not called until the
execution of the object's destructor has completed. If atexit is called
during the construction of an object, the complete object to which it
belongs shall be destroyed before the registered function is called."
</cite>
</dd></dl>

<p>
What this implies to me is that atexit, and the part of the runtime
library that handles destructors for static objects, must know about
each other.

<p>
<font color=blue><hr><p>[990812 All]</font>
Some people would prefer a sorting scheme based on the section name
instead of the data, and also less linker impact.
Jim will look into alternatives.

<p>
<font color=blue><hr><p>[991110 SGI -- Jim]</font>
I said I would revisit my proposal, looking at two questions:
<ol type=A>
<li> Can we get less linker impact?
<li> Can we sort based on section name instead of data?
</ol>

I'll address them separately.

<p>
<h5> A) Linker impact </h5>

<p>
I believe the proposal made need have almost no linker impact.
Consider the second suggested implementation scheme, based on IBM's
description of their approach.

<p>
A minimalist implementation (from the linker point of view)
includes:

<ol type=1>
<p>
<li>
The link components are bracketed (either by a driver constructing
the command line, or by implicit arguments generated within the
linker) by two INIT_ARRAY entries.  The first calls
<p>
<dd>    __cxx_priority_init_begin()
<p>
The one at the end calls
<p>
<dd>    __cxx_priority_init_end()
<p>
These are both in the implementation runtime.  The begin routine
determines the address and size of the SHT_CXX_PRIORITY_INIT section
(below).  It sorts the section by priority, and calls
__cxx_priority_init(addr,cnt) as described in the proposal with the
count of <=0 entries.
<p>
__cxx_priority_init_end calls __cxx_priority_init(addr,cnt) with the
address and count of >0 entries.

<p>
<li>
The linker simply concatenates the SHT_CXX_PRIORITY_INIT sections,
and emits markers (DT entries) that allow __cxx_priority_init_begin
to find the section and its size.  At the same time, it creates a
init_array section from other (i.e. non-constructor) entries as it
normally would, which of course gets bracketed by the entries
described above.

<p>
<li>
At runtime, when loading the executable object, the init_array
entries are executed, thereby sorting the constructor entries,
executing the <=0-priority entries, executing the non-constructor
entries, and finally executing the >0-priority entries.
</ol>

<p>
My original proposal did not describe the dynamic tags to delimit the
section, nor the __cxx_priority_init_<begin,end> routines.  Given such
an approach, it's hard for me to imagine much less linker impact.

<p>
Now suppose you want to minimize runtime instead of linker impact --
the first suggested implementation scheme.  There are at least two
approaches:

<ul>
<p>
<li>
   The linker sorts the SHT_CXX_PRIORITY_INIT section after generating
   it, and emits bracketing __cxx_priority_init_<begin,end> calls in
   init_array entries itself.

<p>
<li>
   To make things even simpler for the runtime, the linker could also
   convert init_array entries in the .o files to CXX_PRIORITY_INIT
   section entries with priority zero, reducing everything to a single
   init_array entry that calls __cxx_priority_init.
</ul>

<p>
One of my original objectives, and I think a key attribute of this
proposal, is that this full range of possible implementations, from
minimal linker impact to minimal runtime impact, makes absolutely no
difference to the generated .o files -- compatibility between compilers
does not depend on the chosen link-time implementation.

<p>
<h5> B) Sorting approach </h5>

<p>
Sorting is a more interesting issue.  I see four possibilities:

<ol type=1>
<p>
<li> No sorting -- the low-linker-impact approach above.

<p>
<li> Implicit sorting -- the low-runtime approach above, with knowledge
   explicit in the linker about how to sort SHT_CXX_PRIORITY_INIT.

<p>
<li> Explicit sorting within a section, e.g. what my proposal described,
   based on an explicit sorting specification that describes the size
   of objects to be sorted and the key location.

<p>
<li> Explicit sorting of sections, based on a sort key encoded in the
   section name (for example).
</ol>

<p>
I'll say up front that I think implicit sorting is adequate for the
purpose at hand, and I'd like to understand other applications before
I'd choose (3) or (4).

<p>
There are two differences between (3) and (4):

<ul>
<p>
<li> the unit of sorting (an object within a section, or a whole section)

<p>
<li> the sort key (part of the data, or separate from the data).
</ul>

<p>
Either would work for the application at hand.  Approach (3) would
require only one SHT_CXX_PRIORITY_INIT section per .o file, while
approach (4) would require up to one such section per constructor call
(though only if the user used lots of different priorities).  I
personally think sorting based on a data vector that's already been
concatenated should be much more efficient, but it probably doesn't
matter much.

<p>
On the other hand, sorting an arbitrarily-sized section, based on an
external key, is more flexible except that the keys may be more
constrained.  So, again, I think the choice comes down to other
applications of the feature.  Absent significant other demands, I'd
just stick to implicit sorting (and optional at that) for now.

<p>
<font color=blue><hr><p>[991202 All]</font>
An extensive discussion failed to reach concensus,
but clarified the issues.

<p>
The proposed alternative of sorting based on section name is
specifically the Linux implementation of treating all section names
containing a dollar sign ($) as being a section name before the dollar
sign and a sort key after it.
As mentioned above, this has the advantage of being more general,
except with respect to the sort key, which isn't an issue here,
and it is implemented in Linux.

<p>
The primary concern with the Linux approach is that some
implementations must deal with static linkers which are under control
of other groups or companies,
and therefore can't depend on getting linker sorting implemented.
IBM has been in that position,
though it isn't clear whether it will be an issue on IA-64.

<p>
A secondary concern is a general objection from SGI to features that
depend on section naming rather than section types and attributes.

<p>
Jim will attempt to frame the issue and get feedback from the base ABI
group.

<p>
<font color=blue>[000106 All]</font>
We will wait for base ABI feedback before deciding.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C3></a> <td> C-3 </td>
<td> Order of ctors/dtors w.r.t. DSOs </td>
<td> ps </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> reopened </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Given the constructor/destructor calls for each executable object
comprising a program, what is the order of execution between objects?
For constructors, there is not much question:
unless we choose some explicit means of control,
file-scope objects will be initialized by the DT_INIT/DT_INITARRAY
functions in the order determined by the base ABI order rules,
and local objects will be initialized in the order their containing
scopes are entered.
<p>
For destructors, the Standard requires opposite-order destruction,
which implies a runtime structure to keep track of the order.
Furthermore, the potential for dynamic unloading of a DSO
(e.g. by dlclose)
requires a mechanism for early destruction of a subset.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#C3> Resolution</a></b>:
Accept SGI proposal for a simple API which registers destructors and
atexit calls.
</td> </tr>

</table>

<p>
<font color=blue><hr><p>[990804 SGI -- Jim]</font>
<h4> Proposal </h4>

<p>
My objectives are:
<ul>
<li> Simple library interface.
<li> Efficient handling during construction.
<li> Standard-conforming treatment during normal program exit.
<li> Reasonable treatment during early DSO unload (e.g. dlclose).
<li> Minimal dynamic and static linker impact.
</ul>

<p>
<h5> Runtime Data Structure </h5>

<p>
The runtime library shall maintain a list of termination functions
with the following information about each:

<ul>
<li> A function pointer (a pointer to a function descriptor on IA-64).
<li> A void* operand to be passed to the function.
<li> A void* handle for the <i>home DSO</i> of the entry (below).
</ul>

<p>
The representation of this structure is implementation defined.
All references are via the API described below.

<p>
<h5> Runtime API </h5>

<ol type=A>
<p>
<li> Object construction:
<p>
When a global or local static object is constructed,
which will require destruction on exit,
a termination function is <i>registered</i> as follows:
<center><code>
int __cxa_atexit ( void (*f)(void *), void *p, dso_handle d );
</code></center>
This registration, e.g. <code>__cxa_atexit(f,p,d)</code>,
is intended to cause the call <code>f(p)</code> when DSO d is unloaded,
before all such termination calls registered before this one.
It returns zero if registration is successful, nonzero on failure.
<font color=red>Should we use exceptions instead?</font>

<p>
The registration function is called separate from the constructor.

<p>
<li> User atexit calls:
<p>
When the user registers exit functions with <code>atexit</code>,
they should be registered with NULL parameter and DSO handle, i.e.
<center><code>
__cxa_atexit ( f, NULL, NULL );
</code></center>
It is expected that implementations supporting both C and C++ will
integrate this capability into the libc <code>atexit</code>
implementation, so that C-only DSOs will nevertheless interact with C++
programs in a C++-standard-conforming manner.
No user interface to __cxa_atexit is supported,
so the user is not able register an <code>atexit</code> function with a
parameter or a home DSO.
</font>

<p>
<li> Termination:
<p>
When linking any DSO containing a call to <code>__cxa_atexit</code>,
the linker should define a hidden symbol <code>__dso_handle</code>,
with a value which is an address in one of the object's segments.
(It doesn't matter what address,
as long as they are different in different DSOs.)
It should also include a call to the following function in the FINI
list (to be executed first):
<center><code>
void __cxa_finalize ( dso_handle d );
</code></center>
The parameter passed should be <code>__dso_handle</code>.

<p>
Note that the above can be accomplished either by explicitly providing
the symbol and call in the linker, or by implicitly including a
relocatable object in the link with the necessary definitions,
using a .fini_array section for the FINI call.
Also, note that these can be omitted for an object with no calls to
<code>__cxa_atexit</code>, but they can be safely included in all objects.

<p>
Finally, a main program should be linked with a FINI call to
<code>__cxa_finalize</code> with NULL parameter.

<p>
When <code>__cxa_finalize(d)</code> is called,
it should walk the termination function list,
calling each in turn if <code>d</code> matches
<code>__dso_handle</code> for the termination function entry.
If <code>d == NULL</code>, it should call all of them.
Multiple calls to <code>__cxa_finalize</code> should not result in
calling termination function entries multiple times;
the implementation may either remove entries or mark them finished.

<p>
<font color=red>
Issue: By passing a NULL-terminated vector of DSO handles to
<code>__cxa_finalize</code> instead of one,
we could deal with unloading multiple DSOs at once.
However, <code>dlclose</code> closes one at a time,
so I'm not sure the extra complexity is worthwhile.
</font>

</ol>

<p>
Since <code>__cxa_atexit</code> and <code>__cxa_finalize</code>
must both manipulate the same termination function list,
they must be defined in the implementation's C++ runtime library,
rather than in the individual linked objects.


<p>
<font color=blue><hr><p>[991202 All]</font>
The proposal above is accepted, with three changes (integrated above):
<ul>
<p>
<li> The "__cxx_" prefixes are changed to "__cxa_".
    This matches the prefix chosen for the exception handling API,
    and stands (loosely) for "C++ ABI".
<p>
<li> Clarify that integration into the C libc library is expected.
<p>
<li> Clarify that no user interface to 
    <code>__cxa_atexit</code> is supported.
</ul>

<p>
During discussion, it was noted that this proposal will not deal
effectively with DSOs which (a) have cross-DSO destructor interactions
and (b) are unloaded dynamically.
It is generally believed that such code would not reliably work on a
variety of platforms today,
and is not a robust methodology worthy of ABI support.
However, note that if it becomes an issue,
it would be possible to define a <code>__cxa_finalize</code> analog
which takes a list of DSOs instead of a single DSO,
and if the program or dynamic linker identifies a set of DSOs to be
unloaded together, run their finalization entries in a single pass
instead of one DSO at a time.


<p>
<font color=blue><hr><p>[991215 CodeSourcery -- Mark]</font>
Note that the type of "__dso_handle" above is not specified.
Since the simplest implementation is for the static linker to resolve
it into an arbitrary address in the DSO, define it as "void *".


<p>
<font color=blue><hr><p>[991216 CodeSourcery -- Mark]</font>

<p>
What I'm suggesting (for exit finalization) is:

<ul>
<p>
<li> As in the ABI, atexit calls __cxa_atexit.

<p>
<li> When `exit' is called, it invokes all the things registered with
    all of __cxa_atexit, atexit, and (possibly) on_exit.

<p>
<li> When a shared library is unloaded, it calls __cxa_finalize, which
    behaves exactly as in the ABI.

<p>
<li> When a main program exits, it does not call __cxa_finalize.
    Instead, it just calls exit.  That does the things described
    above.
</ul>


<p>
<font color=blue><hr><p>[991217 CodeSourcery -- Mark]</font>
I've attached the GNU libc source files.  Basically, none of these
routines are implemented in terms of the others; instead, they just
share a common data structure.  I think the source will make it clear;
none of these files is more than 50 lines or so.

<code><pre>
================================
=====  filename="cxa_atexit.c"
================================

/* Copyright (C) 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include <stdlib.h>
#include "exit.h"

/* Register a function to be called by exit or when a shared library
   is unloaded.  This function is only called from code generated by
   the C++ compiler.  */
int
__cxa_atexit (void (*func) (void *), void *arg, void *d)
{
  
  struct exit_function *new = __new_exitfn ();

  if (new == NULL)
    return -1;

  new->flavor = ef_cxa;
  new->func.cxa.fn = func;
  new->func.cxa.arg = arg;
  new->func.cxa.dso_handle = d;
  return 0;
}

================================
=====  filename="cxa_finalize.c"
================================

/* Copyright (C) 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include <stdlib.h>
#include "exit.h"

/* If D is non-NULL, call all functions registered with `__cxa_atexit'
   with the same dso handle.  Otherwise, if D is NULL, do nothing.  */

void
__cxa_finalize (void *d)
{
  struct exit_function_list *funcs;

  if (!d)
    return;

  for (funcs = __exit_funcs; funcs; funcs = funcs->next)
    {
      struct exit_function *f;

      for (f = &funcs->fns[funcs->idx - 1]; f >= &funcs->fns[0]; --f)
        {
          if (f->flavor == ef_cxa && d == f->func.cxa.dso_handle)
            {
              (*f->func.cxa.fn) (f->func.cxa.arg);
              /* We don't want to run this cleanup again.  */
              f->flavor = ef_free;
            }
        }
    }
}

===========================
=====  filename="atexit.c"
===========================

/* Copyright (C) 1991, 1996, 1999 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include <bits/libc-lock.h>
#include <stdlib.h>
#include "exit.h"


/* Register FUNC to be executed by `exit'.  */
int
atexit (void (*func) (void))
{
  struct exit_function *new = __new_exitfn ();

  if (new == NULL)
    return -1;

  new->flavor = ef_at;
  new->func.at = func;
  return 0;
}


/* We change global data, so we need locking.  */
__libc_lock_define_initialized (static, lock)


static struct exit_function_list initial;
struct exit_function_list *__exit_funcs = &initial;

struct exit_function *
__new_exitfn (void)
{
  struct exit_function_list *l;
  size_t i = 0;

  __libc_lock_lock (lock);

  for (l = __exit_funcs; l != NULL; l = l->next)
    {
      for (i = 0; i < l->idx; ++i)
        if (l->fns[i].flavor == ef_free)
          break;
      if (i < l->idx)
        break;

      if (l->idx < sizeof (l->fns) / sizeof (l->fns[0]))
        {
          i = l->idx++;
          break;
        }
    }

  if (l == NULL)
    {
      l = (struct exit_function_list *)
        malloc (sizeof (struct exit_function_list));
      if (l != NULL)
        {
          l->next = __exit_funcs;
          __exit_funcs = l;

          l->idx = 1;
          i = 0;
        }
    }

  /* Mark entry as used, but we don't know the flavor now.  */
  if (l != NULL)
    l->fns[i].flavor = ef_us;

  __libc_lock_unlock (lock);

  return l == NULL ? NULL : &l->fns[i];
}

===========================
=====  filename="on_exit.c"
===========================

/* Copyright (C) 1991, 1996 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#include <stdlib.h>
#include "exit.h"

/* Register a function to be called by exit.  */
int
__on_exit (void (*func) (int status, void *arg), void *arg)
{
  struct exit_function *new = __new_exitfn ();

  if (new == NULL)
    return -1;

  new->flavor = ef_on;
  new->func.on.fn = func;
  new->func.on.arg = arg;
  return 0;
}
weak_alias (__on_exit, on_exit)

========================
=====  filename="exit.h"
========================

/* Copyright (C) 1991, 1996, 1997 Free Software Foundation, Inc.
   This file is part of the GNU C Library.

   The GNU C Library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Library General Public License as
   published by the Free Software Foundation; either version 2 of the
   License, or (at your option) any later version.

   The GNU C Library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with the GNU C Library; see the file COPYING.LIB.  If not,
   write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */

#ifndef _EXIT_H
#define _EXIT_H 1

struct exit_function
  {
    enum {
       ef_free, ef_us, ef_on, ef_at, ef_cxa } flavor;
		/* `ef_free' MUST be zero! */
    union
      {
        void (*at) (void);
        struct
          {
            void (*fn) (int status, void *arg);
            void *arg;
          } on;
        struct
          {
            void (*fn) (void *arg);
            void *arg;
            void *dso_handle;
          } cxa;
      } func;
  };
struct exit_function_list
  {
    struct exit_function_list *next;
    size_t idx;
    struct exit_function fns[32];
  };
extern struct exit_function_list *__exit_funcs;

extern struct exit_function *__new_exitfn (void);

#endif  /* exit.h  */
</pre></code>



<p>
<font color=blue><hr><p>[991220 SGI -- Jim]</font>
<p>
In the elf context assumed by the base IA-64 ABI, I expect that a C++
program will typically be running with the C run-time library libc.so,
the C++ runtime library libC.so, likely other system DSOs, and its own
components.

<p>
In this context, achieving an integrated solution could be accomplished
in a couple of ways.  The obvious one is to replace the routines
atexit, on_exit, and exit in the C run-time library with routines that
are cognizant of the C++ __cxa_atexit and __cxa_finalize facilities.
a less obvious method, but still generally usable, would be to insert
C++-specific versions of them in the C++ runtime library, and depend on
preemption to achieve the replacement.  This works as long as libC.so
precedes libc.so in the library list.

<p>
There are other possible non-integrated solutions, but given the
assumption of the underlying IA-64 ABI, and the fact that the second
solution above can work without changing the underlying C run-time
library, it doesn't seem necessary to consider them.

<p>
What is an issue, however, is that the application could in theory be
linked on a different system than the one where it ultimately runs,
and therefore presumably on a different system than that which built
the run-time library DSOs.  It is that interface which we need to pin
down, namely (a) what routines (with what interfaces and semantics)
must be present in libC.so/libc.so, and (b) what sequences of calls
the libraries may assume the program will make.

<p>
We appear to be agreed on the presence of __cxa_atexit and
__cxa_finalize in libC.so, on the registration of C++ destructors
and C atexit cleanup with __cxa_atexit, and on the use of
__cxa_finalize for destructor execution upon early unloading.
The open questions are (1) whether (or how) on_exit registration can
be integrated, and (2) how the final cleanup is invoked.

<p>
The original proposal adopted ignored (1) out of ignorance, and
answered (2) by specifying a call to __cxa_finalize(NULL).  If (1) is
addressed by calling __cxa_atexit for on_exit with a parameter, and
passing an additional exit code parameter to __cxa_finalize (and thence
to all the finalization actions it invokes), this works, i.e. on_exit
works as currently defined by Sun and is properly integrated into the
finalization order.  But that assumes that the exit code is available
for passing to __cxa_finalize, which may imply calling it from exit if
it's not available to a .fini_array routine (which was what the
original proposal specified).

<p>
Mark points out that it works to just assume that exit does the
call to __cxa_finalize, or performs the equivalent processing,
eliminating the need for the explicit __cxa_finalize call in
.fini_array.  This is slightly simpler in that it doesn't require
generation of the .fini_array entry, and the library implementation
can coordinate features like on_exit without exposing the interfaces
necessary to implement them.  It also probably preserves more
faithfully the traditional semantics that atexit routines are executed
before the main program .fini_array, although doing __cxa_finalize
first in the latter should produce the same effect.

<p>
Note that we can't just not choose -- one approach requires the builder
of the main executable to insert a .fini_array entry, while the other
doesn't -- unless we want to require the run-time to handle either,
which doesn't seem useful.

<p>
My current preference is to proceed with Mark's proposal, requiring
that exit handle the __cxa_atexit -registered calls (but _not_
requiring that anyone explicitly register __cxa_finalize or anything
else to accomplish that).  Upon re-reading all the mail, this seems
quite workable.  In any case, I'll re-open the issue and we can discuss
it next time.




<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C4></a> <td> C-4 </td>
<td> Construction vtables </td>
<td> call </td>
<td> open </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
When calling a virtual function from the constructor/destructor of a
base subobject,
the version specific to the base type is required,
unlike the typical case when calling such a vfunc for the full object
from some other context.
Since the pointer for that vfunc in the the subobject's sub-vtable
of the full object's vtable is the full object version,
some other means is required for accessing the correct vfunc.
</td> </tr>

</table>

<p>
<font color=blue>[990630 HP -- Christophe]</font>
A rough idea from Christophe's original vtable layout proposal
has been incorporated in the
<a href=abi-layout.html#vtable-ctor>ABI data layout document</a>.

<p>
<font color=blue>[000217 All]</font>
Coleen has generated <a href=abi-layout.html#vtable-ctor>a proposal</a>.

<p>
<font color=blue>[000308 All]</font>
Discussed and clarified the proposal.
Jim will clarify the content descriptions.
Coleen will describe how some of the base vtables can be eliminated
from the construction vtable groups given vbase promotion.
She should be out to California in two weeks,
so we can finalize this issue.

<p>
<font color=blue>[000323 All]</font>
Discussion clarified the two proposals and their relative merits:
<ul>

<p>
<li>
Proposal A has a VTT with pointers only to full vtable groups,
which are special construction vtable groups except for those bases
where the entire group can be the normal complete object group.

<p>
<li>
Proposal B has a VTT with pointers to all the vtables in the vtable
groups for all of the bases,
but individual vtable pointers can reference the normal group
(or even construction groups for other bases).

<p>
<li>
Therefore, B will have a larger VTT but smaller construction vtables.
Overall, we should expect much less space required by proposal B.
Because of this in particular,
and the sharing of vtables for the construction of various bases as
well as normal post-construction usage,
B should have better cache behavior.

<p>
<li>
In A, the vpointers are populated by loading a group address from the VTT
and doing an add and store for each base.
In B, we must do a load/store pair for each base.

<p>
<li>
B breaks the ability to assume that,
if you have a vpointer for one secondary non-virtual vtable,
you can use it to access the other secondary vtables at known offsets.
We know of noone that does this optimization today,
and it only affects multiple inheritance.

</ul>

<p>
It was decided that the space savings outweighed the lost optimizations,
and proposal B was adopted.
Jim will clean up the writeup for final adoption.

<p>
For the record,
following are several issues that have been raised and resolved in the
process of developing this proposal:

<ul>
<li>
We could separate the VTT array from the vtable,
and provide a new VTT data item.
<font color=purple><i>
We will do so.
</i></font>
<li>
We could also make the VTT static so it has no linkage
and is created in the modules that define the constructors and destructor
of a class.  I don't think they would take that much space.
<font color=purple><i>
We will not do this.
To avoid replicating the construction vtables, which are big,
we need to allocate them with the main vtable with a known interface.
So there's no benefit to putting the VTT elsewhere.
</i></font>
<li>
The subobject construction vtables do not need to be contiguous to the
normal vtable, since they will be accessed via the VTT.
<font color=purple><i>
We will not require them to be contiguous.
</i></font>
</ul>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C5></a> <td> C-5 </td>
<td> Calling destructors </td>
<td> call </td>
<td> closed </td>
<td> Sun </td>
<td> 990603 </td>
<td> 991104 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What is the calling convention for destructors?
Do virtual destructors require special treatment?
Is delete() integrated with the destructor call or separate?
How is delete() handled when invoked on a base subobject?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#C5> Resolution</a></b>:
Destructors are called with a reference to <i>this</i>.
Virtual destructors have two versions, and two entries in the vtable,
one that deletes the object after destruction, and one that doesn't.
There is a third version that does not delete the object,
and is not in-charge, i.e. does not destroy any base objects;
it is not called via the vtable.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C6></a> <td> C-6 </td>
<td> Extra parameters to constructors </td>
<td> call </td>
<td> closed </td>
<td> Cygnus </td>
<td> 990603 </td>
<td> 991104 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
When calling constructors for classes with virtual bases,
what information about the treatment of virtual base subobjects
in the full class, or about object allocation,
must be transmitted to the constructor in parameters?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#C6> Resolution</a></b>:
None.
Two versions, and two entrypoints,
of the constructor will be created:
one that calls the virtual base subobject constructor (in-charge),
and one that does not.
Object allocation will be done by the caller.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C7></a> <td> C-7 </td>
<td> Passing value parameters by reference </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 990624 </td>
<td> 990805 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It may be desirable in some cases where a type has a non-trivial
copy constructor to pass value parameters of that type by performing
the copy at the call site and passing a reference.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#C7> Resolution</a></b>:
Whenever a class type has a non-trivial copy constructor,
pass value parameters of that type by performing
the copy at the call site and passing a reference.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C8></a> <td> C-8 </td>
<td> Returning classes with non-trival copy constructors </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 990625 </td>
<td> 990722 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How do we return classes with non-trivial copy constructors?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#C8> Resolution</a></b>:
The caller allocates space,
and passes a pointer as an implicit first parameter
(prior to the implicit <i>this</i> parameter).
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C9></a> <td> C-9 </td>
<td> Passing parameters with ctors/dtors </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 991028 </td>
<td> 991104 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Where do allocation, construction, destruction, and deallocation occur
for value parameters?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#C9> Resolution</a></b>:
<a href=cxx-closed.html#C9>closed issues list</a>.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C10></a> <td> C-10 </td>
<td> Synthesized copy assignments </td>
<td> call </td>
<td> closed </td>
<td> All </td>
<td> 991028 </td>
<td> 991028 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Should we specify special treatment for synthesized copy assignments,
to avoid multiple copies of virtual bases?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#C10> Resolution</a></b>:
No.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C11></a> <td> C-11 </td>
<td> Array constructors/destructors </td>
<td> call </td>
<td> closed </td>
<td> Cygnus </td>
<td> 000130 </td>
<td> 000309 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How are constructors/destructors run for arrays?
Many compilers use a <code>__vec_new</code> function;
g++ doesn't, to allow for inlining of constructors.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#C11> Resolution</a></b>:
Define standard library entries for array construction/destruction.
See the <a href=abi-layout.html#array-ctor>ABI Layout</a> document.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C12></a> <td> C-12 </td>
<td> Constructor return values </td>
<td> call </td>
<td> closed </td>
<td> Cygnus </td>
<td> 000130 </td>
<td> 000309 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What is the return value of a constructor?
Void, this, ...?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#C11> Resolution</a></b>:
Void.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C13></a> <td> C-13 </td>
<td> Allocating constructors </td>
<td> call </td>
<td> open </td>
<td> HP </td>
<td> 000309 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Should we define allocating constructors?
</td> </tr>

</table>

<p>
<font color=blue>[000308 HP -- Christophe]</font>
We should consider defining alternate constructors which
allocate the object before constructing it.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=C14></a> <td> C-14 </td>
<td> Local-scope dynamic constructors </td>
<td> data </td>
<td> open </td>
<td> all </td>
<td> 000309 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The Standard requires that local static objects with dynamic
constructors be initialized exactly once,
the first time the containing scope is entered.
This requires a data object to serve as a guard variable;
define its content or interface.
</td> </tr>

</table>

<p>
<font color=blue>[000309 All]</font>
We have defined a mangling for the guard variable object (issue F-1),
but we need to define at least its size and either its content or
a library interface to it.
This is tied up with multithreading issue G-4.
If we want the initialization to be implicitly thread-safe,
the object probably needs to contain both an initialized flag
and a thread semaphore,
and it is desirable that they be in different cache lines.



<p> <hr> <p> <a name=Dstart></a>
<h3> Exception Handling Issues </h3>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D0></a> <td> D-0 </td>
<td> Exception handling framework </td>
<td> lib ps </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991216 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the general framework for exception handling,
including Level I (psABI unwinding API)
and Level II (C++ ABI exception handling API).
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D0> Resolution</a></b>:
See the <a href=exceptions.pdf> HP proposal</a>,
accepted as a working paper,
and discussions in the closed issues page.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D1></a> <td> D-1 </td>
<td> Language-specific data area format </td>
<td> lib ps </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA-64 runtime conventions describe language-independent descriptors
for restoring registers when unwinding the stack.
The do not specify how C++ performs language-specific unwinding for
exception handling, i.e. locating a handler and destroying automatic
objects.
Note that this can be handled by agreeing on common descriptors,
or by agreeing on per-frame personality routines with common APIs.
</td> </tr>

</table>

<p>
<font color=blue>[990715 Cygnus -- Jason]</font>
The languge-specific part of the EH stack in g++ contains these
elements:

<p>
<code><pre>
void *value; // pointer to the thrown object, or the thrown value
             // itself if a pointer
void *type;  // pointer to the type_info node for the thrown object
void (*cleanup)(void *, int) // pointer to the dtor for the object
bool caught; // has this exception been caught since its last throw?
long handlers; // how many catch handlers are active for this exception
</code></pre>

<p>
Both 'caught' and 'handlers' are needed to handle rethrowing and
catching within a catch block.

<p>
Language interaction is handled by recording the language of both the
exception region and the thrown exception.  Each thrown exception also
includes a pointer to a language-specific matching function which is
called to compare the types of the exception and handler.

<p>
<font color=blue>[991209 all]</font>
Observe that this issue is part of a
<a href=#exception-level3>level 3 specification</a>,
i.e. part of a common runtime specification,
but not strictly part of the ABI.
It is described as part of the
<a href=http://reality.sgi.com//dehnert_engr/cxx/exceptions.pdf>
EH working paper</a> from HP.

<p>
<font color=blue>[991216 all]</font>
The <code>__typeinfo</code> type defined in 7.6 of the working paper
should be replaced by the ABI standard <code>type_info</code>.
The treatment of predefined types must be specified.

<p>
<font color=blue>[000126 editor]</font>
This issue is effectively closed by virtue of accepting the working
paper (D-0),
but I will not close it officially until the
<a href=exceptions.pdf>working paper</a>
reflects the <code>__typeinfo</code> change.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D2></a> <td> D-2 </td>
<td> Unwind personality routines </td>
<td> lib ps </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 000106 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA-64 runtime conventions provide for a personality routine
pointer for language-specific actions when unwinding the stack.
They do not specify its interface.
There are typically two required actions for C++:
locating a handler (non-destructively)
and destroying automatic objects while unwinding.
This issue involves specification of the API (see also D-3).
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D2> Resolution</a></b>:
See the <a href=abi-eh.pdf> exception handling specification</a>,
level 1, and the <a href=exceptions.pdf>working paper</a>.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D3></a> <td> D-3 </td>
<td> Unwind process clarification </td>
<td> lib ps </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 000106 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA-64 runtime conventions provide for a personality routine
pointer for language-specific actions when unwinding the stack.
However, they are quite muddy about the precise sequence of calls.
This issue involves specification of unwind process (see also D-2).
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D3> Resolution</a></b>:
See the <a href=abi-eh.pdf> exception handling specification</a>.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D4></a> <td> D-4 </td>
<td> Unwind routines nested? </td>
<td> lib ps </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 991209 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA-64 runtime conventions call for the unwind personality routine
to behave like a routine nested in the routine raising an exception.
Is that the preferred definition?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D4> Resolution</a></b>:
This is not required, nor included in the proposed common implementation.
However, a conforming implementation could add this option in the
personality routine and tables.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D5></a> <td> D-5 </td>
<td> Interaction with other languages (e.g. Java) </td>
<td> lib ps </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 991007 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The IA64 exceptions handling framework is largely language independent.
What is the behaviour of a C++ runtime receiving, for instance,
an exception thrown from Java?
Does it call terminate()?
Does it allow the exception to pass through C++ code with destructors
if there is no catch clause?
Does it allow the exception to be caught in a catch(...) provided this
catch(...) ends with a rethrow?
Does it allow even more?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D5> Resolution</a></b>:
In general, foreign exceptions will cause normal destructor invocation
and other cleanup in C++ code, and will pass through C++ frames except
where explicit exception specifications do not allow them.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D6></a> <td> D-6 </td>
<td> Allow resumption in other languages? </td>
<td> lib ps </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 991007 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The exception handling framework requires the interaction of the
runtime of all the languages "on the stack" during exception processing.
Some of these languages may have very different exception handling semantics.
What are the constraints we impose on the C++ exception handling runtime
to preserve the relative language neutrality of the EH framework?
Example: do we allow a handler to cleanup and resume at the point
where the exception was thrown?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D6> Resolution</a></b>:
Moot -- resume-type exceptions are more appropriately handled by
registering trap handlers and processing them in place.
No interaction with stack traceback should be necessary.
</td> </tr>

</table>

<p>
<font color=blue>[990908 SGI -- Jim]</font>
The typical case of cleanup and resume is floating point trap handling,
which is normally handled entirely in the original FP trap handler.
Is there an example where stack walkback must occur to identify the
handler, but resumption at the point-of-exception is required?
I can't think of any, and I think the model of registering a trap
handler is preferable for such purposes.

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D7></a> <td> D-7 </td>
<td> Interaction with signals or asynch events </td>
<td> lib ps </td>
<td> closed </td>
<td> HP </td>
<td> 990603 </td>
<td> 991209 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The Standard says that the behavior of anything other than
"pure C code" (POF) is implementation defined,
and warns (in a note) against using EH in a signal handler.
We should define what is supported,
possibly explicitly stating that signal handler code must be a POF.
We could allow any feature but exception handling to be used.
We could allow some EH routines to be called
(for instance, <code>uncaught_exception()</code>).
Or we could allow even an exception to be thrown,
if it does not exit the handler.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D7> Resolution</a></b>:
This ABI requires no support beyond the Standard requirements.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D8></a> <td> D-8 </td>
<td> Interaction with threads packages </td>
<td> lib ps </td>
<td> closed </td>
<td> SGI </td>
<td> 990603 </td>
<td> 000106 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What happens when an exception is not caught in the thread where raised?
What does <code>uncaught_exception()</code>
return if another thread is currently processing an exception?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D8> Resolution</a></b>:
With one exception, exception handling is entirely per-thread --
exceptions must be caught in the thread where raised,
and queries about them (e.g. <code>uncaught_exception()</code>)
are answered only with respect to the thread doing the query.
The only global exception behavior is handler registration --
see <a href=cxx-closed.html#D15>issue D-15</a>.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D9></a> <td> D-9 </td>
<td> longjmp interaction </td>
<td> lib ps </td>
<td> closed </td>
<td> IBM </td>
<td> 990908 </td>
<td> 000113 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Does longjmp run destructors?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D9> Resolution</a></b>:
Define an alternate routine, longjmp_unwind in namespace abi,
defined in new header cxxabi.h,
which always does full cleanup during unwinding.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D10></a> <td> D-10 </td>
<td> psABI proposal </td>
<td> lib ps </td>
<td> closed </td>
<td> all </td>
<td> 991216 </td>
<td> 000120 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Solidify the Level I (psABI) specification and submit it to the base
ABI group.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D10> Resolution</a></b>:
See the <a href=abi-eh.html#forced>exception handling specification</a>.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D11></a> <td> D-11 </td>
<td> pthreads interface </td>
<td> lib ps </td>
<td> closed </td>
<td> all </td>
<td> 991216 </td>
<td> 000203 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Certain pthreads functionality is a prerequisite,
e.g. to acquire thread-local storage.
The ABI should specify the requirements,
along with the expected stub behavior when
the pthreads library is not present.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D11> Resolution</a></b>:
No specification necessary.
This is Level 3 material.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D12></a> <td> D-12 </td>
<td> Table location </td>
<td> lib ps </td>
<td> open </td>
<td> all </td>
<td> 991216 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Determine constraints on the location of the unwind table
and the unwind information table.
</td> </tr>

</table>

<p>
<font color=blue>[991216 SGI -- Jim]</font>
The unwind table consists of triples:
a begin and end location bounding the code fragment described by the
unwind descriptors,
and the location of the unwind information for this fragment.
The base psABI states that these are segment-relative offsets,
to avoid the need to relocate them at runtime.
It also specifies a section type and name for the unwind table,
with attribute <code>SHF_ALLOC</code> (but not writable),
as well as a segment type,
but does not specify the unwind information table section information.

<p>
The psABI specification leaves open the question of how to identify the
relevant segments for the unwind table segment-relative entries.
There are several possibilities:

<ul>
<p>
<li>
The intended method is to put both the unwind tables
and the unwind information tables in the text segment they describe.
That is, the relevant text segment would contain these tables,
and the unwind table segment would be an overlay segment.
Then the identification of referenced segments just requires
determining which text segment contains the unwind segment.

<p>
Forcing the unwind information tables into the text
segment is constraining.
Given that their format is undefined by the ABI
(i.e. the language-specific data area),
the severity of that constraint is not fully predictable.
It would, for example, interfere with the bias in some systems to
avoid data in text segments.

<p>
<li>
The very preliminary (i.e. hacked) SGI implementation put the unwind
information tables in data with their own section name,
and used the section table to find them.
This works, but using the section table is not desirable.

<p>
<li>
A fully general solution would be a table of triples,
each containing segment pointers for the unwind table segment and the
segments containing its associated unwind information table and text.
It would usually contain one triple,
but it is desirable to allow multiple text segments and therefore
multiple triples.
It could be located via a dynamic tag,
which is consistent with how we usually locate things at runtime.

</ul>

<p>
<font color=blue><hr><p>[000120 HP -- Cary]</font>
The first bullet you listed is the intended method.
Both the unwind table and the unwind info blocks are intended
to be in the same segment as the text with which they're associated.
Thus, any segment-relative addresses in those tables are understood
to refer to locations in the same segment.

<p>
To overcome any limitations that placing info blocks in text might impose,
we designed the LTV family of relocations,
which allows a link-time virtual address to be placed in an info block
without requiring a dynamic relocation;
the consumer is expected to be able to calculate from context what
segment the LTV address refers to so it can relocate the address on the fly.
We also have the LTOFF_FPTR family of relocations,
which is needed to identify the personality routine as a gp-relative
offset to a linkage table entry that contains the function pointer.

<p>
The advantages to this scheme are that there are no dynamic relocations
for any unwind information
(except function pointers in the GOT created by LTOFF_FPTR),
and that the unwind information does not cause any 
increase in the application's per-process data space.

<p>
In order to unwind correctly,
it's important that there is a one-to-one
relationship between text segments and unwind tables.
The dynamic loader needs to keep track of these relationships,
so that the unwinder can find the appropriate unwind table,
given a pc value.

<p>
Instead of a table of triples,
there is a PT_UNWIND program header table entry that locates
the unwind information for a load module;
this entry is intended to refer to a subset of the text segment.
It's through this entry that the dynamic loader finds the unwind table.

<p>
<font color=blue><hr><p>[991224 SGI -- Jim]</font>
My concern with this comes from the possibility of
generating multiple text segments.
In such a case, if an implementation wants to put the
unwind information in a separate segment from text,
there's no longer a trivial way to find the associated text segments for fixup.
And although I have no objection to putting these in text today for C++,
I'm concerned that a future requirement for C++ or some other language
might make it desirable to put them in data.
If there's a simple way of making this work, I'd like to pursue it.

<p>
<font color=blue><hr><p>[000126 HP -- Cary]</font>

<p>
<b>Re. multiple text segments...</b>

<p>
Our position is that we would only need more than one text segment in a
single load module where we need to establish different access 
permissions for some text pages than for others.
In such a case, we consider them to be separate -- but contiguous --
text segments from the loader's point of view,
and a single text segment from the unwinder's point of view.
Therefore, we still need only one unwind table per load module.

<p>
This points out the hazy definition of "segment" and "program header 
table entry" in the ELF specification.
Some program header table entries describe segments that are disjoint
from all other segments,
while others (like PT_DYNAMIC and PT_UNWIND)
describe "sub-segments" that are really part of another segment.

<p>
<b>Re. unwind tables in data...</b>

<p>
The performance bigots here would *never* let me put the unwind tables
in the data segment.
Nevertheless, if some language-specific data really needs to be in data,
it can be arranged by putting "LTV" pointers in the language-specific
data that point to an auxiliary block of info in the data segment.
A much earlier version of our C++ exception handling tables 
in fact did just that.

<p>
("LTV" pointers are "link-time virtual" addresses.
At link time,
an LTV relocation works just like the corresponding DIR relocation,
except that no dynamic relocation is generated,
so the associated word can be placed in a read-only segment.
The consumer of that pointer must, at run time,
figure out what segment the link-time virtual address refers to and
apply the appropriate relocation factor to the address.
The required information can be obtained from the dynamic loader.
Note that this scheme requires that the linker-assigned addresses
for all of the loadable segments do not overlap.)

<p>
<dl>
<dd> [Jim]
Does the ABI require that the segment table be allocated?
Easy to find?
</dd>
</dl>

<p>
No, but the dynamic loader does have access to it.
When we need to find an unwind table,
we ask the dynamic loader:
given a pc value, its <code>dlmodinfo()</code> entry point locates
the load module containing that text segment,
and returns a struct load_module_desc,
which contains, among other things,
a pointer to the unwind table for that load module.

<p>
<font color=blue><hr><p>[991226 SGI -- Jim]</font>
An observation, then:
in order to make this work,
we should specify how to obtain this information in the psABI,
unless <code>dlmodinfo()</code> is already standard.

<p>
<font color=blue><hr><p>[000203 All]</font>
To understand this issue better,
we worked through the EH structures looking at references:

<ol kind=A>
<p>
<li> The unwind table is in its own segment,
    assumed by the HP implementation to be an overlay of .text.
    They find it, and the associated .text segment by a query to
    the dynamic linker based on the IP address to be located.
    They also use linker-defined symbols for the base addresses of text
    and the unwind table,
    which of course depend on only having one of each.
    <p>
    It contains references:
    <ul>
    <li> Start and end addresses of the text fragment which the
	entry describes,
	as an offset from the text base address.
    <li> Address of the unwind information entry for the fragment,
	as an offset from a segment assumed to be .text.
    </ul>

<p>
<li> The unwind info table is
    assumed by the HP implementation to be contained in .text,
    and is referenced from the unwind table via .text-segment-relative
    offsets.
    <p>
    It contains references:
    <ul>
    <li> Unwind descriptor references are relative to the text fragment.
    <li> A landing pad start pointer (LPStart),
	at the beginning of the language-specific data area (LSDA),
	represented as an offset relative to its own location,
	and therefore assuming that the LSDA is in the same segment as
	the landing pad if runtime relocation is to be avoided.
    <li> A type table base pointer,
	represented as an offset relative to its own location, 
	and therefore assuming that the LSDA is in the same segment as
	the type table if runtime relocation is to be avoided.
    <li> Other references, to call sites and landing pads,
	are represented as offsets relative to the address contained in
	LPStart.
    </ul>

<p>
<li> The type table is
    assumed by the HP implementation to be contained in .text,
    and is referenced from the unwind info table via self-relative
    offsets.
    <p>
    It contains references:
    <ul>
    <li> To RTTI records,
	relative to the GP for the current text fragment.
	Note that this does not allow for address-only RTTI comparisons,
	since it does not support preemption.
	HP uses the RTTI pointer along with another identifier for
	comparisons.
    </ul>

</ol>



<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D13></a> <td> D-13 </td>
<td> _Unwind_ForcedUnwind </td>
<td> lib ps </td>
<td> closed </td>
<td> all </td>
<td> 991216 </td>
<td> 000120 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the interface of _Unwind_ForcedUnwind.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D13> Resolution</a></b>:
See the <a href=abi-eh.html#forced>exception handling specification</a>.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D14></a> <td> D-14 </td>
<td> __cxa_begin/end_catch </td>
<td> lib </td>
<td> open </td>
<td> all </td>
<td> 991216 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the interfaces of <code>__cxa_begin_catch</code>
and <code>__cxa_end_catch</code>.
</td> </tr>

</table>

<p>
<font color=blue>[991216 All]</font>
Define how <code>__cxa_begin_catch</code>
and <code>__cxa_end_catch</code> identify the thrown exception.

<p>
<font color=blue>[991216 Compaq - Coleen]</font>
If you need to clean up more than one live exception from a
catch handler, don't you need a 'count' parameter to
__cxa_end_catch?  In this case, you destroy both X and
Y objects (whether or not they're both on the stack,
or just X is).

<p>
Our equivalent of end_catch has a count parameter which
is set to the number of live exception objects to
delete and is used for branching out of the nested catch
clause (not by rethrow).

<p>
<code><pre>
struct X {
   X(); ~X(); };
struct Y {
   Y(); ~Y(); };
extern "C" int printf(const char *,...);
main()
{
  try {
    throw X();
  } catch (X x) {
    try {
        throw Y();
    } catch(...) {
        //generates __cxa_end_catch(/*levels=*/2)
        return 1;
    }
  }
}
</pre></code>

<p>
<font color=blue><hr><p>[991217 HP -- Christophe]</font>

The reason __cxa_end_catch does not need the exception argument is that
the exceptions it is interested in are in the "caught stack".
When you rethrow,
the exception you rethrow is also on this caught stack
(it is indeed the top of the stack).
So you don't need a separate copy or argument.

<p>
All you need is a flag set by __rethrow,
saying "this top exception is the one being just rethrown".
In that case, when __end_catch finds that the exception
exits its last catch block, it will not delete it.
Instead, the exception will just be popped from the stack.
As a result, the exception being rethrown remains on the caught
stack until you exit the last catch that caught it,
and then becomes referred to only through the exception object
passed in the runtime
(that is, it becomes similar to a new exception being thrown:
it does not appear in the caught stack.)
This is the "stack + 1" model I mentioned...

<p>
__begin_catch clears the flag,
in case you catch the rethrown exception before
exiting the last catch handler.

<p>
This mechanism is actually correctly specified in the description of
__cxa_end_catch (see in particular the last bullet):

<p>
Upon exit from the handler by any means,
the epilogue calls __cxa_end_catch(),
which:
<ul>
<li>
Locates the most recently caught exception and decrements its handler count.
<li>
Removes the exception from the "caught" stack if the handler count
goes to zero.
<li>
Destroys the exception if the handler count goes to zero,
and the exception was not re-thrown by throw.
</ul>

<font color=red>
<p>
What is unclear, though,
is the fact that __rethrow needs to pass a flag to
__end_catch for that purpose,
and also that the flag is stored in the high bit of the handlerCount
(which is why it did not appear in the specification...).
</font>

<p>
<font color=blue><hr><p>[000112 editor]</font>
Does this mean that the specification on pg. 16 of the HP document
is the desired definition?

<p>
<font color=blue>[000126 editor]</font>
The answer to the above question is yes.
This issue is effectively closed,
but I will not close it officially until the
<a href=exceptions.pdf>working paper</a>
reflects the clarifications in the email discussion.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D15></a> <td> D-15 </td>
<td> Terminate handler and threads </td>
<td> lib </td>
<td> closed </td>
<td> all </td>
<td> 991216 </td>
<td> 000106 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define how the terminate and unexpected handler registration
interacts with threads.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D15> Resolution</a></b>:
Handler registration applies to all threads.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=D16></a> <td> D-16 </td>
<td> Exception specifications </td>
<td> lib </td>
<td> closed </td>
<td> all </td>
<td> 991216 </td>
<td> 000113 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How is the type list for an exception specification
represented in the action records?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#D16> Resolution</a></b>:
As specified in the HP document
</td> </tr>

</table>


<p> <hr> <p>
<h3> Template Instantiation Model Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>


<tr> </tr>
<tr> <th> E </th>
<th colspan=6> Template Instantiation Model </th>
</tr>

<tr> <a name=E1></a> <td> E-1 </td>
<td> When does instantiation occur? </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
There are two principal models for instantiation.
The <i>early instantiation</i> (or Borland) model performs all
instantiation at compile time,
potentially resulting in extra copies which are removed at link time.
The <i>pre-link instantiation</i> model identifies the required
instantiations prior to linking and instantiates them via a special
compile step.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=E2></a> <td> E-2 </td>
<td> Separate compilation model </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[SGI]
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=E3></a> <td> E-3 </td>
<td> Template repository </td>
<td> tools </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Independent of the template instantiation model,
we need to make sure that whatever template persistent storage is used
by one vendor does not interact negatively with other vendors' mechanisms.
Issues:
  (1) Avoiding conflict on the name of any repository.
  (2) If .o files are used,
	describe how this information is to be preserved, ignored, etc.
  (3) Evaluate if tools such as make, ld, ar, or others, can
	break because .o files get written at unexpected times.
</td> </tr>

</table>

<p> <hr> <p>
<h3> Name Mangling Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F1></a> <td> F-1 </td>
<td> Mangling convention </td>
<td> call </td>
<td> closed </td>
<td> SGI </td>
<td> 990520 </td>
<td> 000330 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What rules shall be used for mangling names,
i.e. for encoding the information other than the source-level object
name necessary to resolve overloading?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#F1> Resolution</a></b>:
See the <a href=abi-layout.html#mangling>ABI Layout</a> document.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F2></a> <td> F-2 </td>
<td> Mangled name size </td>
<td> call g </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Typical name mangling schemes to date typically begin to produce very
long names.  SGI routinely encounters multi-kilobyte names,
and increasing usage of namespaces and templates will make them worse.
This has a negative impact on object file size, and on linker speed.
<p>
SGI has considered solutions to this problem including modified string
tables and/or symbol tables to eliminate redundancy.
Cygnus, HP, and Sun have also considered or implemented approaches
which at least mitigate it.
</td> </tr>

</table>

<p>
<font color=blue>[991028 all]</font>
Cygnus and Sun use a mangling scheme which has proven extremely
effective at compression, but not overly complex.
Each time the mangler incorporates a type into a name,
it remembers it and assigns it a number,
and subsequent occurrences of the type in the name are replaced by
the (escaped) number.
Jason believes this might be adequate compression,
without going to large character sets or more complex schemes.

<p>
<font color=blue>[991115 SCO -- Jonathon]</font>
In a discussion with Matt Austern I suggested using a
collision-resistant hash function on the manglings to generate the
names actually used in object files.
(The algorithm is: first mangle, then hash.)
This could really reduce .o size a ton;
think expression templates, etc.
I bet this would have a much bigger impact that any
obvious compression algorithm; you could just decree that all symbols
be no longer than 256 bits long, say.
Lots of tools (assemblers, debuggers) will use less space/time
dealing with the shorter names.
You would keep around a table mapping hashes back to the original
mangled names for debugging.

<p>
An interesting twist on this would be to use a secure hash with a key.
For ordinary compilation, use some well-known key.
But, by setting some flag/environment-variable you could tell the
compiler to use a key of your choice.
You can now distribute a .o that is hard to link to --
unless you know the key.

<p>
&lt;After a request for clarification...>

<p>
A collision-resistant hash function is a notion from cryptography.
(That's the world I spend a lot of my time in when I'm not doing
compiler stuff.)

<p>
Suppose you have an n-bit hash, so you have 2^n hash values.
A collision-resistant hash is one where the probability of two randomly
chosen strings hashing to the same value is (very close to) 1/(2^n).
A stronger notion of this is that finding strings that collide is
computationally infeasible.

<p>
Certainly, hashing introduces a probabilistic nature to things:
it becomes possible that two different functions could hash to the same
hash-mangled name.
However, by choosing a good hash function (and provably good ones exist)
and enough bits,
you can make it considerably less likely that in the next hundred years
two distinct functions will hash to the same name,
than that cosmic rays will cause unpredicatable linker errors.

<p>
... this (the assumption that mangling is reversible,
as the basis for such things as the c++filt tool)
is the biggest objection I can think of.  

<p>
We originally came up with this idea for our C++-to-C translator.
We ship this to people with embedded systems whose linkers only support
16-characters;
by using a collision-resistant hash they can use C++.
Nobody has ever run into a collision.
We solved the c++-filt problem
by keeping a database mapping hashes back to mangled names.
(The probabilistic guarantee says that this database can actually be
global; in our lifetime will never see two things with the same hash.)
So, it's still possible to make a c++-filt that works,
but it is admittedly more difficult.

<p>
The biggest advantage to this scheme is that you can put an upper
bound on symbol lengths,
even if the presence of truly huge template usage.
(I've seen programs where mangled names approached a megabyte in length.)
I would only suggest hashing long names;
names under 100 characters, or even a thousand characters, say,
could be left unhashed.



<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F3></a> <td> F-3 </td>
<td> Consistency checks
</td>
<td> call g </td>
<td> open </td>
<td> SGI </td>
<td> 990520 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define a mechanism to support consistency checks, e.g. in the linker,
in cases where the Standard forbids inconsistency but does not require
detection.
</td> </tr>

</table>

<p>
<font color=blue>[991028 all]</font>
In a number of cases,
the Standard requires consistent definitions in different places,
even in different files,
but does not require the implementation to detect and report
inconsistency.
With a small amount of extra information,
the linker could often detect and report such inconsistencies.
Also, there are cases where the linker can already detect a problem,
but could provide a better diagnostic with more information.

<p>
Several examples are:

<ul>
<p>
<li>
A template instantiation may conflict with a full specialization
(in different translation units).

<p>
<li>
Functions may be declared with different exceptions specifications.

<p>
<li>
Functions may be declared with different return types.

<p>
<li>
Template formal parameter names would help improve instantiation error
messages.

</ul>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F4></a> <td> F-4 </td>
<td> Empty throw specs
</td>
<td> call g </td>
<td> open </td>
<td> HP </td>
<td> 990930 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
It is useful to be able to identify functions with empty throw specifications,
to allow calling of unexpected() from the runtime during unwinding.
Can this specification be merged into the function's name mangling?
</td> </tr>

</table>

<p>
<font color=blue>[000330 all]</font>
We discussed this subject right after that of mangling the return type
of all functions.
In both cases there is significant concern that we would break enough
"working" but incorrect code to create significant customer problems.
We agreed to think about this issue for a short while (a week or two),
and try to get some data to evaluate the risk,
since doing either of these would also help catch problems.
Jim will also extract the SGI interface specification ELF section,
look at adding throw specifications to it,
and distribute it for consideration.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F5></a> <td> F-5 </td>
<td> ILP32 vs. LP64
</td>
<td> call </td>
<td> open </td>
<td> HP </td>
<td> 000210 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
This ABI focusses on the LP64 data model.
What should we do (if anything) to support
(a) compatibility between different vendors' ILP32 compilers
(b) compatibility between ILP32 and LP64?
</td> </tr>

</table>

<p>
<font color=blue>[000210 All -- Matt]</font>
HP will be supporting an ilp32 model as well as as an lp64 model.
The ABI only discusses an lp64 model.
Do we want to support ilp32 in any way?
What will we have to do to support
(a) compatibility between different vendors' ilp32 compilers, or
(b) compatibility between ilp32 and lp64?
HP has suggested, for example,
modifying the mangling scheme so that long long in ilp32
is mangled the same way as long in lp64.
Is this enough to ensure ilp32/lp64 link compatibility,
or would we need to make many other changes as well?

<p>
<font color=blue>[000217 All]</font>
The group observed that one can prevent all incorrect linkage by using
a different version prefix for LP64 and ILP32 mangling.
Christophe would prefer to just mangle those types that are different
differently, so as not to prevent linkage when it would work.
It is not clear whether mixed models are workable enough to make such a
complication useful.
Christophe will produce a concrete proposal to discuss once the base
mangling is settled enough to base it on.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F6></a> <td> F-6 </td>
<td> Demangling
</td>
<td> call </td>
<td> lib </td>
<td> Cygnus </td>
<td> 000210 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Users may sometimes want to get demangled names.
Should we provide an entry point for calling a demangler?
</td> </tr>

</table>

<p>
<font color=blue>[000210 all -- Matt]</font>
Users have access to types' mangled names via the standard type_info class.
Users may sometimes want to get demangled names.
Should we provide an entry point for calling a demangler?
This might be a standalone function,
perhaps with an interface like that of EDG's demangle(),
or it might be some kind of type_info extension.
If we do this,
should we attempt to specify exactly what demangled names look like,
or should we explicitly leave it unspecified and warn users
not to depend on the exact format?

<p>
<font color=blue>[000321 HU-Berlin -- Martin]</font>
Suggestion:
<code><pre>
  namespace abi {
    std::string demangle_mangled_name (const char*);	// &lt;mangled-name>
    std::string demangle_type (const char*);		// &lt;type>
  }
</pre></code>

<p>
<font color=blue>[000330 all]</font>
The problem with the suggested interface is that using std::string
requires sucking in half the standard library.
An alternate proposed is that the user pass in a buffer,
with a NULL pointer causing the routine to allocate storage.
Christophe also volunteered to send the HP interface,
though it is a bit heavyweight.

<p>
<font color=blue>[000330 HP -- Christophe]</font>
Here is the interface HP offers today.
As I said, it seems overly complicated,
compared to what Matt proposed.
On the plus side, it has handling of erroneous input,
which I believe we need to define.

<code><pre>
class TDemangler {
  
public:
  void * operator new(size_t size) {
    return (void*)malloc(size);
  }

  void operator delete(void *deadObject) {
    free(deadObject);
  }

  TDemangler();
  TDemangler(const char *mangledDecl);
  ~TDemangler();

  enum Status { OK, Empty, Error, Truncated };
    
  void reset();
  Status getStatus() const { return status; }
  Status demangleDecl(const char *mangledDecl);
  Status demangleType(const char *mangledType);
  Status copy(char *result, size_t maxToCopy /*including null*/) const;
  Status copy(char *result, size_t maxToCopy /*including null*/,
              char *name, size_t nameLength) const;
    
private:
  Status status;
  const char *p;
  const char *end;
  void partial(bool top, bool typeOfExternalDecl = false);
  void typeName(size_t &baseOffset, size_t &baseLength);
  void templateArgs();
  void writePrefix(const char *text, size_t length);
  void writeSuffix(const char *text, size_t length);
  void writeDuplicate(unsigned offset, unsigned length);
  void writeBaseName(const char *baseName, size_t baseNameLength,
                     size_t classNameOffset, size_t classNameLength);
  enum Spacing { Before, None, After };
  void writeQualifiers(const char *cv, Spacing spacing);
  size_t extractCount();
  void demangleDecl();

  char *buffer;
  size_t bufferSize;
  enum { InternalBufferSize = 200 };
  char internalBuffer[InternalBufferSize];
  size_t nameSize;
  size_t prefixSize;
  size_t suffixSize;
  bool spaceBeforeName;
  void makeAvailable(size_t length);
  void merge();
  static size_t min(size_t a, size_t b) { return a < b ? a : b; }
};
</pre></code>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F7></a> <td> F-7 </td>
<td> Mangling statics </td>
<td> call </td>
<td> open </td>
<td> HP </td>
<td> 000223 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
What, if anything, should we do about mangling the names of objects in
static functions in case a compiler chooses to inline them?
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F8></a> <td> F-8 </td>
<td> Identifiers with unicode letters </td>
<td> call </td>
<td> open </td>
<td> HU-Berlin </td>
<td> 000323 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How should we mangle names containing unicode letters?
</td> </tr>

</table>

<p>
<font color=blue>[000323 HU-Berlin -- Martin]</font>
2.2, [lex.charset]/2, allows usage of universal-character-names in
C++ programs, especially in identifiers and strings.
How do we mangle the variable pi below?

<code><pre>
   namespace newmath {
      const long double \u03A0 = 3.14159265358979;
   }

</pre></code>

<p>
This is also an issue for C99, so it may be that the base ABI has a
specification; we'd have to follow that at least for extern "C" names.
If not, I propose that such names are encoded in UTF-8.


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=F9></a> <td> F-9 </td>
<td> Strings with unicode letters </td>
<td> call </td>
<td> open </td>
<td> HU-Berlin </td>
<td> 000323 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How should we handle the object file representation of narrow and wide
string literals containing unicode letters?
</td> </tr>

</table>

<p>
<font color=blue>[000323 HU-Berlin -- Martin]</font>
2.2, [lex.charset]/2, allows usage of universal-character-names in
C++ programs, especially in identifiers and strings.
Consider the example:

<code><pre>
    wchar_t MvL[]=L"Martin von L\u00F6wis";
</pre></code>

<p>
First, what is sizeof(wchar_t) in the base ABI? I'll assume 4 for
the moment. Then, the question comes down to: What is the execution
character set, and the wide execution character set? 2.2/3 says
they are implementation-defined, so I guess we must define
them. Typically, people expect this to be a run-time setting (which
is a reasonable assumption), but it kind-of breaks for string
literals.

<p>
Proposal: The wide execution character set is UCS-4.
The execution-character-set is "as-is",
i.e. bytes from the source character set are
copied unmodified to the object file.
Universal-character-names appearing in narrow (ie. char)
strings are not portable in this ABI
(the other alternatives would be to say they are Latin-1,
or encoded as UTF-8, I guess).




<p> <hr> <p>
<h3> Miscellaneous Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=G1></a> <td> G-1 </td>
<td> Basic command line options </td>
<td> tools </td>
<td> open </td>
<td> HP </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Can we agree on basic command line options (compiler and linker)
for fundamental functionality,
possibly allowing portable makefiles?
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=G2></a> <td> G-2 </td>
<td> Detection of ODR violations </td>
<td> call </td>
<td> open </td>
<td> Sun </td>
<td> 990603 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
[Sun]
(See also F-3.)
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=G3></a> <td> G-3 </td>
<td> Inlined routine linkage </td>
<td> call </td>
<td> closed </td>
<td> Sun </td>
<td> 990603 </td>
<td> 991202 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Inline routines with external linkage require a method of handling
vague linkage (see B-5 for definition) for the out-of-line instance,
as well as for any static data they contain.
The latter includes string constants per [7.1.2]/4.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#G3> Resolution</a></b>:
Out-of-line instances are emitted where required,
using COMDAT (issue B-5).
Static data referenced will be placed in COMDAT sections as well.
The names of each are addressed as part of mangling (issue F-1).
Strings will be emitted in SHT_MERGE/SHT_STRING sections,
with the static linker responsible for removing duplicates.
</td> </tr>

</table>



<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=G4></a> <td> G-4 </td>
<td> Dynamic init of local static objects and multithreading </td>
<td> call </td>
<td> open </td>
<td> SCO </td>
<td> 990607 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The Standard requires that local static objects with dynamic
constructors be initialized exactly once, the first time the containing
scope is entered.
Multi-threading renders the simple check of a flag before
initialization inadequate to prevent multiple initialization.
Should the ABI require locking for this purpose,
and if so, what are the necessary interfaces?
In addition to the locking of the initialization,
special exception handling treatment is required to deal with an
exception during construction.
</td> </tr>

</table>

<p>
<font color=blue><hr><p>[990607 SCO -- Jonathan]</font>
The standard is mute on multiple threads of control in general, so 
there is no requirement in the language to support what I'm talking
about. But as a practical matter compilers have to do it (Watcom gave
a paper on their approach during the standardization process, if I
remember).  This example using UI/SVR4 threads will usually show
whether a compiler does it or not: 

<pre><code>
thr5.C:
// static local initialization and threads

#include <stdlib.h>
#define EXIT(a) exit(a)
#define THR_EXIT() thr_exit(0)

#include <thread.h>

int init_count = 0;
int start_count = 0;

int init()
{
  
        ::thr_yield();
        return ++init_count;
}

void* start(void* s)
{
  
        start_count++;
        static int i = init();
        if (i != 1) EXIT(5);
        THR_EXIT();
        return 0;
}
                
int main()
{
  
        thread_t t1, t2;
        if (::thr_create(0, 0, start, 0, 0L, &t1) != 0) EXIT(1);
        if (::thr_create(0, 0, start, 0, 0L, &t2) != 0) EXIT(2);
        if (::thr_join(t1, 0, 0) != 0) EXIT(3);
        if (::thr_join(t2, 0, 0) != 0) EXIT(4);
        if (start_count != 2)
                EXIT(6);
        if (init_count != 1)
                EXIT(7);
        THR_EXIT();
}
</code></pre>

<p>
When compiled with CC -Kthread thr5.C on UnixWare 7, for instance,
it passes by returning 0.  When compiled with CC -mt thr5.C on
Solaris/x86 C++ 4.2 (sorry don't have the latest version!), it
fails by returning 5.


<p>
<font color=blue><hr><p>[990607 Sun -- Mike Ball]</font>
As far as I can tell, the language says that the automatic blocking 
issue isn't a valid approach.  It says what has to happen, and
it isn't that.

<p>
If you look at the entire statement you find that it reads:
<quote>
"Otherwise such an object is initialized the first time control passes
through its declaration; such an object is considered initialized upon
the completion of its initialization.
If the initialization exits by throwing an exception,
the initialization is not complete,
so it will be tried again the next time control enters the declaration.
If control re-enters the declaration (recursively)
while the object is being initialized,
the behavior is undefined."
</quote>

<p>
The word "recursively" is normative,
so eliminates that sentence from consideration.

<p>
One can, of course, make any extension to the language,
but in this case I think the extension invalidates some otherwise valid code.

<p>
The sentence I'm referring to is that the object is considered
initialized upon the completion of its initialization.
This is explicit, and the reason for it is covered in the following sentence,
which discusses an initialization that terminates with an exception.
A person catching such an exception has the right to try again
without danger that the static variable will be initialized in the meantime.

<p>
I don't see anything at all to justify semantics that say,
"after initialization is started, Any other threads of control are
blocked until that thread completes the initialization,
unless, of course, it executes by an exception,
in which case the other thread can do the initialization before the
exception handler gets a chance to try again, except...."
 Take an attempt to define the semantics as far as you like.

<p>
The problem is that there is no way for the compiler writer to know
what the programmer really wanted to do.
I can (and will at some other date, if necessary)
come up with scenarios justifying a variety of mutual exclusion policies,
including none.

<p>
The solution is to let the programmer write the mutual exclusion, the
same as we do for every other potential race condition.
It's a real mess, and, I claim, an unwise one to put in as an extension.

<p>
<font color=blue><hr><p>[990608 HP -- Christophe]</font>
The semantics currently implemented in the HP aC++ compiler is as follows:
<ul>
<li> No two thread can enter a static initialization at the same time
<li> Threads are blocked until immediately after the static  
    initialization either succeeds or fails with an exception.
</ul>

<p>
There are details of our implementation that I disagree with, but in  
general, the semantics seem clear and sane, not as convoluted as you  
seemed to imply. In particular, it correctly covers the case where  
the static initialization fails with an exception. Any thread at that  
point can attempt the initialization.

<p>
<font color=blue><hr><p>[990608 SCO -- Jonathan]</font>
Here's what the SCO UnixWare 7 C++ compiler does for IA-32,
from a (slightly sanitized) design document.
 It meets Jim's goal of having no overhead for non-threaded programs
and minimal overhead for threaded programs unless
actual contention occurs (infrequent),
and meets Mike's goal of handling exceptions in the initialization correctly
(although it doesn't guarantee that the thread getting the exception is
the one that gets next crack at initializing the static).
 It's also worth noting that dynamic initialization of local variables
(static or otherwise) is very common in C++,
since that's what most object constructions involve,
so I don't think this case is as rare as Jim does.


<p>
[...] This is in local static variables with dynamic initialization,
where the compiler generates out a static one-time flag to guard the
initialization.
Two threads could read the flag as zero before either of them set it,
resulting in multiple initializations.

<p>
[...] Accordingly, when compilation is done with -Kthread on,
a code sequence will be generated to lock this initialization.  
[...] the basic idea is to have one guard saying whether the
initialization is done (so that multiple initializations do not occur)
and have another guard saying whether initialization is in progress
(so that a second thread doesn't access what it thinks is
an initialized value before the first thread has finished the
initialization).  [...]

<p>
When compiled with -Kthread, the generated code for a dynamic
initialization of a local static variable will look like the
following. guard is a local static boolean, initialized to zero,
generated by the [middle pass of the compiler]. 
Two bits of it are used: the low-order 'done bit'
and the next-low-order 'busy bit'.

<pre><code>
.again:
        movl    $guard,%eax
        testl   $1,(%eax)       // test the done bit
        jnz     .done           // if set, variable is initialized,
done
        lock; btsl  $1,(%eax)   // test and set the busy bit
        jc      .busy
        < init code >           // not busy, do the initialization
        movl    $guard,%eax
        movl    $3,(%eax)       // set the done bit
        jmp     .done
.busy:
        pushl   %eax            // call RTS routine to wait, passing address
        call1   __static_init_wait      // of guard to monitor
        testl   %eax,%eax       // 1 means exception occurred in init code,
        popl    %ecx
        jnz     .again                  // start the whole thing over
.done                                   // 0 means wait finished
</code></pre>

<p>
The above code will work for position-independent code as well.

The complication due to exceptions is:
what happens if the initialization code throws an exception?
The [compiler] EH tables will have set up a special region and flag in
their region table to detect this situation,
along with a pointer to the guard variable.
Because the initialization never completed,
when the RTS sees that it is cleaning up from such a region,
it will reset the guard variable back to both zeroes.
This will free up a busy-waiting thread, if any,
or will reset everything for the next thread that calls the function.

<p>
The idea of the __static_init_wait() RTS routine is to monitor the
value of guard bits passed in, by looping on this decision table:
<pre><code>
    done    busy
    0       0       return 1 in %eax        (EH wipe-out)
    1       1       return 0 in %eax        (no longer busy)
    0       1       continue to wait        (still busy)
    1       0       internal error, shouldn't happen
</code></pre>

<p>
As for how the wait is done [... not relevant for ABI,
although currently we're using thr_yield(),
which may or may not be right for this context].

<p>
<font color=blue><hr><p>[990608 SGI -- Hans]</font>
I'd like to make some claims about function scope static constructor
calls in multithreaded environments.
I personally can't recall ever having used such a construct,
which somewhat substantiates my claims,
but also implies some lack of certainty.
I'd be interested in hearing any arguments to the contrary.

<p>
I believe that these arguments imply that this problem is not important
enough to warrant added ABI complexity or overhead for sequential code.

<p>
Consider the following skeletal example:

<p><code>
f(int x) { static foo a(...); ... }
</code>

<ol>
<p>
<li>
If the constructor argument doesn't depend on the function parameter,
and the code behaves reasonably, it should be possible to rewrite this as

<p><code>
static foo a(...);
<br>
f(int x) { ... }
</code>

<p>
<li>
If I read the standard correctly (and that's a big disclaimer),
the compiler is entitled to perform the above transformation under
conditions that are usually true,
but hard for the compiler to deduce.
Thus code that relies on the initialization occurring during the
execution of f is usually broken.

<p>
<li>
Thus the foo constructor cannot rely on its caller holding any locks.
It must explicitly acquire any locks it needs.

<p>
<li>
It is far preferable to write the transformed form with a file scope
static variable to start with.
The initial form risks deadlock,
since f may be called with locks held which the constructor
can't assume are held.
If it needs one of those locks it will need to reacquire it.
With default mutex semantics that results in deadlock with itself.
(If locks may be reentered,
it may fail in a more subtle manner since the foo constructor may
acquire a monitor lock whose monitor invariant doesn't hold.)

<p>
<li>
File scope static constructor calls aren't a problem and require no locking,
since they are executed in a single thread before main is called or
before dlopen returns.
(Forking a thread in a static constructor should probably be disallowed.
Threads may not have been fully initialized, among other issues.)

<p>
<li>
Static function scope constructor calls which depend on function
arguments are likely to involve a race condition anyway,
if multiple instances of the function can be invoked concurrently.
Any of the calls might determine the constructor parameters.
Thus these aren't very interesting either.
And if they are really needed, they can be replaced with a file scope
static constructor call plus an assignment.

</ol>

<p>
<font color=blue><hr><p>[990607 SCO -- Jonathan]</font>
Hans' argument breaks such local statics into two groups:
those that don't depend upon the function's parameters,
and those that do.
For the latter group, he says:

<pre><i>
> 6) Static function scope constructor calls which depend on function
> arguments are likely to involve a race condition anyway, if multiple
> instances of the function can be invoked concurrently.  Any of the
> calls might determine the constructor parameters.  Thus these aren't
> very interesting either.  And if they are really needed, they can be
> replaced with a file scope static constructor call plus an assignment.
</i></pre>

<p>
I don't agree with these claims.
There are sometimes situations where a group of objects is being processed,
and you want to arbitrarily pick one of them
to serve as an identifier or key for all of them.
 Consider perhaps a golf course scheduler,
which is taking in players and assigning them to foursomes.  
You want to name each foursome by one of the names of the players
(it doesn't matter which one),
such as the "Jones group" or the "Smith group".  
A natural way to program this might be:

<pre><tt>
      void build_foursome(string golfer) {
	  static string group_name(golfer);
	  // process golfer into group group_name ...
      }
</tt></pre>

<p>
Now if the golfers being scheduled are coming from four different databases,
it might be that a thread is running to extract from each database.
Thus build_foursome() might be called concurrently.
That's fine, and there is no need for application-level locks in
either the caller or this function; we don't care which golfer
the group is named after.
We just want the 'static' to work correctly;
what we don't want is a double initialization,
with two different group names being generated for golfers in the same group,
which is possible if the guard code isn't thread-safe.

<p>
Now one can say that this kind of design isn't wise,
or that locks will probably be needed later in this function
to do the rest of the processing, 
or that this can be coded in several other ways.
And that may all be so.
But I think this usage is *reasonable* in this context,
and that as implementors we should get it right.
[Editorial:  Especially with the advent of Java,
threaded application programming is becoming more the norm; 
and language implementations that dodge the challenge and say that
thread support is solely the job of libraries,
may not be looked upon kindly by users.]


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=G5></a> <td> G-5 </td>
<td> Varargs routine interface </td>
<td> call </td>
<td> closed </td>
<td> HU-B </td>
<td> 990810 </td>
<td> 991014 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
The underlying C ABI defines conventions for calling varargs routines.
Does C++ need, or would it benefit from, any modifications or special cases?
How should we pass references or class objects?
Is any runtime library support required?
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#G5> Resolution</a></b>:
No special cases required -- C++ will follow the C varargs ABI.
</td> </tr>

</table>


<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr class=small> <a name=G6></a> <td> G-6 </td>
<td> bool parameters </td>
<td> call </td>
<td> closed </td>
<td> all </td>
<td> 991104 </td>
<td> 991202 </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
How should we pass bool parameters on IA-64?
Choices are to pass them like ABI ints,
or in predicate registers or register pairs.
</td> </tr>
<tr> <td colspan=7>
<b><a href=cxx-closed.html#G6> Resolution</a></b>:
No special treatment -- pass bool like char.
</td> </tr>

</table>


<p> <hr> <p>
<h3> Library Interface Issues </h3>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=H1></a> <td> H-1 </td>
<td> Runtime library DSO name </td>
<td> tools </td>
<td> open </td>
<td> SGI </td>
<td> 990616 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Determine the name of the common C++ runtime library DSO,
e.g. <code>libC.so</code>.
If there are to be vendor-specific support libraries which must coexist
in programs from mixed sources, identify naming convention for them.
</td> </tr>

</table>

<p>
<table border=on cellpadding=3>

<tr>
<th> # </th>
<th> Issue </th> <th> Class </th> <th> Status </th>
<th> Source </th> <th> Opened </th> <th> Closed </th>
</tr>

<tr> <a name=H2></a> <td> H-2 </td>
<td> Runtime library API </td>
<td> lif </td>
<td> open </td>
<td> SGI </td>
<td> 990616 </td>
<td> </td>
</tr>
<tr> <td colspan=7>
<b>Summary</b>:
Define the required entrypoints in the common C++ runtime library DSO,
and their prototypes.
</td> </tr>

</table>

<p> <hr> <p>
<h3><a name=ancient> Ancient Revision History </a> </h3>

<p>
<font color=blue>[000214]</font>
Closed <a href=#A21>A-21</a>, <a href=#A25>A-25</a>.
Additions to <a href=#A23>A-23</a>, <a href=#C4>C-4</a>,
<a href=#F1>F-1</a>, <a href=#F5>F-5</a>.
New issue <a href=#B9>B-9</a>.

<p>
<font color=blue>[000214]</font>
Additions to <a href=#A21>A-21</a>, <a href=#A23>A-23</a>,
<a href=#A24>A-24</a>, <a href=#F1>F-1</a>.
New issue <a href=#F5>F-5</a>.

<p>
<font color=blue>[000204]</font>
Closed <a href=#A22>A-22</a>, <a href=#D11>D-11</a>.
Additions to <a href=#A23>A-23</a>, <a href=#A24>A-24</a>,
<a href=#D12>D-12</a>.
New issue <a href=#A25>A-25</a>.

<p>
<font color=blue>[000131]</font>
Additions to <a href=#A20>A-20</a>, <a href=#A21>A-21</a>,
<a href=#D11>D-11</a>, <a href=#F1>F-1</a>.
New issues <a href=#A22>A-22</a>, <a href=#A23>A-23</a>,
<a href=#A24>A-24</a>, <a href=#C11>C-11</a>, <a href=#C12>C-12</a>.

<p>
<font color=blue>[000121]</font>
Fix links.
Closed <a href=#A19>A-19</a>, <a href=#A20>A-20</a>,
<a href=#D10>D-10</a>, <a href=#D13>D-13</a>.
Additions to <a href=#A21>A-21</a>,
<a href=#D1>D-1</a>, <a href=#D11>D-11</a>,
<a href=#D12>D-12</a>, <a href=#D14>D-14</a>.

<p>
<font color=blue>[000120]</font>
Closed <a href=#A17>A-17</a>, <a href=#A18>A-18</a>,
<a href=#D9>D-9</a>, <a href=#D16>D-16</a>.
Additions to <a href=#A19>A-19</a>.
New issues <a href=#A20>A-20</a>, <a href=#A21>A-21</a>.

<p>
<font color=blue>[000112]</font>
Closed <a href=#A15>A-15</a>, <a href=#A16>A-16</a>,
<a href=#D2>D-2</a>, <a href=#D3>D-3</a>,
<a href=#D8>D-8</a>, <a href=#D15>D-15</a>.
Additions to <a href=#A17>A-17</a>, <a href=#A18>A-18</a>,
<a href=#D9>D-9</a>, <a href=#D11>D-11</a>,
<a href=#D13>D-13</a>, <a href=#D14>D-14</a>, <a href=#D16>D-16</a>.
New issue <a href=#A19>A-19</a> (split from A-17).

<p>
<font color=blue>[000105]</font>
Closed <a href=#D0>D-0</a>.
Additions to <a href=#D1>D-1</a>, <a href=#D9>D-9</a>.
New issues <a href=#D10>D-10</a> to <a href=#D16>D-16</a>.

<p>
<font color=blue>[000103]</font>
Additions to <a href=#A17>A-17</a>.

<p>
<font color=blue>[991230]</font>
Clarify definition of nearly empty class.

<p>
<font color=blue>[991221]</font>
New issues <a href=#A15>A-15</a>, <a href=#A16>A-16</a>,
<a href=#A17>A-17</a>, <a href=#A18>A-18</a>.
Reopened <a href=#C3>C-3</a>.
Additions to <a href=cxx-closed.html#C3>C-3</a> (closed).

<p>
<font color=blue>[991209]</font>
Additions to <a href=#D1>D-1</a>,
<a href=#D2>D-2</a>, <a href=#D3>D-3</a>.
Closed <a href=cxx-closed.html#D4>D-4</a>,
<a href=cxx-closed.html#D7>D-7</a>.

<p>
<font color=blue>[991202]</font>
Additions to <a href=#B4>B-4</a>
(<a href=cxx-closed.html#B4>closed</a>),
<a href=#C2>C-2</a>, <a href=#D0>D-*</a>.
Closed <a href=cxx-closed.html#B1>B-1</a>,
<a href=cxx-closed.html#C1>C-1</a>,
<a href=cxx-closed.html#C3>C-3</a>,
<a href=cxx-closed.html#G3>G-3</a>,
<a href=cxx-closed.html#G6>G-6</a>.

<p>
<font color=blue>[991129]</font>
Additions to <a href=#B1>B-1</a>, <a href=#F2>F-2</a>, <a href=#G3>G-3</a>.
Closed <a href=cxx-closed.html#B5>B-5</a>.

<p>
<font color=blue>[991104]</font>
New issue <a href=#G6>G-6</a>.
Additions to <a href=#C4>C-4</a>.
Closed <a href=cxx-closed.html#C5>C-5</a>,
<a href=cxx-closed.html#C6>C-6</a>,
<a href=cxx-closed.html#C9>C-9</a>.

<p>
<font color=blue>[991028]</font>
Opened <a href=#C9>C-9</a>, <a href=#C10>C-10</a>.
Closed <a href=cxx-closed.html#A6>A-6</a>,
<a href=cxx-closed.html#B6>B-6</a>,
<a href=cxx-closed.html#C10>C-10</a>.
Additions to <a href=#C5>C-5</a>, <a href=#C6>C-6</a>,
<a href=#F1>F-1</a>, <a href=#F2>F-2</a>, <a href=#F3>F-3</a>.

<p>
<font color=blue>[991026]</font>
Additions to <a href=#F1>F-1</a>.

<p>
<font color=blue>[991012]</font>
Closed <a href=cxx-closed.html#B8>B-8</a>,
<a href=cxx-closed.html#G5>G-5</a>.
Additions to <a href=#A6>A-6</a>, <a href=#B5>B-5</a>,
<a href=#C5>C-5</a>.

<p>
<font color=blue>[991012]</font>
Closed <a href=cxx-closed.html#D5>D-5</a>,
<a href=cxx-closed.html#D6>D-6</a>.
Additions to <a href=#B4>B-4</a>, <a href=#B5>B-5</a>,
<a href=#D7>D-7</a>.

<p>
<font color=blue>[991005]</font>
New issue <a href=#F4>F-4</a>.
Additions to <a href=#A6>A-6</a>, <a href=#B5>B-5</a>, <a href=#B6>B-6</a>,
<a href=#C4>C-4</a>, <a href=#D5>D-5</a>, <a href=#D7>D-7</a>.

<p>
<font color=blue>[990929]</font>
Additions to <a href=#D0>D-*</a>, <a href=#D9>D-9</a>.

<p>
<font color=blue>[990914]</font>
Additions to <a href=#B1>B-1</a>, <a href=#D0>D-*</a>, <a href=#D9>D-9</a>.

<p>
<font color=blue>[990908]</font>
New issue <a href=#D9>D-9</a>.
Additions to <a href=#B1>B-1</a>, <a href=#D0>D-*</a>,
<a href=#D2>D-2</a>, <a href=#D4>D-4</a>,
<a href=#D5>D-5</a>, <a href=#D6>D-6</a>.

<p>
<font color=blue>[990901]</font>
Additions to <a href=#A6>A-6</a>, <a href=#B6>B-6</a>.

<p>
<font color=blue>[990825]</font>
Additions to <a href=#A6>A-6</a>, <a href=#B6>B-6</a>,
<a href=#C5>C-5</a>, <a href=#D0>D-*</a>.

<p>
<font color=blue>[990813]</font>
Closed <a href=cxx-closed.html#A11>A-11</a>.
Additions to <a href=#A6>A-6</a>,
<a href=#B1>B-1</a>, <a href=#B6>B-6</a>, <a href=#B8>B-8</a>,
<a href=#C2>C-2</a>,
<a href=#G5>G-5</a>.

<p>
<font color=blue>[990810]</font>
New issue <a href=#G5>G-5</a>.
Additions to <a href=#B6>B-6</a>, <a href=#C2>C-2</a>, <a href=#C3>C-3</a>.

<p>
<font color=blue>[990805]</font>
Closed A-12, A-14, B-3, B-4, B-7, C-7.
Additions to <a href=#A6>A-6</a>, <a href=#A11>A-11</a>,
<a href=#B1>B-1</a>, <a href=#B6>B-6</a>, <a href=#F1>F-1</a>.

<p>
<font color=blue>[990729]</font>
Closed A-7.
Additions to A-11, A-12, C-2.
Summary added for A-12.
New issue A-14.

<p>
<font color=blue>[990727]</font>
Closed B-2, C-8.
Additions to A-9 (closed), C-2.
Summaries added for C-4, C-6, D-1 to D-4.

<p>
<font color=blue>[990720]</font>
Additions to B-2, B-5, C-2, D-1.

<p>
<font color=blue>[990701]</font>
Closed A-3, A-5, A-10, A-13.
Additions to A-6, B-6, B-7, B-8, C-2, C-7.

<p>
<font color=blue>[990625]</font>
Closed A-1, A-2, A-4, A-8, A-9.
Additions to A-3, A-5, A-7, B-4, B-5, B-7, G-3, G-4.
New issues B-6, B-7, B-8, C-7, C-8.

<p>
<font color=blue>[990616]</font>
Added HP summaries.
Added sketchy notes from 990610 discussions (A and B issues).
A-10 was intended by HP as something different than I described,
so it was renamed, and a new issue A-13 opened as an SGI issue.
HP did not submit A-12, so relabeled as Sun's (is that right?).
Added library interface issues, H-1 and H-2.


<p>
<hr>

<p>
Please send corrections to <a href=mailto:dehnert@sgi.com>Jim Dehnert</a>.


</BODY>
</HTML>
